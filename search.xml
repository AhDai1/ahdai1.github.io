<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux网络编程基础</title>
    <url>/2020/09/05/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h1><h2 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h2><p>传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p>
<h2 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a>B/S模式</h2><p>浏览器/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p>
<h1 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p><strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。<br><strong>数据链路层</strong>：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。<br><strong>网络层</strong>：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。<br><strong>传输层</strong>：定义了一些传输数据的协议和端口号，如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。<br><strong>会话层</strong>：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。<br><strong>表示层</strong>：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。<br><strong>应用层</strong>：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</p>
<h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h2><p>TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。</p>
<p>TCP是一种面向连接的、可靠的协议，TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。</p>
<p>UDP是无连接的传输协议，不保证可靠性。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。</p>
<h1 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h1><h2 id="数据包封装"><a href="#数据包封装" class="headerlink" title="数据包封装"></a>数据包封装</h2><p>传输层及其以下的机制由内核提供，应用层由用户进程提供，应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装。<br><img src="https://img-blog.csdnimg.cn/20200213122053413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）<br>数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p>
<h2 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213122226138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>源地址和目的地址是指MAC地址，长度48位，是出厂时固化的。<br>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。最大值1500称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片。</p>
<h2 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a>ARP数据报格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213122429235.png#pic_center" alt="在这里插入图片描述"><br>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。</p>
<h2 id="IP段格式"><a href="#IP段格式" class="headerlink" title="IP段格式"></a>IP段格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213122614798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。</p>
<p>对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节为单位的，最小值为5，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。8位TOS字段有3个位用来指定IP数据报的优先级，还有4个位表示可选的服务类型，还有一个位总是0。</p>
<p>总长度是整个数据报（包括IP首部和IP层payload）的字节数。</p>
<p>每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。</p>
<p>3位标志和13位片偏移用于分片。</p>
<p>TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。</p>
<p>协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。</p>
<h2 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213122856215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>TFTP是基于文本的协议<br>UDP首部：源端口号是客户端的端口号。</p>
<p>目的端口号是TFTP服务的well-known端口号。<br>使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。</p>
<p>一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。</p>
<h2 id="TCP数据报格式"><a href="#TCP数据报格式" class="headerlink" title="TCP数据报格式"></a>TCP数据报格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213123238703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。<br>32位序号、32位确认序号、窗口大小稍后详细解释。<br>4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节<br>如果没有选项字段，TCP协议头最短20字节。<br>URG、ACK、PSH、RST、SYN、FIN是六个控制位</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>C++多态例子与C语言利用函数指针实现多态</title>
    <url>/2020/05/14/C++%E5%A4%9A%E6%80%81%E4%BE%8B%E5%AD%90%E4%B8%8EC%E8%AF%AD%E8%A8%80%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>本程序解释：诸葛亮交给赵云三个锦囊，三种情况下分别打开不同的锦囊。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TIP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">open_tip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	TIP(<span class="built_in">string</span> from, <span class="built_in">string</span> to)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;from = from;</span><br><span class="line">		<span class="keyword">this</span>-&gt;to = to;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">get_from</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;from;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">get_to</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;to;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> from;</span><br><span class="line">	<span class="built_in">string</span> to;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tip1</span>:</span><span class="keyword">public</span> TIP</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tip1(<span class="built_in">string</span> from, <span class="built_in">string</span> to) :TIP(from, to)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">open_tip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"打开了锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"此锦囊由"</span> &lt;&lt; get_from() &lt;&lt; <span class="string">"写给"</span> &lt;&lt; get_to() &lt;&lt; <span class="string">"的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内容是:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"一到东吴就拜会乔国老"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tip2</span> :</span><span class="keyword">public</span> TIP</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tip2(<span class="built_in">string</span> from, <span class="built_in">string</span> to) :TIP(from, to)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">open_tip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"打开了锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"此锦囊由"</span> &lt;&lt; get_from() &lt;&lt; <span class="string">"写给"</span> &lt;&lt; get_to() &lt;&lt; <span class="string">"的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内容是:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"如果主公乐不思蜀，就谎称曹贼来袭"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tip3</span> :</span><span class="keyword">public</span> TIP</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tip3(<span class="built_in">string</span> from, <span class="built_in">string</span> to) :TIP(from, to)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">open_tip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"打开了锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"此锦囊由"</span> &lt;&lt; get_from() &lt;&lt; <span class="string">"写给"</span> &lt;&lt; get_to() &lt;&lt; <span class="string">"的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内容是:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"如果被孙权追杀，向孙尚香求救"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_tips</span><span class="params">(TIP *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tp-&gt;open_tip();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tip1 *t1 = <span class="keyword">new</span> tip1(<span class="string">"孔明"</span>, <span class="string">"赵云"</span>);</span><br><span class="line">	tip2 *t2 = <span class="keyword">new</span> tip2(<span class="string">"孔明"</span>, <span class="string">"赵云"</span>);</span><br><span class="line">	tip3 *t3 = <span class="keyword">new</span> tip3(<span class="string">"孔明"</span>, <span class="string">"赵云"</span>);</span><br><span class="line">	open_tips(t1);</span><br><span class="line">	open_tips(t2);</span><br><span class="line">	open_tips(t3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//抽象层</span></span><br><span class="line"><span class="comment">//定义一个拆开锦囊方法的类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(TIPS)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//定义锦囊类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tip</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> from[<span class="number">64</span>];<span class="comment">//谁写的</span></span><br><span class="line">	<span class="keyword">char</span> to[<span class="number">64</span>];<span class="comment">//写给谁的</span></span><br><span class="line">	TIPS *tp;<span class="comment">//相当于抽象类的纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//需要一个打开锦囊的架构函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_tip</span><span class="params">(struct tip *tip_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"打开了锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"此锦囊由"</span> &lt;&lt; tip_p-&gt;from &lt;&lt; <span class="string">"写给"</span> &lt;&lt; tip_p-&gt;to &lt;&lt; <span class="string">"的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"内容是："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	tip_p-&gt;tp();<span class="comment">//发生多态现象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供创建锦囊的方法</span></span><br><span class="line"><span class="function">struct tip* <span class="title">Create_tip</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, TIPS *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tip</span> *<span class="title">temp</span> = (<span class="title">struct</span> <span class="title">tip</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">tip</span>));</span></span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(temp-&gt;from, from);</span><br><span class="line">	<span class="built_in">strcpy</span>(temp-&gt;to, to);</span><br><span class="line">	<span class="comment">//给一个回调函数赋值，一般称为注册回调函数</span></span><br><span class="line">	temp-&gt;tp = tp;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供一个销毁锦囊的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(struct tip *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tp != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(tp);</span><br><span class="line">		tp = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现层</span></span><br><span class="line"><span class="comment">//诸葛亮写了三个锦囊</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tip1_func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"一到东吴就拜会乔国老"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tip2_func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"如果主公乐不思蜀，就谎称曹贼来袭"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tip3_func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"如果被孙权追杀，向孙尚香求救"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//业务层</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建出三个锦囊</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tip</span> *<span class="title">tip1</span> = <span class="title">Create_tip</span>("孔明", "赵云", <span class="title">tip1_func</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tip</span> *<span class="title">tip2</span> = <span class="title">Create_tip</span>("孔明", "赵云", <span class="title">tip2_func</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tip</span> *<span class="title">tip3</span> = <span class="title">Create_tip</span>("孔明", "赵云", <span class="title">tip3_func</span>);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//由赵云进行拆锦囊</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"刚刚来到东吴，赵云打开第一个锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	open_tip(tip1);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"刘备乐不思蜀，赵云打开第二个锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	open_tip(tip2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"孙权大军追杀"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	open_tip(tip3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	destroy(tip1);</span><br><span class="line">	destroy(tip2);</span><br><span class="line">	destroy(tip3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>TCP协议</title>
    <url>/2020/09/05/TCP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="TCP通讯时序"><a href="#TCP通讯时序" class="headerlink" title="TCP通讯时序"></a>TCP通讯时序</h1><p><img src="https://img-blog.csdnimg.cn/20200213153208834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>三次握手<br>1、客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。<br>2、服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。<br>3、客户必须再次回应服务器端一个ACK报文，这是报文段3。<br>数据传输<br>1、客户端发出段4，包含从序号1001开始的20个字节数据。<br>2、服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback。<br>3、客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。<br>四次握手<br>1、客户端发出段7，FIN位表示关闭连接的请求。<br>2、服务器发出段8，应答客户端的关闭连接请求。<br>3、服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。<br>4、客户端发出段10，应答服务器的关闭连接请求。</p>
<h1 id="TCP状态转换图"><a href="#TCP状态转换图" class="headerlink" title="TCP状态转换图"></a>TCP状态转换图</h1><p><img src="https://img-blog.csdnimg.cn/20200213153538726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>CLOSED：表示初始状态。</p>
<p>LISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</p>
<p>SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</p>
<p>SYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</p>
<p>ESTABLISHED：表示连接已经建立。</p>
<p>FIN_WAIT_1: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：</p>
<p>FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。</p>
<p>FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用<br>netstat看到。</p>
<p>FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。</p>
<p>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</p>
<p>CLOSING: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是<br>CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭<br>SOCKET连接。</p>
<p>CLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。</p>
<p>LAST_ACK: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>SIGCHILD信号</title>
    <url>/2020/05/19/SIGCHILD%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="SIGCHILD的产生条件"><a href="#SIGCHILD的产生条件" class="headerlink" title="SIGCHILD的产生条件"></a>SIGCHILD的产生条件</h1><p>1、子进程终止时<br>2、子进程接收到SIGSTOP信号停止时<br>3、子进程处在停止态，接受到SIGCONT后唤醒时</p>
<h1 id="子进程结束status处理方式"><a href="#子进程结束status处理方式" class="headerlink" title="子进程结束status处理方式"></a>子进程结束status处理方式</h1><p>函数原型：pid_t waitpid(pid_t pid, int <em>status, int options)<br>*</em>options：**</p>
<p>WNOHANG：没有子进程结束，立即返回</p>
<p>WUNTRACED：如果子进程由于被停止产生的SIGCHLD，waitpid则立即返回</p>
<p>WCONTINUED：如果子进程由于被SIGCONT唤醒而产生的SIGCHLD，waitpid则立即返回</p>
<p><strong>status：</strong><br>    WIFEXITED(status):子进程正常exit终止，返回真<br>    WEXITSTATUS(status):返回子进程正常退出值<br>    WIFSIGNALED(status):子进程被信号终止，返回真<br>    WTERMSIG(status):返回终止子进程的信号值<br>    WIFSTOPPED(status):子进程被停止，返回真<br>    WSTOPSIG(status):返回停止子进程的信号值<br>    WIFCONTINUED(status):子进程接收到SIGCONT信号继续执行</p>
<h1 id="借助SIGCHILD信号回收子进程"><a href="#借助SIGCHILD信号回收子进程" class="headerlink" title="借助SIGCHILD信号回收子进程"></a>借助SIGCHILD信号回收子进程</h1><p>解释:子进程结束运行，其父进程会收到SIGCHLD信号。该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="comment">//如果用if 在linux内核中，收到多个信号，只会记录一个信号</span></span><br><span class="line">	<span class="comment">//用if的话只会回收其中的某些子进程</span></span><br><span class="line">	<span class="keyword">while</span>((pid = waitpid(<span class="number">0</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"child %d exit %d\n"</span>,pid, WEXITSTATUS(status));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"child %d cancel signal %d\n"</span>,pid, WTERMSIG(status));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">//阻塞SIGCHLD</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">			sys_err(<span class="string">"fork "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(n--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"child ID %d\n"</span>,getpid());</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span> )<span class="comment">//父进程捕捉SIGCHILD信号</span></span><br><span class="line">	&#123;</span><br><span class="line">		struct sigaction act;</span><br><span class="line">		act.sa_handler = do_sig_child;</span><br><span class="line">		sigemptyset(&amp;act.sa_mask);</span><br><span class="line">		act.sa_flags = <span class="number">0</span>;</span><br><span class="line">		sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"parent ID %d\n"</span>, getpid());</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP服务器</title>
    <url>/2020/09/06/UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>UDP不需要在数据传输之前建立、维护连接。只专心获取数据就好。省去了三次握手的过程，通信速度可以大大提高，但与之伴随的通信的稳定性和正确率便得不到保证。</p>
<h1 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C/S模型"></a>C/S模型</h1><p><img src="https://img-blog.csdnimg.cn/20200217112900490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="keyword">int</span> sfd;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="keyword">int</span> i, n;</span><br><span class="line">        sfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        bind(sfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Accepting connections\n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                n = recvfrom(sfd, buf, BUFSIZ, <span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>) </span><br><span class="line">                        perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)), ntohs(clie_addr.sin_port));</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                n = sendto(sfd, buf, n , <span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>) </span><br><span class="line">                perror(<span class="string">"sendto error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> sfd, n;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        sfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;serv_addr.sin_addr);</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        <span class="keyword">while</span>(fgets(buf, BUFSIZ, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                n = sendto(sfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>) </span><br><span class="line">                        perror(<span class="string">"sendto error"</span>);</span><br><span class="line">                n = recvfrom(sfd, buf, BUFSIZ, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//NULL不关心对端</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>) </span><br><span class="line">                        perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">                <span class="built_in">write</span>(STDOUT_FILENO, buf, n); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Socket编程</title>
    <url>/2020/09/05/Socket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200213154454718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。</p>
<h1 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h1><p>TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。如果主机是大端字节序的，发送和接收都不需要做转换。</p>
<h2 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h2><pre><code>#include &lt;arpa/inet.h&gt;
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);</code></pre><h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><pre><code>#include &lt;arpa/inet.h&gt;
int inet_pton(int af, const char *src, void *dst);
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code></pre><h1 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a>网络套接字函数</h1><h2 id="socket模型"><a href="#socket模型" class="headerlink" title="socket模型"></a>socket模型</h2><p><img src="https://img-blog.csdnimg.cn/20200213154852852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int socket(int domain, int type, int protocol);</code></pre><p>domain:<br>AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址<br>AF_INET6 与上面类似，不过是来用IPv6的地址<br>AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</p>
<p>type:<br>SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。<br>SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。<br>SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。<br>SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。<br>SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</p>
<p>protocol:<br>传0 表示使用默认协议。</p>
<p>返回值：<br>成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno</p>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号<br>    #include &lt;sys/types.h&gt;<br>    #include &lt;sys/socket.h&gt;<br>    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>sockfd：<br>socket文件描述符</p>
<p>addr:<br>构造出IP地址加端口号</p>
<p>addrlen:<br>sizeof(addr)长度</p>
<p>返回值：<br>成功返回0，失败返回-1, 设置errno</p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int listen(int sockfd, int backlog);</code></pre><p>sockfd:<br>socket文件描述符</p>
<p>backlog:<br>排队建立3次握手队列和刚刚建立3次握手队列的链接数和</p>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></pre><p>sockdf:<br>socket文件描述符</p>
<p>addr:<br>传出参数，返回链接客户端地址信息，含IP地址和端口号</p>
<p>addrlen:<br>传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小</p>
<p>返回值：<br>成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno</p>
<p>addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。</p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><p>sockdf:<br>socket文件描述符</p>
<p>addr:<br>传入参数，指定服务器端地址信息，含IP地址和端口号</p>
<p>addrlen:<br>传入参数,传入sizeof(addr)大小</p>
<p>返回值：<br>成功返回0，失败返回-1，设置errno</p>
<h1 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ];</span><br><span class="line">        <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line">        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client IP :%s, client port = %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                n = Read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                Write(cfd, buf, n);</span><br><span class="line">        &#125;</span><br><span class="line">        Close(lfd);</span><br><span class="line">        Close(cfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">int</span> cfd, n;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> serv_addr_len;</span><br><span class="line">        cfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        inet_pton(AF_INET, SERV_IP , &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">        Connect(cfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">int</span> r = Write(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"write  %d\n"</span>, r); </span><br><span class="line">                n = Read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"read len %d\n"</span>, n); </span><br><span class="line">                Write(STDOUT_FILENO, buf, n); </span><br><span class="line">        &#125;</span><br><span class="line">        Close(cfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="出错处理封装函数"><a href="#出错处理封装函数" class="headerlink" title="出错处理封装函数"></a>出错处理封装函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        perror(s);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *salenptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//start:</span></span><br><span class="line">                <span class="keyword">if</span> ((n = accept(fd, sa, salenptr)) &lt; <span class="number">0</span>)  </span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line">                                <span class="comment">//goto start;</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                perr_exit(<span class="string">"accept error"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">return</span> n;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> ((n = bind(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">                perr_exit(<span class="string">"bind error"</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        n = <span class="built_in">connect</span>(fd, sa, salen);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)  </span><br><span class="line">        &#123;</span><br><span class="line">                perr_exit(<span class="string">"connect error"</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> ((n = <span class="built_in">listen</span>(fd, backlog)) &lt; <span class="number">0</span>)</span><br><span class="line">                perr_exit(<span class="string">"listen error"</span>);</span><br><span class="line">                        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n; </span><br><span class="line">        <span class="keyword">if</span> ((n = socket(family, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">                perr_exit(<span class="string">"socket error"</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//start:</span></span><br><span class="line">                <span class="keyword">if</span> ( (n = <span class="built_in">read</span>(fd, ptr, nbytes)) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                                <span class="comment">//goto start;</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//start:</span></span><br><span class="line">                <span class="keyword">if</span> ((n = <span class="built_in">write</span>(fd, ptr, nbytes)) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                                <span class="comment">//goto start;</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> ((n = <span class="built_in">close</span>(fd)) == <span class="number">-1</span>)</span><br><span class="line">                perr_exit(<span class="string">"close error"</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*参三: 应该读取的字节数*/</span>                          <span class="comment">//socket 4096  readn(cfd, buf, 4096)   nleft = 4096-1500</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span>  nleft;              <span class="comment">//usigned int 剩余未读取的字节数</span></span><br><span class="line">        <span class="keyword">ssize_t</span> nread;              <span class="comment">//int 实际读到的字节数</span></span><br><span class="line">        <span class="keyword">char</span>   *ptr;</span><br><span class="line">        ptr = vptr;</span><br><span class="line">        nleft = n;                  <span class="comment">//n 未读取字节数</span></span><br><span class="line">        <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> ((nread = <span class="built_in">read</span>(fd, ptr, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                                nread = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                nleft -= nread;   <span class="comment">//nleft = nleft - nread </span></span><br><span class="line">                ptr += nread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> nleft;</span><br><span class="line">        <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line">        ptr = vptr;</span><br><span class="line">        nleft = n;</span><br><span class="line">        <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (nwritten = <span class="built_in">write</span>(fd, ptr, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">                                nwritten = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nleft -= nwritten;</span><br><span class="line">                ptr += nwritten;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">my_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> read_cnt;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> *read_ptr;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> read_buf[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//while(1)</span></span><br><span class="line">                <span class="comment">//&#123;</span></span><br><span class="line">start:</span><br><span class="line">                        <span class="keyword">if</span> ( (read_cnt = <span class="built_in">read</span>(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span>) &#123;   <span class="comment">//"hello\n"</span></span><br><span class="line">                                <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                                        <span class="keyword">goto</span> start;</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//else </span></span><br><span class="line">                        <span class="comment">//      break;</span></span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line">                read_ptr = read_buf;</span><br><span class="line">        &#125;</span><br><span class="line">        read_cnt--;</span><br><span class="line">        *ptr = *read_ptr++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*readline --- fgets*/</span></span><br><span class="line"><span class="comment">//传出参数 vptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Readline</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> n, rc;</span><br><span class="line">        <span class="keyword">char</span>    c, *ptr;</span><br><span class="line">        ptr = vptr;</span><br><span class="line">        <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rc = my_read(fd, &amp;c)) == <span class="number">1</span>)</span><br><span class="line">                &#123;   <span class="comment">//ptr[] = hello\n</span></span><br><span class="line">                        *ptr++ = c;</span><br><span class="line">                        <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        *ptr = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>epoll</title>
    <url>/2020/09/06/epoll/</url>
    <content><![CDATA[<p>1、创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。</p>
<pre><code>#include &lt;sys/epoll.h&gt;
int epoll_create(int size)</code></pre><p>size：监听数目</p>
<p>2、控制某个epoll监控的文件描述符上的事件：注册、修改、删除。</p>
<pre><code>#include &lt;sys/epoll.h&gt;
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></pre><p>epfd： 为epoll_creat的句柄<br>op： 表示动作，用3个宏来表示：<br>EPOLL_CTL_ADD (注册新的fd到epfd)，<br>EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，<br>EPOLL_CTL_DEL (从epfd删除一个fd)；<br>event： 告诉内核需要监听的事件</p>
<pre><code>struct epoll_event {
__uint32_t events; /* Epoll events /
epoll_data_t data; / User data variable */
};
typedef union epoll_data {
void *ptr;
int fd;
uint32_t u32;
uint64_t u64;
} epoll_data_t;</code></pre><p>EPOLLIN ： 表示对应的文件描述符可以读（包括对端SOCKET正常关闭）<br>EPOLLOUT： 表示对应的文件描述符可以写<br>EPOLLPRI： 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）<br>EPOLLERR： 表示对应的文件描述符发生错误<br>EPOLLHUP： 表示对应的文件描述符被挂断<br>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的<br>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>
<p>3、等待所监控文件描述符上有事件的产生，类似于select()调用。</p>
<pre><code>#include &lt;sys/epoll.h&gt;
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code></pre><p>events： 用来存内核得到事件的集合，<br>maxevents： 告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，<br>timeout： 是超时时间<br>-1： 阻塞<br>0： 立即返回，非阻塞<br>.&gt;0： 指定毫秒<br>返回值： 成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</p>
<h1 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ], str[INET_ADDRSTRLEN];<span class="comment">//缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> lfd, cfd, sfd;</span><br><span class="line">        <span class="keyword">int</span> n, maxfd, maxi, num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">ssize_t</span> efd, res;</span><br><span class="line">        <span class="keyword">int</span> nready;<span class="comment">//接收poll返回值</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">tep</span>, <span class="title">ep</span>[<span class="title">OPEN_MAX</span>];</span><span class="comment">//tep:epoll_ctl参数 </span></span><br><span class="line">                                                <span class="comment">//ep[]:epoll_wait参数</span></span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">        efd =   epoll_create(OPEN_MAX);</span><br><span class="line">        <span class="keyword">if</span>(efd == <span class="number">-1</span>) </span><br><span class="line">                perr_exit(<span class="string">"epoll create error"</span>);</span><br><span class="line">        tep.events = EPOLLIN;<span class="comment">//设置为读</span></span><br><span class="line">        tep.data.fd = lfd;</span><br><span class="line">        res = epoll_ctl(efd, EPOLL_CTL_ADD, lfd, &amp;tep);<span class="comment">//将lfd设置到树上</span></span><br><span class="line">        <span class="keyword">if</span>(res == <span class="number">-1</span>) </span><br><span class="line">                perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//每次循环都重新设置select监控信号集</span></span><br><span class="line">        &#123;</span><br><span class="line">                nready = epoll_wait(efd, ep, OPEN_MAX, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">                        perr_exit(<span class="string">"poll error"</span>);</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; nready;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!(ep[i].events &amp; EPOLLIN))<span class="comment">//如果不是读，继续循环</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(ep[i].data.fd == lfd)<span class="comment">//判断满足的是不是lfd</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                                cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);<span class="comment">//不会阻塞</span></span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">"client IP :%s, client port = %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">                                tep.events = EPOLLIN;</span><br><span class="line">                                tep.data.fd = cfd;</span><br><span class="line">                                res = epoll_ctl(efd, EPOLL_CTL_ADD, cfd, &amp;tep);</span><br><span class="line">                                <span class="keyword">if</span>(res == <span class="number">-1</span>)</span><br><span class="line">                                        perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                sfd = ep[i].data.fd;</span><br><span class="line">                                <span class="keyword">if</span>((n = Read(sfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        res = epoll_ctl(efd, EPOLL_CTL_DEL, sfd, <span class="literal">NULL</span>);</span><br><span class="line">                                        <span class="keyword">if</span>(res == <span class="number">-1</span>)</span><br><span class="line">                                                perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line"></span><br><span class="line">                                        <span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, i);</span><br><span class="line">                                        Close(sfd);<span class="comment">//说明客户端先关闭链接</span></span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                                                buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                                        Write(sfd, buf, n);</span><br><span class="line">                                        Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">if</span>(errno == ECONNRESET)<span class="comment">//收到RST</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                                res = epoll_ctl(efd, EPOLL_CTL_DEL, sfd, <span class="literal">NULL</span>);</span><br><span class="line">                                                <span class="built_in">printf</span>(<span class="string">"client[%d] aborted connection\n"</span>, i);</span><br><span class="line">                                                Close(sfd);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">else</span></span><br><span class="line">                                                perr_exit(<span class="string">"read error"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Close(lfd);</span><br><span class="line">        Close(efd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>了解C++默默编写并调用哪些函数</title>
    <url>/2020/10/20/%E4%BA%86%E8%A7%A3C++%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>什么时候一个empyt class不再是个empty class呢？<br><strong>当C++处理它之后。</strong><br>如果自己没有声明，编译器就会为它声明一个copy构造函数、一个copy assignment操作符和一个析构函数。如果也没有声明任何的构造函数，编译器也会声明一个default构造函数，这些函数都是public且inline。<br>如果写下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span>&#123;</span>……&#125;;</span><br></pre></td></tr></table></figure>
<p>就好像写下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Empty()&#123;……&#125;;</span><br><span class="line">	Empty(<span class="keyword">const</span> Empty&amp; rhs)&#123;……&#125;;</span><br><span class="line">	~Empty()&#123;……&#125;;</span><br><span class="line">	Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs)&#123;……&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>唯有这些函数被需要的时候，它们才会被编译器创造出来。<br>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Empty e1;<span class="comment">//default构造函数</span></span><br><span class="line">		<span class="comment">//析构函数</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="function">Empty <span class="title">e2</span><span class="params">(e1)</span></span>;<span class="comment">//copy构造函数</span></span><br><span class="line">e2=e1;<span class="comment">//copy assignment操作符</span></span><br></pre></td></tr></table></figure>
<p>default构造函数和析构函数主要是给编译器一个地方来放置base classes和non-static成员变量的构造函数和析构函数。至于copy构造函数只是单纯的将每一个non-static成员变量拷贝到目标对象。</p>
<p>如果编译为class生出copy assignment操作符，行为基本与copy构造函数如出一辙，但一般而言只有当生出的代码合法且有合适机会证明它有意义。<br><strong>如果class中的成员变量有引用或是const变量，编译器则拒绝为class生出operator=。</strong></p>
<p><strong>总结：</strong><br>    <strong>编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符以及析构函数。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>poll</title>
    <url>/2020/09/06/poll/</url>
    <content><![CDATA[<p>#include &lt;poll.h&gt;<br>    int poll(struct pollfd *fds, nfds_t nfds, int timeout)</p>
<pre><code>struct pollfd {
int fd; /* 文件描述符 /
short events; / 监控的事件 /
short revents; / 监控事件中满足条件返回的事件 */
};</code></pre><p>POLLIN 普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND<br>POLLRDNORM 数据可读<br>POLLRDBAND 优先级带数据可读<br>POLLPRI 高优先级可读数据<br>POLLOUT 普通或带外数据可写<br>POLLWRNORM 数据可写<br>POLLWRBAND 优先级带数据可写<br>POLLERR 发生错误<br>POLLHUP 发生挂起<br>POLLNVAL 描述字不是一个打开的文件<br>nfds 监控数组中有多少文件描述符需要被监控<br>timeout 毫秒级等待<br>-1：阻塞<br>0：立即返回，不阻塞进程<br>.&gt;0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值<br>如果不再监控某个文件描述符时，可以把pollfd中，fd设置为-1，poll不再监控此pollfd，下次返回时，把revents设置为0。</p>
<h1 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ], str[INET_ADDRSTRLEN];<span class="comment">//缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> lfd, cfd, sfd;</span><br><span class="line">        <span class="keyword">int</span> n, maxfd, maxi;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> nready;<span class="comment">//接收poll返回值</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line">    </span><br><span class="line">        client[<span class="number">0</span>].fd = lfd;</span><br><span class="line">        client[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt; OPEN_MAX;i++)</span><br><span class="line">                client[i].fd = <span class="number">-1</span>; </span><br><span class="line">        maxi = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//每次循环都重新设置select监控信号集</span></span><br><span class="line">        &#123;</span><br><span class="line">                nready = poll(client, maxi+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">                        perr_exit(<span class="string">"poll error"</span>);</span><br><span class="line">                <span class="keyword">if</span>(client[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">                &#123;</span><br><span class="line">                        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                        cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);<span class="comment">//不会阻塞</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"client IP :%s, client port = %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">                        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; OPEN_MAX;i++)</span><br><span class="line">                                <span class="keyword">if</span>(client[i].fd &lt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="comment">//保存accept返回的文件描述符</span></span><br><span class="line">                                        client[i].fd = cfd;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        <span class="keyword">if</span>(i == OPEN_MAX)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="built_in">fputs</span>(<span class="string">"too many clients\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        client[i].events = POLLIN;<span class="comment">//设置刚刚返回cfd读</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt; maxi)</span><br><span class="line">                                maxi = i;<span class="comment">//保证maxi存的总是最后一个元素下标</span></span><br><span class="line">                        <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= maxi;i++)<span class="comment">//检测哪个客户端有数据就绪</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span>((sfd = client[i].fd) &lt; <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(client[i].revents &amp; POLLIN)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">if</span>((n = Read(sfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, i);</span><br><span class="line">                                        Close(sfd);<span class="comment">//说明客户端先关闭链接</span></span><br><span class="line">                                        client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                                                buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                                        Write(sfd, buf, n);</span><br><span class="line">                                        Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">if</span>(errno == ECONNRESET)<span class="comment">//收到RST</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                                <span class="built_in">printf</span>(<span class="string">"client[%d] aborted connection\n"</span>, i);</span><br><span class="line">                                                Close(sfd);</span><br><span class="line">                                                client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">else</span></span><br><span class="line">                                                perr_exit(<span class="string">"read error"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Close(lfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>mmap</title>
    <url>/2020/05/16/mmap/</url>
    <content><![CDATA[<h1 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h1><p>mmap()函数将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。</p>
<p>mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read(),write()等操作。</p>
<p><strong>函数原型：</strong><br><strong>void * mmap(void * start, size_t length, int port, int flags, int fd, off_t offsize)**</strong></p>
<p>参数的意义：<br><strong>start:</strong> 指向欲映射的内存初始地址，通常设为NULL，代表让系统自动选定地址，映射成功后返回该地址。</p>
<p><strong>length:</strong> 代表将文件中的多大的部分映射到内存。</p>
<p><strong>port:</strong> 映射区域的保护方式<br>PROT_EXEC：映射区域可被执行<br>PROT_READ：映射区域可被读取<br>PROT_WRITE：映射区域可被写入<br>PROT_NONE：映射区域不能存取</p>
<p><strong>flags:</strong> 影响映射区域的各种属性。</p>
<p>在调用mmap()时必须指定MAP_SHARED或MAP_PRIVATE<br>MAP_FIXED：如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。<br>MAP_SHARED：对映射区域的写入数据会复制回文件内，而且允许其它映射文件的进程共享。<br>MAP_PRIVATE：对映射区域的写入操作会产生一个映射文件的复制，即私人的“写时复制”对此区域的任何修改都不会写回原来的文件内容。<br>MAP_ANONYMOUS：建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。<br>MAP_DENYWRITE：只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。<br>MAP_LOCKED：将映射区域锁定住，这表示该区域不会被置换（swap）。</p>
<p><strong>fd:</strong> 要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。</p>
<p><strong>offset:</strong> 文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。<br>返回值：若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(－1)，错误原因存于errno 中。</p>
<h2 id="通过mmap向文件中写数据"><a href="#通过mmap向文件中写数据" class="headerlink" title="通过mmap向文件中写数据"></a>通过mmap向文件中写数据</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	fd = <span class="built_in">open</span>(<span class="string">"mytest.txt"</span>, O_CREAT | O_RDWR ,<span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"open "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = ftruncate(fd, <span class="number">4</span>);<span class="comment">//将文件大小改为4K</span></span><br><span class="line">	<span class="keyword">if</span>(len == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftruncate "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	p = mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(p == MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"mmap "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">strcpy</span>(p, <span class="string">"abc"</span>);<span class="comment">//写数据</span></span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">int</span> ret = munmap(p, <span class="number">4</span>);<span class="comment">//取消映射文件</span></span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"munmap "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="父子进程通过mmap通信"><a href="#父子进程通过mmap通信" class="headerlink" title="父子进程通过mmap通信"></a>父子进程通过mmap通信</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> fd</span><br><span class="line">	<span class="comment">//fd = open("/dev/zero",O_RDWR);//还可以通过系统文件创建映射区</span></span><br><span class="line">	fd = <span class="built_in">open</span>(<span class="string">"temp"</span>, O_CREAT | O_RDWR, <span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"open "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	unlink(<span class="string">"temp"</span>);<span class="comment">//删除临时文件目录项，使之具备被释放的条件</span></span><br><span class="line">	ftruncate(fd, <span class="number">4</span>);</span><br><span class="line">	p = mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_WRITE | PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//p = mmap(NULL, 4, PROT_WRITE | PROT_READ, MAP_PRIVATE, fd, 0);</span></span><br><span class="line">	<span class="keyword">if</span>(p == MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"mmap "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*p = <span class="number">2000</span>;</span><br><span class="line">		var = <span class="number">1000</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child, *p = %d,var = %d\n"</span>,*p,var);<span class="comment">//父子进程拥有不同的全局变量</span></span><br><span class="line">																								<span class="comment">//val值在父进程中还是为100</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);<span class="comment">//确保数据已经被子进程修改</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"parent, *p = %d,var = %d\n"</span>,*p, var);</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">int</span> ret = munmap(p, <span class="number">4</span>);</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"munmap "</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非血缘关系进程间通信"><a href="#非血缘关系进程间通信" class="headerlink" title="非血缘关系进程间通信"></a>非血缘关系进程间通信</h2><p>启动写端程序时，同时打开读端程序，可以看到数据的持续写入</p>
<h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span> = &#123;</span><span class="number">10</span>, <span class="string">"xiaoming"</span>, <span class="string">'m'</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> *<span class="title">mm</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"./a.out file_shared\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">	ftruncate(fd, <span class="keyword">sizeof</span>(student));</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(<span class="string">"file open "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(mm == MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(<span class="string">"mmap "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//通过while(1)持续向文件中写入数据，可以启动读端程序进行读取</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">memcpy</span>(mm, &amp;student, <span class="keyword">sizeof</span>(student));</span><br><span class="line">		student.id++;	</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	munmap(mm, <span class="keyword">sizeof</span>(student));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(<span class="string">"str"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> *<span class="title">mm</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"./a.out file_shared\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(<span class="string">"mmap "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student), PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"id = %d\tname = %s\t %c\n"</span>,mm-&gt;id, mm-&gt;name, mm-&gt;sex);</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	munmap(mm, <span class="keyword">sizeof</span>(student));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>n皇后问题</title>
    <url>/2021/05/11/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="n皇后Ⅰ"><a href="#n皇后Ⅰ" class="headerlink" title="n皇后Ⅰ"></a>n皇后Ⅰ</h1><p>题目：<br>51. N 皇后<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例 1：</p>
<p>输入：n = 4<br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。</p>
<p><strong>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</strong></p>
<h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>①首先记录每行放置的皇后列下标，以此在每一行可行的位置放一个皇后。<br>②通过回溯法进行逐层选择，最终找到每一个皇后的位置，详细注释在代码中</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;<span class="comment">//记录每一种棋盘</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">board</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>))</span></span>;</span><br><span class="line">        <span class="comment">//'.'表示空，'Q'表示皇后</span></span><br><span class="line">        backtrace(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *board中小于row的行已经摆放完成</span></span><br><span class="line"><span class="comment">        *皇后可以放在row行的符合条件的列中</span></span><br><span class="line"><span class="comment">        *当row超过n时则结束   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;board, <span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size() == row)&#123;<span class="comment">//结束条件</span></span><br><span class="line">            ans.emplace_back(board);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = board[row].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(board, row, col))&#123;<span class="comment">//排除不合法的</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[row][col] = <span class="string">'Q'</span>;<span class="comment">//选择</span></span><br><span class="line">            backtrace(board, row + <span class="number">1</span>);<span class="comment">//进入下一层</span></span><br><span class="line">            board[row][col] = <span class="string">'.'</span>;<span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//判断列是否有皇后</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断右上方是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span>&amp;&amp;j &lt; n; i--, j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断左上方是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span>&amp;&amp;j &gt;= <span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="n皇后Ⅱ"><a href="#n皇后Ⅱ" class="headerlink" title="n皇后Ⅱ"></a>n皇后Ⅱ</h1><p>题目：<br>52. N皇后 II<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p>
<p>示例 1：</p>
<p>输入：n = 4<br>输出：2</p>
<p>解释：如上图所示，4 皇后问题存在两个不同的解法。</p>
<h2 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h2><p>只需要把上一题的代码稍作修改就可以得到此题的答案。<br>将记录每一种摆法改成当满足条件以后将结果加一</p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">board</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>))</span></span>;</span><br><span class="line">        backtrace(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;board, <span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size() == row)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = board[row].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(board, row, col))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">            backtrace(board, row + <span class="number">1</span>);</span><br><span class="line">            board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span>&amp;&amp;j &lt; n; i--, j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span>&amp;&amp;j &gt;= <span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>k个一组翻转链表</title>
    <url>/2021/03/30/k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>假设我们要2个一组翻转链表，我们可以看到本问题有递归思想，也就是reverse(head, 2)，而第二个结点后的内容就是子问题，只要解决了原问题，子问题也就迎刃而解了。<br>首先我们先利用迭代来翻转整条链表</p>
<h1 id="翻转一整条链表"><a href="#翻转一整条链表" class="headerlink" title="翻转一整条链表"></a>翻转一整条链表</h1><p>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;nullptr<br>可以通过三个指针来控制链表进行翻转<br>1&lt;-2-&gt;3-&gt;4-&gt;5-&gt;nullptr<br>1&lt;-2&lt;-3-&gt;4-&gt;5-&gt;nullptr<br>以此往下，改变每一个结点的指向。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">reverse</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *pre, *cur, *nxt;</span><br><span class="line">    pre = <span class="literal">nullptr</span>; cur = head; nxt = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        nxt = cur.next;        </span><br><span class="line">        cur.next = pre；</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="翻转a-b结点"><a href="#翻转a-b结点" class="headerlink" title="翻转a~b结点"></a>翻转a~b结点</h1><p>接下来如果我们想翻转前a~b个结点，我们只需要把第b+1个结点看作上方代码最后一个结点指向的空值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseab</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *pre,*cur,*nxt;</span><br><span class="line">        pre=<span class="literal">nullptr</span>;</span><br><span class="line">        cur=a;</span><br><span class="line">        nxt=a;</span><br><span class="line">        <span class="keyword">while</span>(cur != b)&#123;</span><br><span class="line">            nxt=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>只需要把nullptr编程b结点即可。</p>
<h1 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a>k个一组翻转链表</h1><p>我们只需要利用上述代码，在翻转完前k个结点以后，递归调用本身，继续翻转k+1~2k这个部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *a, *b;</span><br><span class="line">        a=b=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            b=b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newHead = reverseab(a,b);<span class="comment">//翻转后的新头结点</span></span><br><span class="line">        a-&gt;next=reverseKGroup(b,k);<span class="comment">//递归调用本身</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>信封嵌套问题</title>
    <url>/2021/04/15/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。注意：不允许旋转信封。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p>输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]<br>输出：3<br>解释：最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</p>
<h1 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h1><p>输入：envelopes = [[1,1],[1,1],[1,1]]<br>输出：1</p>
<h1 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h1><p>①首先我们可以想到外面的信封高和宽一定都比里面的信封的高和宽要大。<br>②这样就可以想到我们将信封进行排序，然后来找最长递增子序列。<br>③然而这样有一个问题，信封应该按怎么样的顺序排序。是按宽的升序排序还是按高的升序排序？<br>我们可以举个例子：<br>这五封信封应该怎么嵌套，才能保证信封最多？[1, 8],[2, 3],[5, 2],[5, 4],[6, 4],[6. 7]<br>[1, 8]</p>
<p>[2, 3]</p>
<p>[5, 4]</p>
<p>[5, 2]</p>
<p>[6, 7]</p>
<p>[6. 4]<br>这三个信封能保证信封嵌套最多[2, 3]，[5, 4]，[6, 7]。我们可以发现，按照信封的宽进行升序排序，按信封的高进行降序排序。<br>按宽进行升序可以很容易理解，因为外面的信封一定要比里面的信封大，而按高的降序则是因为要保证相同宽的信封只能选择一个。<br>④在排完序以后就可以进行对高进行最长递增子序列查找。<br>⑤对于LIS本题是利用二分法进行。</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = envelopes.size();</span><br><span class="line">        sort(envelopes.begin(), envelopes.end(),</span><br><span class="line">            [&amp;](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">0</span>] &lt; b[<span class="number">0</span>])&#123;<span class="comment">//第一关键字，宽的升序</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>] &gt; b[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];<span class="comment">//第二关键字，高的降序</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">height</span><span class="params">(n,<span class="number">0</span>)</span></span>;<span class="comment">//信封的高单独用一个vetcor存</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            height[i] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lengthLis(height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthLis</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//最长递增子序列长度</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">top</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//对每个元素找到相应的位置</span></span><br><span class="line">            <span class="keyword">int</span> key = nums[i];</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> right = len;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;<span class="comment">//二分</span></span><br><span class="line">                <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(top[mid] &gt;= key)&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left == len)&#123;<span class="comment">//如果该元素已经比所有已找到的递增子序列还要大，</span></span><br><span class="line">               len++;       <span class="comment">//则将该元素放到最后，并将len++</span></span><br><span class="line">            &#125;</span><br><span class="line">            top[left] = key;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>利用分治法寻找第k大的数</title>
    <url>/2021/04/21/%E5%88%A9%E7%94%A8%E5%88%86%E6%B2%BB%E6%B3%95%E5%AF%BB%E6%89%BE%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="数组中的第k的最大元素"><a href="#数组中的第k的最大元素" class="headerlink" title="数组中的第k的最大元素"></a>数组中的第k的最大元素</h1><p>题目：<br>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p>
<h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>①首先我们我们知道快速排序是基于分治法，每一次都将基准放到相应的位置使基准数左边的数都比基准数小，右边的数都比基准数大。<br>②而本题正好可以利用快速排序的思想，逐步找到k这个位置，进而这个位置即答案</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//升序</span></span><br><span class="line">        <span class="keyword">int</span> key=nums[l];<span class="comment">//基准数</span></span><br><span class="line">        <span class="keyword">int</span> start=l;</span><br><span class="line">        <span class="keyword">int</span> end=r;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;<span class="comment">//******如果想要找到第K小的数******//</span></span><br><span class="line">			<span class="comment">//******就把下面&lt;=key的符号变成&gt;=key******//</span></span><br><span class="line">            <span class="keyword">while</span>(start&lt;=end&amp;&amp;nums[start]&lt;=key) start++;<span class="comment">//找到比基准数大的</span></span><br><span class="line">            <span class="keyword">while</span>(start&lt;=end&amp;&amp;nums[end]&gt;=key) end--;<span class="comment">//找到比基准数小的</span></span><br><span class="line">            <span class="keyword">if</span>(start&lt;end)<span class="comment">//将在基准数左边比基准数大的数           </span></span><br><span class="line">            &#123;           <span class="comment">//与在基准数有边比基准数小的数进行交换</span></span><br><span class="line">                swap(nums[start],nums[end]);</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[l],nums[end]);<span class="comment">//将基准数交换到自己的位置</span></span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            index=Partition(nums,left,right);</span><br><span class="line">            <span class="keyword">if</span>(index==( nums.size()-k))&#123;<span class="comment">//因为是升序，如果索引等于倒数第k个数</span></span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index&lt;( nums.size()-k))&#123;<span class="comment">//如果索引小于，则向倒数第k个数靠拢</span></span><br><span class="line">                left=index+<span class="number">1</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index&gt;( nums.size()-k))&#123;<span class="comment">//同上</span></span><br><span class="line">                right=index<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>判断是否回文链表</title>
    <url>/2021/03/30/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h1><p>解答思路：<br>① 首先先找到链表的中间位置。<br>② 将中间位置以后的结点进行翻转。<br>③ 将两个链表从头开始相比，如果每一个结点都相等，则是回文链表。</p>
<h2 id="找到中间结点"><a href="#找到中间结点" class="headerlink" title="找到中间结点"></a>找到中间结点</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">endhalflist</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode *slow,*fast;</span><br><span class="line">        slow=head;</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码代表的是，如果链表结点是奇数，则slow指向的是中间结点，而我们要把slow指向中间结点的下一个。<br>例如：<br>1-&gt;2-&gt;3-&gt;2-&gt;1-&gt;nullptr<br>如果没有这一句判断，那么slow将会指向值为3的这个结点，在后续进行链表比对的时候会出现错误。</p>
<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverselist</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        ListNode *pre,*cur,*nxt;</span><br><span class="line">        pre=<span class="literal">nullptr</span>;cur=head;nxt=head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nxt=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此方法在上两篇文章已经提及，可以参考。</p>
<h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *mid = endhalflist(head);</span><br><span class="line">        mid = reverselist(mid);</span><br><span class="line">        <span class="keyword">while</span>(mid != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val != mid-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            mid=mid-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">endhalflist</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode *slow,*fast;</span><br><span class="line">        slow=head;</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverselist</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        ListNode *pre,*cur,*nxt;</span><br><span class="line">        pre=<span class="literal">nullptr</span>;cur=head;nxt=head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nxt=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="递归判断链表是否回文"><a href="#递归判断链表是否回文" class="headerlink" title="递归判断链表是否回文"></a>递归判断链表是否回文</h1><p>解答思路：<br>将每一个结点压入栈中，然后在弹出的时候进行比对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode *left;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        left=head;</span><br><span class="line">        <span class="keyword">return</span> traverse(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">traverse</span><span class="params">(ListNode *right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> res = traverse(right-&gt;next);</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val != right-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left=left-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>实际上就是一种利用了函数栈的方法。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>全局变量的异步I_O</title>
    <url>/2020/05/18/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%82%E6%AD%A5I_O/</url>
    <content><![CDATA[<p>以一个程序来演示：该程序是父子进程通过一个全局变量进行相互数数。</p>
<h1 id="初级版（存在问题）"><a href="#初级版（存在问题）" class="headerlink" title="初级版（存在问题）"></a>初级版（存在问题）</h1><p>解释:通过flag变量标记程序实行进度。flag置1表示数数完成。flag置0表示给对方发送信号完成。<br>问题出现的位置，在父子进程kill函数之后需要紧接着调用 flag，将其置0，标记信号已经发送。但，在这期间很有可能被kernel调度，失去执行权利，而对方获取了执行时间，通过发送信号回调捕捉函数，从而修改了全局的flag。</p>
<p>程序执行期间会造成程序无法唤醒的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//父子进程相互数数,全局变量的异步IO</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I am child %d\t%d\n"</span>, getpid(), n);</span><br><span class="line">	n += <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	flag = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_parent</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I am parent %d\t%d\n"</span>, getpid(), n);</span><br><span class="line">	n += <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	flag = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(<span class="string">"fork"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n = <span class="number">1</span>;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		act.sa_handler = do_sig_parent;</span><br><span class="line">		sigemptyset(&amp;act.sa_mask);</span><br><span class="line">		act.sa_flags = <span class="number">0</span>;</span><br><span class="line">		sigaction(SIGUSR2, &amp;act, <span class="literal">NULL</span>);<span class="comment">//注册自己的信号捕捉函数</span></span><br><span class="line">		do_sig_parent(<span class="number">0</span>);		<span class="comment">//父使用SIGUSR2信号</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//等待信号</span></span><br><span class="line">			<span class="keyword">if</span>(flag == <span class="number">1</span>)<span class="comment">//父进程数数完成</span></span><br><span class="line">			&#123;</span><br><span class="line">				kill(pid, SIGUSR1);</span><br><span class="line">			<span class="comment">//----如果失去cpu，已给子进程发信号，此时flag = 1</span></span><br><span class="line">			<span class="comment">//子进程数完后给父进程发信号，数完之后，获得cpu</span></span><br><span class="line">			<span class="comment">//标志flag = 0,子进程已经发过信号，都在等待信号</span></span><br><span class="line">			<span class="comment">//所以flag一直会等于0 ，程序停止</span></span><br><span class="line">			<span class="comment">//在子进程同样位置有此时间空档情况</span></span><br><span class="line">				flag = <span class="number">0</span>;<span class="comment">//标志已给子进程发送完信号</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n = <span class="number">2</span>;</span><br><span class="line">		act.sa_handler = do_sig_child;</span><br><span class="line">		sigemptyset(&amp;act.sa_mask);</span><br><span class="line">		act.sa_flags = <span class="number">0</span>;</span><br><span class="line">		sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>);<span class="comment">//父进程数数完成发送SIGUSR1</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)			<span class="comment">//给子进程</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//等待信号</span></span><br><span class="line">			<span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				kill(getppid(), SIGUSR2);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完善版"><a href="#完善版" class="headerlink" title="完善版"></a>完善版</h1><p>通过在信号处理函数中父进程（子进程）数完数以后发送信号给子进程（父进程），避免了程序无法唤醒的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//父子进程交替数数升级版</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>, num1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pid_t</span> son_pid;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"parent\tnum = %d\n"</span>,num1);</span><br><span class="line">	num1 += <span class="number">2</span>;</span><br><span class="line">	kill(son_pid, SIGUSR2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child\tnum = %d\n"</span>, num);</span><br><span class="line">	num += <span class="number">2</span>;</span><br><span class="line">	kill(getppid(), SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act1</span>, <span class="title">act2</span>;</span></span><br><span class="line">	pid = fork();</span><br><span class="line">	son_pid = pid;</span><br><span class="line">	<span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		act1.sa_handler = parent;</span><br><span class="line">		sigemptyset(&amp;act1.sa_mask);</span><br><span class="line">		act1.sa_flags = <span class="number">0</span>;</span><br><span class="line">		sigaction(SIGUSR1, &amp;act1, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);<span class="comment">//让父进程先注册捕获函数</span></span><br><span class="line">		act2.sa_handler = child;</span><br><span class="line">		sigemptyset(&amp;act2.sa_mask);</span><br><span class="line">		act2.sa_flags = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> ret = sigaction(SIGUSR2, &amp;act2, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perr(<span class="string">"sigaction error"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		kill(getppid(), SIGUSR1);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		perr(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>信号</title>
    <url>/2020/05/17/%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="信号的机制和特点"><a href="#信号的机制和特点" class="headerlink" title="信号的机制和特点"></a>信号的机制和特点</h1><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><p>A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。</p>
<p>与硬件中断类似——异步模式。但信号是软件层面上实现的中断，常被称为“软中断”。</p>
<p>信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。</p>
<p><strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、简单<br>2、不能携带大量信息<br>3、满足某个特设条件才发送</p>
<h1 id="信号四要素"><a href="#信号四要素" class="headerlink" title="信号四要素"></a>信号四要素</h1><p>1、编号<br>2、名称<br>3、事件<br>4、默认处理动作<br>默认动作：<br>    Term：终止进程<br>    Ign： 忽略信号 (默认即时对该种信号忽略操作)<br>    Core：终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试)<br>    Stop：停止（暂停）进程<br>    Cont：继续运行进程<br><strong>9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</strong></p>
<h1 id="与信号相关的事件"><a href="#与信号相关的事件" class="headerlink" title="与信号相关的事件"></a>与信号相关的事件</h1><h2 id="递达和未决"><a href="#递达和未决" class="headerlink" title="递达和未决"></a>递达和未决</h2><h3 id="递达"><a href="#递达" class="headerlink" title="递达"></a>递达</h3><p>递达并且到达进程</p>
<h3 id="未决"><a href="#未决" class="headerlink" title="未决"></a>未决</h3><p>产生和递达之间的状态，主要由于阻塞（屏蔽）导致该状态</p>
<h4 id="阻塞信号集（信号屏蔽字）"><a href="#阻塞信号集（信号屏蔽字）" class="headerlink" title="阻塞信号集（信号屏蔽字）"></a>阻塞信号集（信号屏蔽字）</h4><p>将某些信号加入集合，对他们设置屏蔽，当屏蔽某信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)</p>
<h4 id="未决信号集"><a href="#未决信号集" class="headerlink" title="未决信号集"></a>未决信号集</h4><p>1、信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。<br>2、信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。   </p>
<h1 id="信号的处理方式"><a href="#信号的处理方式" class="headerlink" title="信号的处理方式"></a>信号的处理方式</h1><p>第一种是类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理。</p>
<p>第二种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。</p>
<p>第三种方法是，对该信号的处理保留系统的默认值，这种缺省操作，对大部分的信号的缺省操作是使得进程终止。进程通过系统调用signal来指定进程对某个信号的处理行为。</p>
<h1 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h1><p>1、按键产生，如：Ctrl+c、Ctrl+z、Ctrl+<br>2、系统调用产生，如：kill、raise、abort<br>3、软件条件产生，如：定时器alarm<br>4、硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)<br>5、命令产生，如：kill命令</p>
<h2 id="kill函数-命令产生信号"><a href="#kill函数-命令产生信号" class="headerlink" title="kill函数/命令产生信号"></a>kill函数/命令产生信号</h2><p>kill命令产生信号：kill -SIGKILL pid<br>kill函数：给指定进程发送指定信号(<strong>不一定杀死</strong>)<br>函数原型：int kill(pid_t pid, int sig)   成功：0；失败：-1 (ID非法，信号非法，普通用户杀init进程等权级问题)，设置errno</p>
<p>sig：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。<br>pid &gt; 0:  发送信号给指定的进程。<br>pid = 0:  发送信号给 与调用kill函数进程属于同一进程组的所有进程。<br>pid &lt; 0:  取|pid|发给对应进程组。<br>pid = -1：发送给进程有权限发送的系统中所有进程。</p>
<p>进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</p>
<p>权限保护：super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的<br>例如kill -9 (root用户的pid)  是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。普通用户基本规则是：发送者实际或有效用户ID等于接收者实际或有效用户ID</p>
<h2 id="raise和abort函数"><a href="#raise和abort函数" class="headerlink" title="raise和abort函数"></a>raise和abort函数</h2><p>raise 函数：给当前进程发送指定信号(自己给自己发)    <strong>raise(signo) == kill(getpid(), signo)</strong><br>函数原型：int raise(int sig)  成功：0，失败非0值</p>
<p>abort 函数：给自己发送异常终止信号 6) SIGABRT 信号，终止并产生core文件<br>函数原型：void abort(void)  该函数无返回</p>
<h2 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h2><p>作用：设置定时器(闹钟)<br>在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。</p>
<p><strong>每个进程都有且只有唯一个定时器。</strong></p>
<p>函数原型：unsigned int alarm(unsigned int seconds) 返回0或剩余的秒数，无失败。<br><strong>常用：取消定时器使用alarm(0)，返回旧闹钟余下秒数。</strong><br>定时，与进程状态无关(自然定时法)，就绪、运行、挂起(阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm都计时。<br>使用time命令查看程序执行的时间。    </p>
<p><strong>程序运行的瓶颈在于IO，优化程序，首选优化IO。</strong><br>实际执行时间 = 系统时间 + 用户时间 + 等待时间</p>
<h2 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h2><p>作用：设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。<br>函数原型：int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value)    成功：0；失败：-1，设置errno</p>
<p>参数<br>which：指定定时方式<br>1、自然定时：ITIMER_REAL → 14）SIGLAR——计算自然时间<br>2、虚拟空间计时(用户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM——只计算进程占用cpu的时间<br>3、运行时计时(用户+内核)：ITIMER_PROF → 27）SIGPROF——计算占用cpu及执行系统调用的时间</p>
<p><strong>it_interval：用来设定两次定时任务之间间隔的时间<br>it_value：定时的时长<br>两个参数都设置为0，即清0操作。</strong></p>
<h3 id="setitimer函数实现alarm函数，实现计算机1秒数数程序。"><a href="#setitimer函数实现alarm函数，实现计算机1秒数数程序。" class="headerlink" title="setitimer函数实现alarm函数，实现计算机1秒数数程序。"></a>setitimer函数实现alarm函数，实现计算机1秒数数程序。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	struct itimerval </span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		struct timeval</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			it_value.tv_sec;</span></span><br><span class="line"><span class="comment">			it_value.tv_usec;	</span></span><br><span class="line"><span class="comment">		&#125;it_interval;//用来设定两次定时任务之间间隔的时间</span></span><br><span class="line"><span class="comment">		struct timeval</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			it_value.tv_sec;</span></span><br><span class="line"><span class="comment">			it_value.tv_usec;	</span></span><br><span class="line"><span class="comment">		&#125;it_value;//定时的时长</span></span><br><span class="line"><span class="comment">	&#125;it, oldit;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">my_alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> sec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	it.it_value.tv_sec = sec;</span><br><span class="line">	it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">	it.it_interval.tv_sec = <span class="number">0</span>;<span class="comment">//两次定时之间的间隔</span></span><br><span class="line">	it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">	ret = setitimer(ITIMER_REAL, &amp;it, &amp;oldit);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"setitimer\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> oldit.it_value.tv_sec;<span class="comment">//返回剩余的秒数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	my_alarm(<span class="number">1</span>);<span class="comment">//alarm(1);</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用setitimer函数的参数实现定时间隔"><a href="#利用setitimer函数的参数实现定时间隔" class="headerlink" title="利用setitimer函数的参数实现定时间隔"></a>利用setitimer函数的参数实现定时间隔</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">	signal(SIGALRM, myfunc);<span class="comment">//注册SIGALRM信号的捕捉处理函数</span></span><br><span class="line">	it.it_value.tv_sec = <span class="number">5</span>;</span><br><span class="line">	it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">	it.it_interval.tv_sec = <span class="number">3</span>;</span><br><span class="line">	it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(setitimer(ITIMER_REAL, &amp;it, &amp;oldit) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"setitimer error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h1><p>内核通过读取未决信号集来判断信号是否应被处理<br>信号屏蔽字mask可以影响未决信号集。而我们可以在应用程序中自定义set来改变mask。已达到屏蔽指定信号的目的。</p>
<h2 id="信号集设定函数"><a href="#信号集设定函数" class="headerlink" title="信号集设定函数"></a>信号集设定函数</h2><p>sigset_t  set;        // typedef unsigned long sigset_t;<br>int sigemptyset(sigset_t *set)：将某个信号集清0<br>成功：0，失败：-1</p>
<p>int sigfillset(sigset_t *set)：将某个信号集置1<br>成功：0，失败：-1</p>
<p>int sigaddset(sigset_t *set, int signum)：将某个信号加入信号集<br>成功：0，失败：-1</p>
<p>int sigdelset(sigset_t *set, int signum)    ：将某个信号清出信号集<br>成功：0，失败：-1</p>
<p>int sigismember(const sigset_t *set, int signum)：判断某个信号是否在信号集中<br>返回值：在集合：1，不在：0，出错：-1  </p>
<p><strong>sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</strong></p>
<h2 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h2><p>用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB中)<br><strong>严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。</strong><br>函数原型：int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)    成功：0，失败：-1，设置errno<br>参数：<br>set：传入参数，是一个位图，set中哪位置1，就表示当前进程屏蔽哪个信号。oldset：传出参数，保存旧的信号屏蔽集。<br>how参数取值：假设当前的信号屏蔽字为mask。<br>1、SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask = mask|set<br>2、SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask = mask &amp;~set<br>3、SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于 mask = set，若调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</p>
<h2 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h2><p>读取当前进程的未决信号集<br>函数原型：int sigpending(sigset_t *set)    set传出参数。<br>返回值：成功：0，失败：-1，设置errno</p>
<h2 id="所有常规信号的未决状态打印至屏幕"><a href="#所有常规信号的未决状态打印至屏幕" class="headerlink" title="所有常规信号的未决状态打印至屏幕"></a>所有常规信号的未决状态打印至屏幕</h2><p>解释：在程序执行过程中使用终端按键产生信号观察未决信号集的变化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printped</span><span class="params">(<span class="keyword">sigset_t</span> *ped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++)<span class="comment">//打印前31个未决信号集</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">if</span>(sigismember(ped, i) == <span class="number">1</span>)<span class="comment">//判断是否处于未决状态</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">sigset_t</span> myset, oldset, ped;</span><br><span class="line">	sigemptyset(&amp;myset);<span class="comment">//将myset置为空</span></span><br><span class="line">	sigaddset(&amp;myset, SIGQUIT);<span class="comment">//将三个信号添加到信号集中</span></span><br><span class="line">	sigaddset(&amp;myset, SIGINT);</span><br><span class="line">	sigaddset(&amp;myset, SIGTSTP);</span><br><span class="line">	<span class="keyword">int</span> ret = sigprocmask(SIG_BLOCK, &amp;myset, &amp;oldset);<span class="comment">//设置屏蔽信号</span></span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"sigprocmask error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sigpending(&amp;ped);</span><br><span class="line">		printped(&amp;ped);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h1><h2 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h2><p>作用：注册一个信号捕捉函数<br>typedef void (<em>sighandler_t)(int);<br>sighandler_t signal(int signum, sighandler_t handler);<br>*</em>该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。**</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catchsigint</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;catch\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">__sighandler_t</span> handler;</span><br><span class="line">	handler = signal(SIGINT, catchsigint);<span class="comment">//捕捉SIGINT信号</span></span><br><span class="line">	<span class="comment">//当接收到SIGINT信号时，执行信号捕捉函数</span></span><br><span class="line">	<span class="keyword">if</span>(handler == SIG_ERR)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"signal error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h2><p>作用：修改信号处理动作（通常在Linux用其来注册一个信号的捕捉函数）<br>函数原型:int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)<br>成功：0；失败：-1，设置errno</p>
<p>参数：<br>act：传入参数，新的处理方式。<br>oldact：传出参数，旧的处理方式。</p>
<p>struct sigaction结构体<br>struct sigaction {<br>    void     (<em>sa_handler)(int);<br>    void     (</em>sa_sigaction)(int, siginfo_t <em>, void *);<br>    sigset_t   sa_mask;<br>    int       sa_flags;<br>    void     (</em>sa_restorer)(void);<br>};<br>sa_restorer：该元素是过时的，不应该使用，POSIX.1标准将不指定该元素。(弃用)<br>sa_sigaction：当sa_flags被指定为SA_SIGINFO标志时，使用该信号处理程序。(很少使用)<br>1、sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作<br>2、sa_mask: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。<strong>注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</strong><br>3、sa_flags：通常设置为0，表使用默认属性。    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">docatch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d signal is catched\n"</span>,signo);</span><br><span class="line">	<span class="comment">//在此期间SIGQUIT信号被屏蔽，等到睡晚10秒以后SIGQUIT信号会被执行一次</span></span><br><span class="line">	sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">	act.sa_handler = docatch;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	sigaddset(&amp;act.sa_mask, SIGQUIT);</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;<span class="comment">//使用默认属性 信号捕捉函数执行期间，屏蔽本信号</span></span><br><span class="line">	<span class="keyword">int</span> ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"sigaction error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//sleep(5);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>区间调度问题</title>
    <url>/2021/04/19/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h1><p>题目：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意:</p>
<p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。<br>示例 1:</p>
<p>输入: [ [1,2], [2,3], [3,4], [1,3] ]</p>
<p>输出: 1</p>
<p>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
<h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>①题目的意思是找到重叠的区域，把它去除，则可以得到不重叠的区域，我们可以反着来，找到了不重叠的区域不就找到了需要移除区间的个数。<br>②可能我们可以找区间中开始最早的那个区间，但是这可能存在某些区间很早，但是该区间很长，则会忽略掉很多短的区间。<br>③所以我们先从区间集合中选出一个区间x，这个x是在所有区间中结束最早的，然后把所有与x区间相交的区间去掉，重复这一条则可以找到没有重叠的区间。<br>④需要先将集合按结束时间进行升序排序，则与x相交的区间必定开始时间小于等于x的结束时间。<br>⑤将区间集合总数减去不重叠的区间则得到需要移除区间的最小数量。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(),[]</span><br><span class="line">            (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];<span class="comment">//集合按结束时间升序排序</span></span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;<span class="comment">//无论怎样都会有一个不重叠的区间</span></span><br><span class="line">        <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];<span class="comment">//x结束时间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = intervals[i][<span class="number">0</span>];<span class="comment">//开始时间</span></span><br><span class="line">            <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.size() - count;<span class="comment">//区间总数-不重叠区间数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="用最少数量的剪引爆气球"><a href="#用最少数量的剪引爆气球" class="headerlink" title="用最少数量的剪引爆气球"></a>用最少数量的剪引爆气球</h1><p>题目：<br>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p>示例 1：</p>
<p>输入：points = [[10,16],[2,8],[1,6],[7,12]]<br>输出：2<br>解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</p>
<h2 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h2><p>①本题的意思是，用一支箭在x轴方向射，只要碰到了气球，则气球会爆炸，求至少需要几支箭。<br>②同样这是一题求不重叠区间的数量，只要求出不重叠区间的个数不就求出了箭的数量。<br>③但要注意的是本题在区间相邻的时候，也算是重叠，即只需要一支箭就可以。</p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(points.begin(), points.end(),[]</span><br><span class="line">            (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];<span class="comment">//按区间右端点升序排序</span></span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = points[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(start &gt; end)&#123;<span class="comment">//***注意：因为题目要求相邻也相当于重叠所以不需要等于*****</span></span><br><span class="line">                count++;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划解0-1背包问题</title>
    <url>/2021/05/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A30-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个可装载重量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为val[i]，现在让你用这个背包装物品，最多能装的价值是多少？</p>
<p>举个简单的例子，输入如下：</p>
<p>N = 3, W = 4<br>wt = [2, 1, 3]<br>val = [4, 2, 3]<br>算法返回 6，选择前两件物品装进背包，总重量 3 小于W，可以获得最大价值 6。</p>
<h1 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h1><p>①首先我们想到背包问题的状态有两个，一个是背包的容量，一个是可选择的物品。<br>②选择就是装进背包与不装进背包。<br>③接下来就是要明白dp[i][w]的含义，比如dp[3][5]=6就是代表对于给定的一系列物品中，若只对前三个物品进行选择，当背包容量为5的时候最多可以装下价值为6。<br>④根据以上，可以知道最终结果就是dp[N][W]，base case就是dp[0][…]=0,dp[…][0]=0。因为没有物品活背包没有空间的时候，能装的最大价值为0。<br>⑤当选择不装进背包时dp[i][w]=dp[i-1][w]，不装就等于继承之前的结果。<br>⑥当选择装入背包时dp[i][w]=max(d[i-1][w], dp[i-1][w-wt[i-1]] + val[i-1])。寻求剩余重量w-wt[i-1]限制能装下的最大价值加上第i个物品的价值。</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; wt, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; val)</span> </span></span><br><span class="line"><span class="function">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前背包容量装不下，只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">                dp[i][w] = max(dp[i - <span class="number">1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], </span><br><span class="line">                               dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>去除重复字母</title>
    <url>/2021/04/15/%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p>输入：s = “bcabc”<br>输出：”abc”</p>
<h1 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h1><p>输入：s = “cbacdcbc”<br>输出：”acdb”</p>
<h1 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h1><p>①首先由题可知，要去除重复字母<br>②去重字符串的相对位置不能改变<br>③去重字符串的字典序保证最小，例如”bcabc”可以去重成”bac”，也可以去重成“abc”而为了保证字典序最小，则需要去重成”abc”<br>④我们可以想到利用栈进行操作，将每一个字母依次入栈，并进行判断，栈内是否存在相同字母，如相同则跳到下一个字母。以及字典序是否小于栈顶元素，将字典序大于目前将要入栈的元素的字母弹出栈，并将当前字母入栈。<br>⑤目前只能保证去重以及位置不变，如果我们按现在的思路，”bcac”经过操作会变成”ac”，而正确答案应该是”bac”，这是因为当我们将a入栈时，判断时将”bc“全部弹出，而这并不是我们想要的<br>⑥解决这个问题其实也很简单，只需要添加一个计数器，首先遍历字符串统计每个字母出现的次数，如果栈内的元素大于将要压栈的元素的字典序，但是字符串只有这一个元素，就不需要进行弹出</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//计数器</span></span><br><span class="line">        <span class="keyword">bool</span> instack[<span class="number">256</span>]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//判断是否在栈中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)&#123;<span class="comment">//统计每个元素出现的次数</span></span><br><span class="line">            count[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)&#123;</span><br><span class="line">            count[c]--;<span class="comment">//每遍历到这个元素，将次数减一</span></span><br><span class="line">            <span class="keyword">if</span>(instack[c])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(!st.empty()&amp;&amp;st.top()&gt;c)&#123;<span class="comment">//判断字典序</span></span><br><span class="line">                <span class="keyword">if</span>(count[st.top()]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                instack[st.top()]=<span class="literal">false</span>;</span><br><span class="line">                st.pop();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            st.push(c);</span><br><span class="line">            instack[c]=<span class="literal">true</span>;<span class="comment">//入栈后将元素标记为栈中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            ans=st.top()+ans;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>利用mmap实现多进程复制文件</title>
    <url>/2020/05/16/%E5%88%A9%E7%94%A8mmap%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>程序将文件分为五部分，四个子进程进行前面的复制工作，父进程进行回收四个子进程，并完成最后的复制工作<br><strong>注意:</strong><br>    1.mmap函数指定的读写方式是对mmap映射区而言的<br>    2.创建映射区的权限要小于等于打开文件的权限，映射区创建过程当中存在一次对文件的读操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"./a.out file "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd1, fd2;</span><br><span class="line">	<span class="keyword">int</span> len, i;</span><br><span class="line">	fd1 = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd1 == <span class="number">-1</span>)</span><br><span class="line">	&#123;		</span><br><span class="line">		perror(<span class="string">"open file1 error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	len = lseek(fd1, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	<span class="keyword">void</span>*mmap_r = mmap(<span class="literal">NULL</span>, len, PROT_READ , MAP_SHARED, fd1, <span class="number">0</span>);<span class="comment">//创建读映射区</span></span><br><span class="line">	<span class="keyword">if</span>(mmap_r == MAP_FAILED)</span><br><span class="line">	&#123;		</span><br><span class="line">		perror(<span class="string">"mmap_r error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fd2 = <span class="built_in">open</span>(argv[<span class="number">2</span>], O_CREAT | O_RDWR, <span class="number">0644</span>);</span><br><span class="line">	<span class="comment">//因为创建映射区会对文件进行一次读操作，所以需要读权限</span></span><br><span class="line">	<span class="keyword">if</span>(fd2 == <span class="number">-1</span>)	</span><br><span class="line">	&#123;		</span><br><span class="line">		perror(<span class="string">"open file2 error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ret = ftruncate(fd2, len);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftruncate error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> *mmap_w = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd2, <span class="number">0</span>);<span class="comment">//创建写映射区</span></span><br><span class="line">	<span class="keyword">if</span>(mmap_w == MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"mmap_w error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">//循环创建进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"fork error\n"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> wpid;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">4</span>)<span class="comment">//父进程进行回收子进程，并进行最后的复制工作</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">			<span class="keyword">if</span>(wpid &gt; <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				n--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span>(n);</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w+<span class="number">4</span>*len/<span class="number">5</span>, mmap_r+<span class="number">4</span>*len/<span class="number">5</span>, len<span class="number">-4</span>*len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"parent copy 5th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w, mmap_r, len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"son1 copy 1th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w+i*len/<span class="number">5</span>, mmap_r+i*len/<span class="number">5</span>, len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"son2 copy 2th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w+i*len/<span class="number">5</span>, mmap_r+i*len/<span class="number">5</span>, len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"son3 copy 3th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w+i*len/<span class="number">5</span>, mmap_r+i*len/<span class="number">5</span>, len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"son4 copy 4th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd1);</span><br><span class="line">	<span class="built_in">close</span>(fd2);</span><br><span class="line">	munmap(mmap_w, len);</span><br><span class="line">	munmap(mmap_r, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>process</tag>
        <tag>mmap</tag>
      </tags>
  </entry>
  <entry>
    <title>填充二叉树的节点的右侧指针</title>
    <url>/2021/05/16/%E5%A1%AB%E5%85%85%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E7%9A%84%E5%8F%B3%E4%BE%A7%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>116.给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。<br>输入：root = [1,2,3,4,5,6,7]<br>输出：[1,#,2,3,#,4,5,6,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，’#’ 标志着每一层的结束。<br><img src="https://img-blog.csdnimg.cn/20210516160913968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h1><p>①根据题意，这是一棵完美二叉树，最终除了右侧节点的next指针会指向null，其余节点的next都会指向右侧相邻的节点。<br>②如果我们只是简单的想将每个节点的左右节点都穿起来就会出现一个问题，题目所说的是将一层的每个节点都穿起来，而这个思路只能将同父节点的左右节点穿起来，如上图，5和6就不能被穿起来。<br>③所以只依赖一个节点是没办法解决问题的，我们应该将题目细化成将每相邻的节点连接起来。</p>
<p>④我们还可以利用队列来进行解答，用层次遍历的思想，将一层中的节点连接起来。</p>
<h1 id="code1（递归）"><a href="#code1（递归）" class="headerlink" title="code1（递归）"></a>code1（递归）</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> null;</span><br><span class="line">    connectTwoNode(root-&gt;left, root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectTwoNode</span><span class="params">(Node* node1, Node* node2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == null || node2 == null) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**** 前序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">// 将传入的两个节点连接</span></span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 连接相同父节点的两个子节点</span></span><br><span class="line">    connectTwoNode(node1-&gt;left, node1-&gt;right);</span><br><span class="line">    connectTwoNode(node2-&gt;left, node2-&gt;right);</span><br><span class="line">    <span class="comment">// 连接跨越父节点的两个子节点</span></span><br><span class="line">    connectTwoNode(node1-&gt;right, node2-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="code2（队列）"><a href="#code2（队列）" class="headerlink" title="code2（队列）"></a>code2（队列）</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; que;</span><br><span class="line">        que.push(root);<span class="comment">//根节点进入队列</span></span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)&#123;<span class="comment">//将一层的节点都连接起来</span></span><br><span class="line">                Node* temp = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span>(i != size - <span class="number">1</span>)&#123;<span class="comment">//如果没有到一层的最右侧的节点，则将左侧的next指向右侧节点</span></span><br><span class="line">                    temp-&gt;next = que.front();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left)<span class="comment">//左节点进入队列</span></span><br><span class="line">                    que.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right)<span class="comment">//右节点进入队列</span></span><br><span class="line">                    que.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>回收子进程</title>
    <url>/2020/05/15/%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：</p>
<p>如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。</p>
<p>我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p>
<h1 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h1><p>父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</p>
<h1 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h1><p>进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</p>
<h1 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h1><p>该函数有三个功能：<br>① 阻塞等待子进程退出<br>② 回收子进程残留资源<br>③ 获取子进程结束状态(退出原因)。</p>
<p> 原型:pid_t wait(int *status)</p>
<p>成功：清理掉的子进程ID；失败：-1 (没有子进程)</p>
<p>当进程终止时，操作系统的隐式回收机制：</p>
<p>1.关闭所有文件描述符 </p>
<p>2.释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)</p>
<p>可使用wait函数传出参数status来保存进程的退出状态。</p>
<p>借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：<br> 1.WIFEXITED(status) 为非0    → 进程正常结束<br>    WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)</p>
<p> 2.WIFSIGNALED(status) 为非0 → 进程异常终止<br>    WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</p>
<p>3.WIFSTOPPED(status) 为非0 → 进程处于暂停状态<br>    WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。<br>    WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">pid_t</span> pid,wpid;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm child,my parent = %d,going to sleep 10s\n"</span>,getppid());</span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"child die\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">76</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                wpid = wait(&amp;status);<span class="comment">//阻塞等待回收</span></span><br><span class="line">                <span class="keyword">if</span>(wpid == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">"wait "</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"child exit with %d\n"</span>,WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"child killed by%d\n"</span>,WTERMSIG(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"I'm parent,pid = %d,myson =%d\n"</span>,getpid(),pid);</span><br><span class="line">                        sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">"fork "</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid()"></a>waitpid()</h1><p>原型：pid_t waitpid(pid_t pid, int *status, in options)    </p>
<p>成功：返回清理掉的子进程ID  失败：-1(无子进程)</p>
<p>特殊参数和返回情况<br>参数pid:<br>pid &gt; 0 回收指定ID的子进程<br>pid = -1 回收任意子进程（相当于wait）<br>pid = 0 回收和当前调用waitpid一个组的所有子进程<br>pid &lt; -1 回收指定进程组内的任意子进程</p>
<p>参数options指定为WNOHANG，设置为非阻塞，且子进程正在运行</p>
<p>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>当程序执行之后，通过while(1)阻止父进程结束，可通过ps aux查看是否存在僵尸进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>,i;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">pid_t</span> wpid;</span><br><span class="line">        <span class="keyword">int</span> q,p;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                p = fork();</span><br><span class="line">                <span class="keyword">if</span>(p == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                &#125;    </span><br><span class="line">                <span class="comment">//else if(i == 3)</span></span><br><span class="line">                <span class="comment">//&#123;</span></span><br><span class="line">                <span class="comment">//        q = p;//设置回收指定子进程</span></span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == i)<span class="comment">//父进程</span></span><br><span class="line">        &#123;</span><br><span class="line">                sleep(n);<span class="comment">//等待子进程执行完</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm parent,pid = %d\n"</span>,getppid());</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                        wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">                        <span class="keyword">if</span>(wpid &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                n--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(n &gt; <span class="number">0</span>); </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"wait finish\n"</span>);</span><br><span class="line">                <span class="comment">//while(waitpid(q, NULL, WNOHANG))</span></span><br><span class="line">				<span class="comment">//wait(NULL);</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm %dth child, pid = %d, gpid = %d\n"</span>,i+<span class="number">1</span>, getpid(),getppid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程拷贝文件</title>
    <url>/2020/05/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_COUNT 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_BUF 1024</span></span><br><span class="line"><span class="comment">//作为线程创建的参数，包括两个文件的文件描述符和每个线程复制的大小</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd1;</span><br><span class="line">	<span class="keyword">int</span> fd2;</span><br><span class="line">	<span class="keyword">size_t</span> start;</span><br><span class="line">	<span class="keyword">size_t</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_copy</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_block</span> *<span class="title">block</span> = (<span class="title">struct</span> <span class="title">thread_block</span> *)<span class="title">arg</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[THREAD_BUF];</span><br><span class="line">	<span class="keyword">size_t</span> count = block-&gt;start;</span><br><span class="line">	<span class="comment">//打印线程ID和线程复制的起始位置和终点位置</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread id = %lu start = %ld end = %ld\n"</span>, pthread_self(), block-&gt;start, block-&gt;<span class="built_in">end</span>);</span><br><span class="line">	<span class="keyword">int</span> ret = lseek(block-&gt;fd1, block-&gt;start, SEEK_SET);<span class="comment">//将文件指针移到线程复制的起始位置</span></span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"lseek fd1 "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = lseek(block-&gt;fd2, block-&gt;start, SEEK_SET);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"lseek fd2 "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(count &lt; block-&gt;<span class="built_in">end</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">size_t</span> read_size, write_size;</span><br><span class="line">		read_size = <span class="built_in">read</span>(block-&gt;fd1, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="keyword">if</span>(read_size &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			count += read_size;<span class="comment">//加上读到的内容</span></span><br><span class="line">			<span class="keyword">if</span>(read_size == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				perror(<span class="string">"read "</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">char</span> *ptr = buf;<span class="comment">//*</span></span><br><span class="line">			<span class="keyword">do</span><span class="comment">//避免一次性不能写完全</span></span><br><span class="line">			&#123;</span><br><span class="line">				write_size = <span class="built_in">write</span>(block-&gt;fd2, ptr, read_size);</span><br><span class="line">				<span class="keyword">if</span>(write_size == <span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					perror(<span class="string">"write "</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(write_size &gt; <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ptr += write_size;<span class="comment">//*</span></span><br><span class="line">					read_size -= write_size;<span class="comment">//当一次没写完时，使数据减去已写入的数据</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">while</span>(write_size != <span class="number">0</span>);<span class="comment">//当没有数据可写的时候退出</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread exit %lu\n"</span>, pthread_self());</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"./a.out error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd1 = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd1 &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"open file1:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd2 = <span class="built_in">open</span>(argv[<span class="number">2</span>], O_CREAT | O_WRONLY, <span class="number">0664</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd2 &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"open file2:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = fstat(fd1, &amp;st);<span class="comment">//获取文件状态</span></span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"stat "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">size_t</span> file_size = st.st_size;<span class="comment">//获取文件的大小</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_block</span> *<span class="title">blocks</span>;</span></span><br><span class="line">	blocks = (struct thread_block *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct thread_block)* THREAD_COUNT);</span><br><span class="line">	<span class="keyword">size_t</span> percent = file_size/THREAD_COUNT;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"filesize = %ld\t each percent = %ld\n"</span>, file_size, percent);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		blocks[i].fd1 = fd1;</span><br><span class="line">		blocks[i].fd2 = fd2;</span><br><span class="line">		blocks[i].start = i*percent;</span><br><span class="line">		blocks[i].<span class="built_in">end</span> = blocks[i].start + percent;</span><br><span class="line">	&#125;</span><br><span class="line">	blocks[i<span class="number">-1</span>].<span class="built_in">end</span> = file_size;<span class="comment">//最后一份</span></span><br><span class="line">	<span class="keyword">pthread_t</span> tid[THREAD_COUNT];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread_copy, (<span class="keyword">void</span> *)&amp;blocks[i]);</span><br><span class="line">		<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"creat error:%s\n"</span>, strerror(ret));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"join error:%s\n"</span>, strerror(ret));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(blocks);</span><br><span class="line">	ret = <span class="built_in">close</span>(fd1);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"close fd1"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">close</span>(fd2);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"close fd2"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"copy successful\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>LWP</tag>
      </tags>
  </entry>
  <entry>
    <title>多播（组播）</title>
    <url>/2020/09/06/%E5%A4%9A%E6%92%AD%EF%BC%88%E7%BB%84%E6%92%AD%EF%BC%89/</url>
    <content><![CDATA[<p>组播组可以是永久的也可以是临时的。<br>组播组地址中，有一部分由官方分配的，称为永久组播组。<br>永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。<br>永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。</p>
<p>可以使用ip -ad查看网卡编号<br>可以使用if_nametoindex函数根据网卡名获取网卡序号</p>
<p>224.0.0.0～224.0.0.255 为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；<br>224.0.1.0～224.0.1.255 是公用组播地址，可以用于Internet；欲使用需申请。<br>224.0.2.0～238.255.255.255 为用户可用的组播地址（临时组地址），全网范围内有效；<br>239.0.0.0～239.255.255.255 为本地管理组播地址，仅在特定的本地范围内有效。</p>
<h1 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIE_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">"239.0.0.2"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sfd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">char</span> buf[MAXLINE] = <span class="string">"ahdai\n"</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span></span><br><span class="line">        sfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port =htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        bind(sfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    </span><br><span class="line">        inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);<span class="comment">//设置组地址</span></span><br><span class="line">        inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;group.imr_address);<span class="comment">//本地任意IP</span></span><br><span class="line">        group.imr_ifindex = if_nametoindex(<span class="string">"ens33"</span>);</span><br><span class="line">        setsockopt(sfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;group, <span class="keyword">sizeof</span>(group));<span class="comment">//组播权限</span></span><br><span class="line">        bzero(&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));<span class="comment">//构造 client地址</span></span><br><span class="line">        clie_addr.sin_family = AF_INET;</span><br><span class="line">        inet_pton(AF_INET, GROUP, &amp;clie_addr.sin_addr.s_addr);<span class="comment">//239.0.0.0</span></span><br><span class="line">        clie_addr.sin_port = htons(CLIE_PORT);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(buf, <span class="string">"ahdai %d\n"</span>, i++);</span><br><span class="line">                sendto(sfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIE_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">"239.0.0.2"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">lo_addr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> cfd;</span><br><span class="line">        <span class="keyword">ssize_t</span> len;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span></span><br><span class="line">        cfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;lo_addr, <span class="keyword">sizeof</span>(lo_addr));</span><br><span class="line">        lo_addr.sin_family = AF_INET;</span><br><span class="line">        inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;lo_addr.sin_addr.s_addr);</span><br><span class="line">        lo_addr.sin_port = htons(CLIE_PORT);</span><br><span class="line">        bind(cfd, (struct sockaddr *)&amp;lo_addr, <span class="keyword">sizeof</span>(lo_addr));</span><br><span class="line">        inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);</span><br><span class="line">        inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;group.imr_address);</span><br><span class="line">        group.imr_ifindex = if_nametoindex(<span class="string">"ens33"</span>);</span><br><span class="line">        setsockopt(cfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, <span class="keyword">sizeof</span>(group));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                len = recvfrom(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>); </span><br><span class="line">                <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(cfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>尽量以const、enum、inline替换define</title>
    <url>/2020/10/18/%E5%B0%BD%E9%87%8F%E4%BB%A5const%E3%80%81enum%E3%80%81inline%E6%9B%BF%E6%8D%A2define/</url>
    <content><![CDATA[<h1 id="const替换-define"><a href="#const替换-define" class="headerlink" title="const替换#define"></a>const替换#define</h1><p>这个规则也许可以改为“宁可以编译器替换预处理器”，#define不被视作语言的一部分，这正是问题的所在。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure>
<p>记号名称ASPECT_RATIO也许从未被编译器看见，它在编译器开始处理之前就被预处理器移走了，于是这个记号名称并没有进入记号表（symbol table）内。<br>当使用这个常量但是却或者一个编译错误信息时，这个错误信息也许会提到1.653而绝不会提到ASPECT_RATIO。如果这个记号被定义在一个非本人写的头文件内，肯定对1.653毫无概念。而这解决方法便是用const替换#define</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;</span><br></pre></td></tr></table></figure>
<p>作为一个语言常量肯定会被编译器所看到。</p>
<p>值得注意的是class专属变量。为了将常量的作用域限制于class内，必须让它称为class的一个成员，而还需要确保此常量最多只有一份实体，所以必须用static修饰。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//static const int Numturns;//常量声明,位于头文件内</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Numturns = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> scores[Numturns];</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//const int GamePlayer::Numturns = 5;//常量定义，位于实现文件内</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::Numturns;</span><br><span class="line"><span class="comment">//如果程序不需要取Numturns的地址，则可以不用定义</span></span><br></pre></td></tr></table></figure>
<p>我们无法用#define创建一个class专属常量，因为#define并不重视作用域。一旦宏被定义，就在其后的编译过程中有效。这就意味着#define不仅不能用来定义class专属变量，也不能提供任何的封装性。</p>
<h1 id="enum替换-define"><a href="#enum替换-define" class="headerlink" title="enum替换#define"></a>enum替换#define</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gameplayer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123; Numturns = <span class="number">5</span>&#125;;<span class="comment">//令Numturns成为5的一个记号名称</span></span><br><span class="line">	<span class="keyword">int</span> scores[Numturns];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>enum的行为与#define比较相似，例如取一个#define的地址是非法的，同样取一个enum的地址也是非法的。</p>
<h1 id="inline替换-define"><a href="#inline替换-define" class="headerlink" title="inline替换#define"></a>inline替换#define</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>
<p>这样的宏函数有非常多的缺点，必须为所有的实参加上小括号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不需要在函数体内中为参数加上括号。</p>
<p><strong>总结：</strong><br> <strong>1. 对于单纯常量，最好以const对象或enums替换#define。<br> 2. 对于形似函数的宏，最好以inline函数替换#define</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>多路I_O转接服务器select</title>
    <url>/2020/09/06/%E5%A4%9A%E8%B7%AFI_O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8select/</url>
    <content><![CDATA[<p>多路IO转接服务器也叫做多任务IO服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件。</p>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>1、select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数<br>2、解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效</p>
<pre><code>#include &lt;sys/select.h
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout)</code></pre><p>nfds: 监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态</p>
<p>readfds： 监控有读数据到达文件描述符集合，传入传出参数</p>
<p>writefds： 监控写数据到达文件描述符集合，传入传出参数</p>
<p>exceptfds： 监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数</p>
<p>timeout： 定时阻塞监控时间，3种情况<br>1、NULL，永远等下去<br>2、设置timeval，等待固定时间<br>3、设置timeval里时间均为0，检查描述字后立即返回，轮<br>struct timeval {<br>long tv_sec; /* seconds /<br>long tv_usec; / microseconds */<br>};</p>
<p>void FD_CLR(int fd, fd_set *set); //把文件描述符集合里fd清0</p>
<p>int FD_ISSET(int fd, fd_set *set); //测试文件描述符集合里fd是否置1</p>
<p>void FD_SET(int fd, fd_set *set); //把文件描述符集合里fd位置1</p>
<p>void FD_ZERO(fd_set *set); //把文件描述符集合里所有位清0</p>
<h2 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ], str[INET_ADDRSTRLEN];<span class="comment">//缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> lfd, cfd, sfd;</span><br><span class="line">        <span class="keyword">int</span> n, maxfd, maxi;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> nready, client[FD_SETSIZE];<span class="comment">//自定义数组,防止便利1024文件描述符</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        fd_set rset, allset;</span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line">    </span><br><span class="line">        maxfd = lfd;<span class="comment">//起初lfd 为最大文件描述符</span></span><br><span class="line">        maxi = <span class="number">-1</span>;<span class="comment">//初始值指向0个元素之前下标位置</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">                client[i] = <span class="number">-1</span>;<span class="comment">//初始化</span></span><br><span class="line">        FD_ZERO(&amp;allset);</span><br><span class="line">        FD_SET(lfd, &amp;allset);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//每次循环都重新设置select监控信号集</span></span><br><span class="line">        &#123;</span><br><span class="line">                rset = allset;</span><br><span class="line">                nready = select(maxfd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">                        perr_exit(<span class="string">"select errpr"</span>);</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(lfd, &amp;rset))<span class="comment">//说明有新的客户端链接请求</span></span><br><span class="line">                &#123;</span><br><span class="line">    </span><br><span class="line">                        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                        cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);<span class="comment">//不会阻塞</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"client IP :%s, client port = %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">                        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; FD_SETSIZE;i++)</span><br><span class="line">                                <span class="keyword">if</span>(client[i] &lt; <span class="number">0</span>)<span class="comment">//找client[i]中没有使用的位置</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="comment">//保存accept返回的文件描述符</span></span><br><span class="line">                                        client[i] = cfd;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        <span class="keyword">if</span>(i == FD_SETSIZE)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="built_in">fputs</span>(<span class="string">"too many clients\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        FD_SET(cfd, &amp;allset);<span class="comment">//向监控文件描述符集添加新的</span></span><br><span class="line">                        <span class="keyword">if</span>(cfd &gt; maxfd)</span><br><span class="line">                                maxfd = cfd;<span class="comment">//select第一个参数</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt; maxi)</span><br><span class="line">                                maxi = i;<span class="comment">//保证maxi存的总是最后一个元素下标</span></span><br><span class="line">                        <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= maxi;i++)<span class="comment">//检测哪个客户端有数据就绪</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span>((sfd = client[i]) &lt; <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(FD_ISSET(sfd, &amp;rset))</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="comment">//当客户端关闭链接时,服务器端也关闭也关闭</span></span><br><span class="line">                                <span class="keyword">if</span>((n = Read(sfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        Close(sfd);</span><br><span class="line">                                        FD_CLR(sfd, &amp;allset);<span class="comment">//解除监控</span></span><br><span class="line">                                        client[i] = <span class="number">-1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                                                buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                                        Write(sfd, buf, n);</span><br><span class="line">                                        Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Close(lfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>尽可能使用const</title>
    <url>/2020/10/18/%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/</url>
    <content><![CDATA[<h1 id="const-iterator"><a href="#const-iterator" class="headerlink" title="const_iterator"></a>const_iterator</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();</span><br><span class="line">*iter = <span class="number">10</span>;<span class="comment">//没问题，改变的是iter所指的值</span></span><br><span class="line">iter++;<span class="comment">//错误，iter是const,类似于const T*</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator citer = vec.begin();</span><br><span class="line">*citer = <span class="number">10</span>;<span class="comment">//错误，*citer是const</span></span><br><span class="line">citer++;<span class="comment">//没问题，类似于T * const</span></span><br></pre></td></tr></table></figure>
<h1 id="降低客户的错误造成的意外"><a href="#降低客户的错误造成的意外" class="headerlink" title="降低客户的错误造成的意外"></a>降低客户的错误造成的意外</h1><p>例如一个有理数的operator*声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span>……&#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,<span class="keyword">const</span> Rational&amp; rhs)</span><br></pre></td></tr></table></figure>
<p>很多人会疑惑为什么要返回一个const，原因是如果不返回const，客户可以实现以下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Rational a,b,c;</span><br><span class="line">(a * b) = c;<span class="comment">//在a * b的成果上调用operator=</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a * b = c)<span class="comment">//其实只是想做一个比较动作，少输了一个等号</span></span><br></pre></td></tr></table></figure>
<p>如果a和b都是内置类型，这样的代码就是不合法的，将operator*的回传值声明为const则可以预防这个毫无意义的赋值</p>
<h1 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span></span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> text[position];<span class="comment">//const对象</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> text[position];<span class="comment">//non-const对象</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TextBlock的operator[]可以被这么使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tb[<span class="number">0</span>];<span class="comment">//调用non-const TextBlock::operator[]</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ctb[<span class="number">0</span>];<span class="comment">//调用const TextBlock::operator[]</span></span><br><span class="line"></span><br><span class="line">tb[<span class="number">0</span>]=<span class="string">'x'</span>;<span class="comment">//可以，写一个non-const TextBlock</span></span><br><span class="line">ctb[<span class="number">0</span>]=<span class="string">'x'</span>;<span class="comment">//错误，写一个const TextBlock</span></span><br></pre></td></tr></table></figure>
<p>上述的错误只因operator[]的返回类型，错误起因是企图对一个const char&amp;施行赋值动作。</p>
<p>下面有一个很有趣的事情，将operator[]声明为const成员函数却返回一个引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span><span class="comment">//其实并不适当</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> pText[position]</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;<span class="comment">//声明一个常量对象</span></span><br><span class="line"><span class="keyword">char</span>* pc = &amp;cctb[<span class="number">0</span>];<span class="comment">//调用const operator[]取得一个指针指向cctb的数据</span></span><br><span class="line">*pc = <span class="string">'J'</span>;<span class="comment">//cctb现在有了"Jello"的内容</span></span><br></pre></td></tr></table></figure>
<p>看起来没有任何的错误，创建一个常量对象并设以某值，而且只对他调用const成员函数，但你终究还是改变了他的值。所以引用与const相结合需要非常谨慎。<br>如果想修改const成员函数中的内容，成员变量只需要在声明的时候前面加上mutable就可以了。</p>
<h1 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h1><p>假设一个TextBlock内的operator[]不止返回一个指向某个字符的引用，也执行边界检验、志记访问信息、数据完善性检验等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		……<span class="comment">//边界检验</span></span><br><span class="line">		……<span class="comment">//志记数据访问</span></span><br><span class="line">		……<span class="comment">//检验数据完整性</span></span><br><span class="line">		<span class="keyword">return</span> text[position]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> positon)</span><br><span class="line">	&#123;</span><br><span class="line">		……<span class="comment">//边界检验</span></span><br><span class="line">		……<span class="comment">//志记数据访问</span></span><br><span class="line">		……<span class="comment">//检验数据完整性</span></span><br><span class="line">		<span class="keyword">return</span> text[position]</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>const与non-const中有许多重复的代码，也许可以将这些代码移到另一个成员函数，并令两个版本的operator[]调用它，这是可能的，但还是会重复一些代码，比如函数调用、两次return语句等等。<br>我们真正该做的是实现operator[]的机能一次并使用它两次，也就是说令其中的一个调用另一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		……<span class="comment">//边界检验</span></span><br><span class="line">		……<span class="comment">//志记数据访问</span></span><br><span class="line">		……<span class="comment">//检验数据完整性</span></span><br><span class="line">		<span class="keyword">return</span> text[position]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> positon)<span class="comment">//现在只调用const op[]</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将op[]返回值的const转除，为*this加上const,调用const op[]</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">			<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这份代码有两个转型动作，我们准备让non-const operator[]调用其const兄弟，但non-const operator[]内部若只是单纯的调用operator[]，便会递归的调用自己，为了避免无穷的递归，我们必须指出调用的是const operator[]，但c++缺乏直接的语法可以这么做。<br>因此将*this从其原型TextBlock&amp;转型为const TextBlock&amp;，然后则是从const operatoe[]的返回值中去除const。</p>
<p> <strong>总结</strong></p>
<p> <strong>1. 将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。<br> 2. 当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/2021/04/18/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="求最长公共子序列"><a href="#求最长公共子序列" class="headerlink" title="求最长公共子序列"></a>求最长公共子序列</h1><p>题目：给你输入两个字符串s1和s2，请你找出他们俩的最长公共子序列，返回这个子序列的长度。</p>
<p>比如说输入s1 = “zabcde”, s2 = “acez”，它俩的最长公共子序列是lcs = “ace”，长度为 3，所以算法返回 3。</p>
<h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>①首先我们想到的是枚举出所有子序列，然后看有没有公共的，再找出最长的，这显然时间复杂度会非常高。<br>②对于两个字符串寻找子序列，我们可以想到动态规划。<br>③我们观察两个字符串的每个字母。用两个指针分别指向两个字符串，当两个字母相等的时候，我们可以肯定这个字母肯定实在lcs里面的，所以<strong>dp[i][j] =dp[i - 1][j - 1] + 1</strong>。<br>④但当字母不相等的时候可以有三种情况，其一是s1[i]不在lcs,其二是s2[j]不在lcs中，最后就是两个字母都不在lcs中，这样我们可以得到状态转移方程的另一半<strong>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j -1])</strong>。<br>⑤但第三种情况其实可以忽略，因为第一和第二种情况包括了。<br>所以动态转移方程：<br><strong>dp[i][j] = dp[i - 1][j - 1] + 1       (s1[i] == s2[j])<br>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1)   (s1[i] != s2[j])</strong></p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = word1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = word2.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(len1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2 + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h1><p>题目：给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。<br>输入: “sea”, “eat”<br>输出: 2<br>解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”</p>
<h2 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h2><p>①本题不是问求lcs，但实际上是换了个说法，删除以后留下的字母不就是lcs吗。<br>②所以只需要利用lcs模板。</p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = word1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = word2.size();</span><br><span class="line">        <span class="keyword">int</span> len = lcs(word1, word2);</span><br><span class="line">		<span class="keyword">int</span> ans = len1 + len2 - len * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="两个字符串的最小ASCII删除和"><a href="#两个字符串的最小ASCII删除和" class="headerlink" title="两个字符串的最小ASCII删除和"></a>两个字符串的最小ASCII删除和</h1><p>题目：给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。</p>
<p>输入: s1 = “sea”, s2 = “eat”<br>输出: 231<br>解释: 在 “sea” 中删除 “s” 并将 “s” 的值(115)加入总和。<br>在 “eat” 中删除 “t” 并将 116 加入总和。<br>结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。</p>
<h2 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h2><p>①本题是求删除的ASCII码，不能用上述的Lcs模板来解答，但还是同样的思路。<br>②当指向的两个字母相同时，同样肯定在Lcs中，也就不用求该字母的ASCII码，即<strong>dp[i][j] = dp[i -1][j - 1]</strong><br>③当不相等时，即<strong>dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]</strong><br>④当有一个字符串为空时，则ans就是另一个字符串的所有字符ASCII相加之和。</p>
<h2 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(len1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2 + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + s1[i - <span class="number">1</span>];<span class="comment">//求dpbase</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len2; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + s2[i - <span class="number">1</span>];<span class="comment">//同dpbase</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j] + s1[i - <span class="number">1</span>], dp[i][j - <span class="number">1</span>] + s2[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>树的非递归遍历</title>
    <url>/2020/05/26/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversal</span><span class="params">(TNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TNode *rt = root;</span><br><span class="line">	<span class="built_in">stack</span>&lt;TNode*&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (rt || s.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (rt)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(rt-&gt;rchild);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; rt-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			rt = rt-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		rt = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">(TNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TNode *rt = root;</span><br><span class="line">	<span class="built_in">stack</span>&lt;TNode*&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (rt || s.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (rt)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(rt);</span><br><span class="line">			rt = rt-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		rt = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; rt-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		rt = rt-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><p>因为程序是通过根，右，左遍历，所以最后需要倒置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTraversal</span><span class="params">(TNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TNode *rt = root;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v;</span><br><span class="line">	<span class="built_in">stack</span>&lt;TNode*&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (rt || s.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (rt)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(rt-&gt;lchild);</span><br><span class="line">			v.push_back(rt-&gt;data);</span><br><span class="line">			rt = rt-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		rt = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(v.begin(), v.end());<span class="comment">//倒转v</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = v.begin(); iter != v.end(); iter++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>特化swap</title>
    <url>/2020/10/21/%E7%89%B9%E5%8C%96swap/</url>
    <content><![CDATA[<h1 id="基础swap"><a href="#基础swap" class="headerlink" title="基础swap"></a>基础swap</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">		<span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要T支持copying，swap便可以置换类型为T的对象，但这swap实现版本十分平淡，它涉及三个对象的复制。对于某些类型而言这些复制动作无一必要。</p>
<h1 id="特化swap"><a href="#特化swap" class="headerlink" title="特化swap"></a>特化swap</h1><p>如果一个类的成员变量非常多，可以设置一个类，用一个指针指向这个成员变量的类，这样就以一个指针指向对象，内含真正的数据。就是所谓的“pimpl”手法,按这样设计：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span>//针对<span class="title">Wigdet</span>设计的<span class="title">class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	WidgetImpl(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v):a(a),b(b),v(v)&#123;&#125;</span><br><span class="line">	WidgetImpl(<span class="keyword">const</span> WidgetImpl&amp; other) &#123;</span><br><span class="line">		a = other.a;</span><br><span class="line">		b = other.b;</span><br><span class="line">		v = other.v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_a</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_b</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;b; &#125;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="title">get_v</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;v; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a, b;<span class="comment">//可能有许多数据，意味着复制时间很长</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Widget(<span class="keyword">const</span> WidgetImpl&amp; rhs) &#123;</span><br><span class="line">		pImpl = <span class="keyword">new</span> WidgetImpl(rhs);</span><br><span class="line">	&#125;</span><br><span class="line">	Widget(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">		pImpl = <span class="keyword">new</span> WidgetImpl(*rhs.pImpl);</span><br><span class="line">	&#125;</span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">		<span class="keyword">if</span> (&amp;rhs == <span class="keyword">this</span>)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		pImpl = <span class="keyword">new</span> WidgetImpl(*rhs.pImpl);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Widget() &#123;</span><br><span class="line">		<span class="keyword">delete</span> pImpl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"成员swap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">		swap(pImpl, other.pImpl);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;pImpl-&gt;get_a() &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="keyword">this</span>-&gt;pImpl-&gt;get_b() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> iter: <span class="keyword">this</span>-&gt;pImpl-&gt;get_v()) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; iter &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	WidgetImpl *pImpl;<span class="comment">//指针，所指对象内含Widget数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一旦要置换Widget对象值，我们只需要置换pImpl指针，但swap算法不知道这点，它不知复制三个Widget还复制三个WidgetImpl对象，非常缺乏效率。</p>
<p>我们考虑到可以在std命名空间内特化swap函数例如：<br>（一种错误的写法）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)&#123;</span><br><span class="line">		swap(a.pImpl, b.pImpl);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这个swap在访问类中的private成员所以编译不能通过，</p>
<p>我们可以在Widget中添加一个swap成员函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget::<span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"成员swap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">		swap(pImpl, other.pImpl);<span class="comment">//这个便是使用std::swap交换指针的值</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>然后在std命名空间里特化swap</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)&#123;</span><br><span class="line">		a.swap(b);<span class="comment">//调用Widget的成员函数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止swap特化完成，以下代码的swap调用的是特化版本，因为c++的名称查找法则会找到Widget的专属版本。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">WidgetImpl <span class="title">W1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, v)</span></span>;</span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(W1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">WidgetImpl <span class="title">W2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, v2)</span></span>;</span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(W2)</span></span>;</span><br><span class="line">w1.print();</span><br><span class="line">w2.print();</span><br><span class="line">swap(w1,w2);<span class="comment">//调用的是特化版本的swap而不是std::swap</span></span><br><span class="line">w1.print();</span><br><span class="line">w2.print();</span><br></pre></td></tr></table></figure>
<h1 id="尝试将Widget参数化"><a href="#尝试将Widget参数化" class="headerlink" title="尝试将Widget参数化"></a>尝试将Widget参数化</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span>&#123;</span>……&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span>……&#125;;</span><br></pre></td></tr></table></figure>

<p>但是如果我们想将特化swap写成这样是不合法的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">void</span> swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt;&amp; a,Widget&lt;T&gt;&amp; b)&#123;</span><br><span class="line">		a.swap(b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为c++只允许对class templates偏特化，在function templates身上时行不通的。</p>
<p>当打算偏特化一个function template时，通常做法是简单的为它添加一个重载版本例如：<br>虽然这个在这个样例中也是不合法的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,Widget&lt;T&gt;&amp; b)</span></span>&#123;</span><br><span class="line">		a.swap(b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是因为std里的内容由c++标准已经决定好的，我们只可以对特化std里的东西而不能膨胀那些已经声明好的东西。<br>以下是解决方法：<br>假设所有Widget相关的机能都被置于这个命名空间内</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff&#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span>……&#125;;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,Widget&lt;T&gt;&amp; b)</span></span>&#123;<span class="comment">//这里并不属于std空间</span></span><br><span class="line">		a.swap(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，在任何的地方任何代码如果打算置换两个Widget对象，都会调用特化的swap。</p>
<p><strong>总结：</strong></p>
<p> <strong>1. 当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定他不抛出异常。<br> 2. 当提供一个member swap，也应该提供一个non-member swap用来调用前者，对于classed而言，也请特化std::swap。<br> 3. 调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。<br> 4. 为“用户定义类型”进行std templates全特化是好的，千万不要尝试在std内加入某些对std而言全新的东西。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>确定对象被使用前已先被初始化</title>
    <url>/2020/10/18/%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="使用初始化列表"><a href="#使用初始化列表" class="headerlink" title="使用初始化列表"></a>使用初始化列表</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span>&#123;</span>……&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABEntry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ABEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> <span class="built_in">string</span>&amp; address,</span><br><span class="line">					<span class="keyword">const</span> <span class="built_in">list</span>&lt;PhoneNumber&gt;&amp;phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> theName;</span><br><span class="line">	<span class="built_in">string</span> theAddress;</span><br><span class="line">	<span class="built_in">list</span>&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">	<span class="keyword">int</span> numTimeConsulted;</span><br><span class="line">&#125;;</span><br><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> <span class="built_in">string</span>&amp; address,</span><br><span class="line">					<span class="keyword">const</span> <span class="built_in">list</span>&lt;PhoneNumber&gt;&amp;phones)</span><br><span class="line">&#123;</span><br><span class="line">	theName = name;<span class="comment">//这些都是赋值而非初始化</span></span><br><span class="line">	theAddress = address;</span><br><span class="line">	thePhones = phones;</span><br><span class="line">	numTimesConsulted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;					</span><br><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> <span class="built_in">string</span>&amp; address,</span><br><span class="line">					<span class="keyword">const</span> <span class="built_in">list</span>&lt;PhoneNumber&gt;&amp;phones)</span><br><span class="line">:theName(name),<span class="comment">//现在这些都是初始化</span></span><br><span class="line">theAddress(address),</span><br><span class="line">thePhones(phones),</span><br><span class="line">numTimeConsulted(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;	<span class="comment">//构造函数本体内不必有任何动作</span></span><br></pre></td></tr></table></figure>
<p>下面这个构造函数与上面那个构造函数最终结果相同，但通常效率较高。基于赋值的版本，首先调用默认构造函数为成员变量设初值，然后立刻对它们赋值。默认构造的以切因此浪费了。使用初始化列表则避免了这一问题。本例中theName以name为初值进行copy构造其余成员变量同样，对大多数类型而言，比先调用默认构造函数再调用copy assignment操作符，单只调用一次copy构造函数是比较高效的。<br><strong>如果成员变量是const或引用则必须使用初始化而不能赋值。</strong></p>
<h1 id="不同编译单元内定义non-local-static对象的初始化次序"><a href="#不同编译单元内定义non-local-static对象的初始化次序" class="headerlink" title="不同编译单元内定义non-local static对象的初始化次序"></a>不同编译单元内定义non-local static对象的初始化次序</h1><p>所谓编译单元是指产出单一目标文件的那些源码，基本上是单一源码文件加上其所含入的头文件。<br>现在我们关心的至少是两个源码文件<br>假设有一个FileSystem class，让互联网上的文件看起来好像在本机</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	……</span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">numDisk</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//众多成员函数之一</span></span><br><span class="line">	……</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;<span class="comment">//预备给客户使用的对象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>//由程序库客户建立</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Directory(params);</span><br><span class="line">	……</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">size_t</span> disks = tfs.numDisks();<span class="comment">//使用tfs对象</span></span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步假设，客户决定创建一个Directory对象用于放置临时文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">(params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>现在初始化次序的重要性就显现出来了，除非tfs在tempDir之前被初始化，否则tempDir的构造函数会用到未初始化的tfs。但tfs和tempDir是不同的人在不同的时间于不同的源码文件建立起来的，我们无法确定tfs和tempDir谁先被初始化。<strong>当然可以用一个设计巧妙解决这个问题。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span>……&#125;;<span class="comment">//同前</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span><span class="comment">//这个函数用来替换tfs对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> FileSystem fs;<span class="comment">//定义并初始化一个local static对象</span></span><br><span class="line">	<span class="keyword">return</span> fs;	<span class="comment">//返回一个对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>&#123;</span>……&#125;;<span class="comment">//同前</span></span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">size_t</span> disks = tfs().numDisks();<span class="comment">//原版本的tfs改为tfs()</span></span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempdir</span><span class="params">()</span><span class="comment">//用来替换tempDir对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> Directory td;</span><br><span class="line">	<span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改之后客户完全像以前一样去使用它，唯一不同的是现在使用tfs()和tempDir()而不是tfs和tempDir，也就是说它们使用函数返回指向static对象的引用，而不再是static对象的本身。这样就可以保证使用的tfs是初始化以后的。</p>
<p><strong>总结</strong></p>
<p> <strong>1. 为内置对象进行手工初始化，因为c++不保证初始化它们。<br> 2. 构造函数最好使用成员初始化列表，而不要在构造函数本体内使用赋值操作。初始化列列出的成员变量，其排列次序应该和他们在class中的声明次序相同。<br> 3. 为免除“跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>并发服务器</title>
    <url>/2020/09/05/%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"192.168.44.138"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> n;</span><br><span class="line">        <span class="keyword">while</span>((n = waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG)) &gt; <span class="number">0</span>); </span><br><span class="line"><span class="comment">/*      while(1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                n = waitpid(0, NULL, WNOHANG);</span></span><br><span class="line"><span class="comment">                if(n == -1)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                        perror("waitpid error");</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ];</span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        <span class="comment">//serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span></span><br><span class="line">        inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"client IP :%s, port:%d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">                pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">"fork error"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        Close(lfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                        Close(cfd);</span><br><span class="line">                        signal(SIGCHLD, wait_child);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        n = Read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="comment">//client close</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                Close(cfd);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                perror(<span class="string">"read error"</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                                <span class="built_in">write</span>(cfd, buf, n);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8888</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_info</span>//将地址与<span class="title">cfd</span>捆绑</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> connfd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_work</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> *<span class="title">ts</span> = (<span class="title">struct</span> <span class="title">s_info</span> *)<span class="title">arg</span>;</span></span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                n = Read(ts-&gt;connfd, buf, MAXLINE);</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"the client %d closed \n"</span>, ts-&gt;connfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>, inet_ntop(AF_INET, &amp;(*ts).clie_addr.sin_addr.s_addr, str, <span class="keyword">sizeof</span>(str)), ntohs((*ts).clie_addr.sin_port));</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span> ;i &lt; n ;i++)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                Write(STDOUT_FILENO, buf, n); </span><br><span class="line">                Write(ts-&gt;connfd, buf, n); </span><br><span class="line">        &#125;</span><br><span class="line">        Close(ts-&gt;connfd);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> <span class="title">ts</span>[256];</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(listenfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(listenfd, <span class="number">128</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Acceptint client connect \n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);<span class="comment">//阻塞监听客户端链接请求</span></span><br><span class="line">                ts[i].clie_addr = clie_addr;</span><br><span class="line">                ts[i].connfd = connfd;</span><br><span class="line">                <span class="comment">//达到线程最大时，pthread_create出错处理，增加服务器稳定性</span></span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, do_work, (<span class="keyword">void</span> *)&amp;ts[i]);</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>管道</title>
    <url>/2020/05/15/%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<p><strong>管道是一种最基本的IPC机制</strong><br>作用于有血缘关系的进程之间，完成数据传递。</p>
<p>调用pipe系统函数即可创建一个管道。有如下特征：<br>1.其本质是一个伪文件(实为内核缓冲区)<br>2.由两个文件描述符引用，一个表示读端，一个表示写端。<br>3.规定数据从管道的写端流入管道，从读端流出。</p>
<p><strong>管道的原理：</strong><br>管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p>
<p><strong>管道的局限性：</strong><br>1.数据自己读不能自己写。<br>2. 数据一旦被读走，便不在管道中存在，不可反复读取。<br>3. 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。<br>4. 只能在有公共祖先的进程间使用管道。</p>
<p>常见的通信方式有，单工通信、半双工通信、全双工通信</p>
<h1 id="pipe"><a href="#pipe" class="headerlink" title="pipe()"></a>pipe()</h1><p>函数原型：int pipe(int pipefd[2])<br>成功：0；失败：-1，设置errno</p>
<p>1.父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。<br> 2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。<br> 3. 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];<span class="comment">//读写文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe err"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork err"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">//子进程，读数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="built_in">close</span>(fd[<span class="number">1</span>]);<span class="comment">//关闭写端</span></span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        ret = <span class="built_in">read</span>(fd[<span class="number">0</span>], buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"--------\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in">write</span>(STDOUT_FILENO, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);<span class="comment">//关闭读端</span></span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>],<span class="string">"hello pipe\n"</span>, <span class="built_in">strlen</span>(<span class="string">"hello pipe\n"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2020/05/19/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h1><p>LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)</p>
<p>进程：独立地址空间，拥有PCB<br>线程：也有PCB，但没有独立的地址空间(共享)<br>区别：在于是否共享地址空间。<br>Linux下：<br><strong>线程：最小的执行单位<br>进程：最小分配资源单位，可看成是只有一个线程的进程。</strong></p>
<h1 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a>Linux内核线程实现原理</h1><p>1、线程也有PCB，创建线程使用的底层函数和进程一样，都是clone<br>2、从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的<br>3、进程可以蜕变成线程<br>4、线程可看做寄存器和栈的集合<br>5、<strong>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</strong></p>
<p>对于进程来说，相同的地址(同一个虚拟地址)在不同的进程中，反复使用而不冲突。原因是他们虽虚拟址一样，但，页目录、页表、物理页面各不相同。相同的虚拟址，映射到不同的物理页面内存单元，最终访问不同的物理页面。</p>
<p><strong>但线程不同</strong>，两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。<br>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。<br>如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。<br><strong>因此</strong>：Linux内核是不区分进程和线程的。只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</p>
<h1 id="线程资源的共享与非共享"><a href="#线程资源的共享与非共享" class="headerlink" title="线程资源的共享与非共享"></a>线程资源的共享与非共享</h1><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>1、文件描述符表<br>2、每种信号的处理方式<br>3、当前工作目录<br>4、用户ID和组ID<br>5、内存地址空间 (.text/.data/.bss/heap/共享库)</p>
<h2 id="非共享"><a href="#非共享" class="headerlink" title="非共享"></a>非共享</h2><p>1、线程id<br>2、处理器现场和栈指针(内核栈)<br>3、独立的栈空间(用户空间栈)<br>4、errno变量<br>5、信号屏蔽字<br>6、调度优先级</p>
<h1 id="线程的控制原语"><a href="#线程的控制原语" class="headerlink" title="线程的控制原语"></a>线程的控制原语</h1><h2 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h2><p>作用：获取线程ID。<br>函数原型：pthread_t pthread_self(void）<br>返回值：成功：线程ID；    失败：无</p>
<p>线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现</p>
<p>线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同)<br><strong>注意：不应使用全局变量 pthread_t tid，而在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。</strong></p>
<h2 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h2><p>作用：创建一个新线程。<br>函数原型：int pthread_create(pthread_t <em>thread, const pthread_attr_t *attr, void *(</em>start_routine) (void *), void *arg)<br>返回值：成功：0，    失败：错误号    —–Linux环境下，所有线程特点，失败均直接返回错误号。</p>
<p>参数：<br>pthread_t：typedef unsigned long int pthread_t;<strong>(Linux)</strong><br>参数1：传出参数，保存系统为我们分配好的线程ID<br>参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。<br>参数3：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。<br>参数4：线程主函数执行期间所使用的参数。</p>
<h2 id="创建新线程，打印线程ID"><a href="#创建新线程，打印线程ID" class="headerlink" title="创建新线程，打印线程ID"></a>创建新线程，打印线程ID</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In thread:thread id = %lu\n"</span>, pthread_self());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %u\n"</span>,getpid());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In main1:thread id = %lu\n"</span>, pthread_self());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %u\n"</span>,getpid());</span><br><span class="line">	ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span> ,<span class="string">"pthread_create error:%s\n"</span>,strerror(ret));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In main2:thread id = %lu\n"</span>, pthread_self());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %u\n"</span>,getpid());</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环创建多个线程"><a href="#循环创建多个线程" class="headerlink" title="循环创建多个线程"></a>循环创建多个线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int i = *(int *)arg;这样是错误的</span></span><br><span class="line">	<span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line">	sleep(i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%dth thread:"</span>,i+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In thread:thread id = %lu\n"</span>, pthread_self());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %u\n"</span>,getpid());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="comment">//在线程取地址之后，有可能i的值发生变化</span></span><br><span class="line">		<span class="comment">//ret = pthread_create(&amp;tid, NULL, thrd_func, (void *)&amp;i);</span></span><br><span class="line">		ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span> *)i);</span><br><span class="line">		<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span> ,<span class="string">"pthread_create error:%s\n"</span>,strerror(ret));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程之间共享全局变量"><a href="#线程之间共享全局变量" class="headerlink" title="线程之间共享全局变量"></a>线程之间共享全局变量</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//线程之间共享全局变量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	var = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"at first var = %d\n"</span>, var);</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"after pthread_create, var = %d\n"</span>, var);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h2><p>作用：将单个线程退出<br>函数原型：void pthread_exit(void <em>retval)<br>参数：retval表示线程退出状态，通常传NULL<br>*</em>注意：线程中，禁止使用exit函数，会导致进程内所有线程全部退出。**</p>
<h2 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h2><p>作用：阻塞等待线程退出，获取线程退出状<br>函数原型：int pthread_join(pthread_t thread, void **retval)</p>
<p>成功：0；失败：错误号<br>参数：thread：线程ID,retval：存储线程结束状态。</p>
<p>1、如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。<br>2、如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。<br>3、如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。<br>4、如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。</p>
<h2 id="回收多个子线程"><a href="#回收多个子线程" class="headerlink" title="回收多个子线程"></a>回收多个子线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//循环回收多个子线程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	i = (<span class="keyword">int</span>)arg;</span><br><span class="line">	sleep(i);</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">1</span>)<span class="comment">//第二个线程修改val=333</span></span><br><span class="line">	&#123;</span><br><span class="line">		var = <span class="number">333</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"var = %d\n"</span>,var);</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">void</span> *)var;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>)<span class="comment">//第4个线程修改val=777</span></span><br><span class="line">	&#123;</span><br><span class="line">		var = <span class="number">777</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm %dth pthread, id = %lu\n var = %d\n"</span>,i+<span class="number">1</span>, pthread_self(), var);</span><br><span class="line">		pthread_exit((<span class="keyword">void</span> *)var);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm %dth pthread, id = %lu\n var = %d\n"</span>,i+<span class="number">1</span>, pthread_self(), var);</span><br><span class="line">		pthread_exit((<span class="keyword">void</span> *)var);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> *ret[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_create(&amp;tid[i], <span class="literal">NULL</span>, tfn, (<span class="keyword">void</span> *)i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span> ;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_join(tid[i], (<span class="keyword">void</span> **)&amp;ret[i]);<span class="comment">//回收子线程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d 's ret = %d\n"</span>, i+<span class="number">1</span>, (<span class="keyword">int</span>)ret[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I'm main pthread tid = %lu\t var = %d\n"</span>,pthread_self(), var);</span><br><span class="line">	sleep(i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pthread-deatch函数"><a href="#pthread-deatch函数" class="headerlink" title="pthread_deatch函数"></a>pthread_deatch函数</h2><p>作用：实现线程分离<br>函数原型：int pthread_detach(pthread_t thread<br>成功：0，失败：错误号<br><strong>线程分离状态</strong>：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放<br>网络、多线程服务器常用。</p>
<h2 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h2><p>作用：杀死(取消)线程<br>函数原型：int pthread_cancel(pthread_t thread<br>成功：0，失败：错误号</p>
<p>线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。<br><strong>取消点</strong>：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write….. </p>
<p>可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthreestcancel函数自行设置一个取消点。</p>
<p>被取消的线程，退出值定义在Linux的pthread库中<br>常数PTHREAD_CANCELED的值是-1。可在头文件pthread.h中找到它的定义：#define PTHREAD_CANCELED ((void *) -1)。因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1。</p>
<h2 id="杀死线程的三种方式"><a href="#杀死线程的三种方式" class="headerlink" title="杀死线程的三种方式"></a>杀死线程的三种方式</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//杀死线程3种方式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 1 returning\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 2 exiting\n"</span>);</span><br><span class="line">	pthread_exit((<span class="keyword">void</span> *)<span class="number">222</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn3</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//printf("thread 3:I'm going to die in 3 seconds\n");</span></span><br><span class="line">		<span class="comment">//sleep(1);</span></span><br><span class="line">		pthread_testcancel();<span class="comment">//自己设置取消点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">666</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">void</span> *tred = <span class="literal">NULL</span>;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid, &amp;tred);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 1 exit code = %d\n\n"</span>, (<span class="keyword">int</span>)tred);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn2, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid, &amp;tred);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 2 exit code = %d\n\n"</span>, (<span class="keyword">int</span>)tred);</span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn3, <span class="literal">NULL</span>);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">	pthread_cancel(tid);<span class="comment">//需要到达某个取消点 系统调用</span></span><br><span class="line">	pthread_join(tid, &amp;tred);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 3 exit code = %d\n\n"</span>, (<span class="keyword">int</span>)tred);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>LWP</tag>
      </tags>
  </entry>
  <entry>
    <title>竞态条件（时序竞态）</title>
    <url>/2020/05/18/%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%88%E6%97%B6%E5%BA%8F%E7%AB%9E%E6%80%81%EF%BC%89/</url>
    <content><![CDATA[<h1 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a>pause函数</h1><p>调用该函数可以造成进程主动挂起，等待信号唤醒。<br>调用该系统调用的进程将处于阻塞状态(主动放弃cpu) 直到有信号递达将其唤醒。<br>函数原型：int pause(void）<br>返回值：-1 并设置errno为EINTR<br>返回值：<br>1、如果信号的默认处理动作是终止进程，则进程终止，pause函数没有机会返回。<br>2、如果信号的默认处理动作是忽略，进程继续处于挂起状态，pause函数不返回。<br>3、如果信号的处理动作是捕捉，则调用完信号处理函数之后，pause返回-1，errno设置为EINTR，表示“被信号中断”。<br>4、pause收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒。</p>
<h1 id="sleep实现"><a href="#sleep实现" class="headerlink" title="sleep实现"></a>sleep实现</h1><h2 id="存在时序竞态问题"><a href="#存在时序竞态问题" class="headerlink" title="存在时序竞态问题"></a>存在时序竞态问题</h2><p>pause函数和alarm函数实现sleep<br>可以通过设置屏蔽SIGALRM的方法来控制程序执行逻辑，但无论如何设置，程序都有可能在“解除信号屏蔽”与“挂起等待信号”这个两个操作间隙失去cpu资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_sigalarm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">	act.sa_handler = catch_sigalarm;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = sigaction(SIGALRM, &amp;act, &amp;oldact);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"sigaction error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	alarm(seconds);</span></span><br><span class="line"><span class="comment">	//如果失去了CPU，优先级较高的程序较多，长时间没有分配CPU</span></span><br><span class="line"><span class="comment">	//如果2S后再获得CPU，先处理信号，程序则不能被唤醒</span></span><br><span class="line"><span class="comment">	ret = pause();</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	alarm(seconds);</span><br><span class="line">	<span class="comment">//屏蔽</span></span><br><span class="line">	ret = pause();</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINTR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pause successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = alarm(<span class="number">0</span>);</span><br><span class="line">	sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);<span class="comment">//恢复SIGALRM信号旧有的处理方式</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ret = mysleep(<span class="number">1</span>);<span class="comment">//睡1S</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d------\n"</span>,ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可将某个信号（如SIGALRM）从临时信号屏蔽字mask中删除，这样在调用sigsuspend时将解除对该信号的屏蔽，然后挂起等待，当sigsuspend返回时，进程的信号屏蔽字恢复为原来的值。如果原来对该信号是屏蔽态，sigsuspend函数返回后仍然屏蔽该信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nsecs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">	<span class="keyword">sigset_t</span> newmask, oldmask, suspmask;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line">	<span class="comment">//1、为SIGALRM设置捕捉函数</span></span><br><span class="line">	newact.sa_handler = sig_alrm;</span><br><span class="line">	sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">	newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigaction(SIGALRM, &amp;newact, &amp;oldact);</span><br><span class="line">	<span class="comment">//2、设置阻塞信号集，阻塞SIGALRM信号</span></span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigaddset(&amp;newmask, SIGALRM);</span><br><span class="line">	sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);<span class="comment">//屏蔽信号字 mask</span></span><br><span class="line">	<span class="comment">//3、定时n秒，到时后可以产生SIGALRM信号</span></span><br><span class="line">	alarm(nsecs);</span><br><span class="line">	<span class="comment">//4、构造一个调用sigsuspend临时有效的阻塞信号集</span></span><br><span class="line">	<span class="comment">//在临时阻塞信号集里解除SIGALRM的阻塞</span></span><br><span class="line">	suspmask = oldmask;                 <span class="comment">//SIGALRM没有被阻塞</span></span><br><span class="line">	sigdelset(&amp;suspmask, SIGALRM);<span class="comment">//保证SIGALRM一定没有被屏蔽</span></span><br><span class="line">	<span class="comment">//5、sigsuspend调用期间，采用临时阻塞信号集suspmask替换原有</span></span><br><span class="line">	<span class="comment">//这个信号集中不包括SIGALRM信号，同时挂起等待</span></span><br><span class="line">	<span class="comment">//当sigsuspend被信号唤醒返回时，恢复原有的阻塞信号集</span></span><br><span class="line">	sigsuspend(&amp;suspmask);<span class="comment">//解除屏蔽调用信号处理函数，同时执行</span></span><br><span class="line">	unslept = alarm(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//6、恢复SIGALRM原有的处理动作-----回应注释1</span></span><br><span class="line">	sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//7、解除对SIGALRM阻塞-------回应注释2</span></span><br><span class="line">	sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> unslept;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mysleep(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"------\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</p>
<p>不可靠由其实现原理所致：信号是通过软件方式实现(跟内核调度高度依赖，延时性强)，每次系统调用结束后，或中断处理处理结束后，需通过扫描PCB中的未决信号集，来判断是否应处理某个信号。当系统负载过重时，会出现时序混乱。</p>
<p>这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。且由于该错误不具规律性，后期捕捉和重现十分困难。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>进程的创建以及exec族函数的应用</title>
    <url>/2020/05/14/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BB%A5%E5%8F%8Aexec%E6%97%8F%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="父子进程共享"><a href="#父子进程共享" class="headerlink" title="父子进程共享"></a>父子进程共享</h2><p>父子进程间遵循读时共享写时复制的原则。</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>全局变量、.date、.text、栈、堆、环境变量、用户ID、宿主ID、进程工作目录、信号处理方式…</p>
<h3 id="非共享"><a href="#非共享" class="headerlink" title="非共享"></a>非共享</h3><p>进程ID、fork返回值、父进程ID、进程运行时间、闹钟、未决信号集</p>
<h2 id="循环创建多个多进程"><a href="#循环创建多个多进程" class="headerlink" title="循环创建多个多进程"></a>循环创建多个多进程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"xxxxxxxx\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">//关键所在</span></span><br><span class="line">                <span class="comment">//如果不break则会导致子进程继续fork，从而导致不只有5个子进程</span></span><br><span class="line">                <span class="comment">//      printf("I'm %dth child ,pid = %u,ppid = %u\n",i+1,getpid(),getppid());</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm %dth child, pid = %u\n"</span>,i+<span class="number">1</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm parent"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"yyyyyyyyyyyy\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="exec族函数"><a href="#exec族函数" class="headerlink" title="exec族函数"></a>exec族函数</h2><p>用途：加载某一个进程</p>
<h3 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h3><p>加载一个进程，借助PATH环境变量</p>
<p>int execlp(const char *file, const char *arg, …)成功：无返回；失败：-1<br>参数1 : 要加载的程序的名字。</p>
<p>execlp(“ls”, “ls”, “-l”, “-F”, NULL);         使用程序名在PATH中搜索。<br>该函数通常调用系统程序例如：ls date cp</p>
<h3 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h3><p>加载一个进程， 通过 路径+程序名 来加载。</p>
<p>int execl(const char *path, const char *arg, …成功：无返回；失败：-1</p>
<p>execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL);<br>使用参数1给出的绝对路径搜索。</p>
<h3 id="execvp"><a href="#execvp" class="headerlink" title="execvp"></a>execvp</h3><p>加载一个进程，使用自定义环境变量env</p>
<p>int execvp(const char *file, const char *argv[]);<br>变参形式： ①… ② argv[]  (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, …)) </p>
<p>变参终止条件：① NULL结尾 ② 固参指定</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">"fork "</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"parent\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//execl("./while","while",NULL);</span></span><br><span class="line">                execl(<span class="string">"/bin/ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"-F"</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">//execlp("ls", "ls","-l","-a",NULL);</span></span><br><span class="line">                <span class="keyword">char</span> *argv[] = &#123;<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="string">"-a"</span>,<span class="string">"-h"</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">                <span class="comment">//execv("/bin/ls",argv);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用dup2-重定向输出到文件中"><a href="#利用dup2-重定向输出到文件中" class="headerlink" title="利用dup2()重定向输出到文件中"></a>利用dup2()重定向输出到文件中</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd; </span><br><span class="line">        fd = <span class="built_in">open</span>(<span class="string">"ps.out"</span>, O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">"open ps.out"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">        dup2(fd, STDOUT_FILENO);<span class="comment">//dup2(3,1);</span></span><br><span class="line">        <span class="comment">//将标准输出重定向到自己创建的文件中</span></span><br><span class="line">        execlp(<span class="string">"ps"</span>,<span class="string">"ps"</span>,<span class="string">"aux"</span>,<span class="literal">NULL</span>);<span class="comment">//no successful return</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>线程属性</title>
    <url>/2020/05/20/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="线程属性结构体"><a href="#线程属性结构体" class="headerlink" title="线程属性结构体"></a>线程属性结构体</h1><pre><code>typedef struct
{
    int                     etachstate;     //线程的分离状态
    int                     schedpolicy;     //线程调度策略
    struct sched_param    schedparam;     //线程的调度参数
    int                     inheritsched;     //线程的继承性
    int                     scope;         //线程的作用域
    size_t                 guardsize;     //线程栈末尾的警戒缓冲区大小
    int                    stackaddr_set; //线程的栈设置
    void*                 stackaddr;     //线程栈的位置
    size_t                 stacksize;     //线程栈的大小
} pthread_attr_t; </code></pre><p>主要结构体成员：<br><strong>1、线程分离状态<br>2、线程栈大小（默认平均分配）<br>3、线程栈警戒缓冲区大小（位于栈末尾）</strong>    </p>
<p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。<br>之后须用pthread_attr_destroy函数来释放资源。</p>
<p>线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</p>
<h2 id="pthread-attr-init函数"><a href="#pthread-attr-init函数" class="headerlink" title="pthread_attr_init函数"></a>pthread_attr_init函数</h2><p>作用：初始化线程属性<br>函数原型：int pthread_attr_init(pthread_attr_t *attr)<br>成功：0,失败：错误号</p>
<h2 id="pthread-attr-destroy"><a href="#pthread-attr-destroy" class="headerlink" title="pthread_attr_destroy"></a>pthread_attr_destroy</h2><p>作用：销毁线程属性所占用的资源<br>函数原型：int pthread_attr_destroy(pthread_attr_t *attr)<br>成功：0，失败：错误号</p>
<h1 id="线程的分离状态"><a href="#线程的分离状态" class="headerlink" title="线程的分离状态"></a>线程的分离状态</h1><p>线程的分离状态决定一个线程以什么样的方式来终止自己。<br><strong>非分离状态</strong>：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。<br><strong>分离状态</strong>：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。<br>线程分离状态的函数：<br>设置线程属性，分离or非分离<br>int <strong>pthread_attr_setdetachstate</strong>(pthread_attr_t <em>attr, int detachstate);<br>获取程属性，分离or非分离<br> int *</em>pthread_attr_getdetachstate<strong>(pthread_attr_t <em>attr, int *detachstate);<br>参数：<br>*</em>attr</strong>：已初始化的线程属性<br><strong>detachstate</strong>：<br>PTHREAD_CREATE_DETACHED（分离线程）<br>PTHREAD _CREATE_JOINABLE（非分离线程）<br><strong>注意</strong>：如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</p>
<h2 id="pthread-deatch函数"><a href="#pthread-deatch函数" class="headerlink" title="pthread_deatch函数"></a>pthread_deatch函数</h2><p>作用：实现线程分离<br>函数原型:int pthread_detach(pthread_t thread)<br>成功：0,失败：错误号</p>
<p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。<br>进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。<br>也可使用 pthread_create函数参2(线程属性)来设置线程分离。</p>
<p><strong>可以通过pthread_detach设置分离状态，也可以通过线程属性设置分离状态</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;//线程分离</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"thread count %d\n"</span>, n);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_exit((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">void</span> *tred;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	<span class="keyword">pthread_attr_t</span> attr;<span class="comment">//通过线程属性来设置游离态</span></span><br><span class="line">	<span class="keyword">int</span> ret = pthread_attr_init(&amp;attr);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_init error:%s\n"</span>, strerror(ret));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">	ret = pthread_creat(&amp;tid, &amp;attr, tfn, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create error:%s\n"</span>, strerror(ret));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_detach(tid);<span class="comment">//线程分离，自动退出，无系统残留资源</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		err = pthread_join(tid, &amp;tred);<span class="comment">//设置分离属性以后，err=22</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"err = %d\n"</span>,err);</span><br><span class="line">		<span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"thread_join error: %s\n"</span>, strerror(err));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"thread exit code %d\n"</span>, (<span class="keyword">int</span>)tred);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>LWP</tag>
      </tags>
  </entry>
  <entry>
    <title>若不想使用编译器自动生成的函数，就该明确拒绝</title>
    <url>/2020/10/20/%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D/</url>
    <content><![CDATA[<p>如果你想这个类对象独一无二，那么你肯定不想下面的代码成功</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>&#123;</span>……&#125;;</span><br><span class="line">HomeForSale h1;</span><br><span class="line">HomeForSale h2;</span><br><span class="line"><span class="function">HomeForSale <span class="title">h3</span><span class="params">(h1)</span></span>;<span class="comment">//希望它失败</span></span><br><span class="line">h1 = h2;<span class="comment">//同样希望它失败</span></span><br></pre></td></tr></table></figure>
<p>你可以做以下的设计</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	……</span><br><span class="line">	HomeForSale(<span class="keyword">const</span> HomeForSale&amp; );<span class="comment">//只有声明</span></span><br><span class="line">	HomeForSale&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HomeForSale&amp; );</span><br><span class="line">&#125;：</span><br></pre></td></tr></table></figure>
<p>令这些函数为private，使你得以阻止调用它，如果member函数和friend函数调用private函数，会获得一个连接错误。</p>
<p>还有一种便是设计一个base class</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Uncopyable();<span class="comment">//允许derived class对象构造和析构</span></span><br><span class="line">	~Uncopyable();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">	Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp; );<span class="comment">//但阻止copy</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>:</span><span class="keyword">private</span> Uncopyable&#123;……&#125;;</span><br><span class="line"><span class="comment">//class不再声明copy构造函数和copy assignment操作符</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：<br>    为驳回编译器自动提供的机制，可将相应的成员函数声明为private并且不与实现。使用像Uncopyable这样的base class也是一种做法</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>递归翻转链表的一部分</title>
    <url>/2021/03/29/%E9%80%92%E5%BD%92%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>首先我们直接想翻转链表中间的一部分的时候，我们可以先想到如何翻转一整条链表。</p>
<h1 id="翻转一整条链表"><a href="#翻转一整条链表" class="headerlink" title="翻转一整条链表"></a>翻转一整条链表</h1><p>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;nullptr</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Reverse</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	ListNode *last = Reverse(head-&gt;next);</span><br><span class="line">	head-&gt;next-&gt;next = head;</span><br><span class="line">	head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，递归的边界条件为if(head-&gt;next==nullptr)，当递归到链表的最后一个结点时，也就意味着翻转已经完成。<br>简单的描述一下思想：<br>① 1-&gt;Reverse(2-&gt;3-&gt;4-&gt;5)-&gt;nullptr（注意不要一层一层跳进递归，考虑整体会带来什么结果）<br>② nullptr&lt;-1&lt;-Reverse(2-&gt;3-&gt;4-&gt;5)<br>现在我们完成了一整条链表的翻转，接下来我们进行翻转链表的前n个结点。</p>
<h1 id="翻转链表的前n个结点"><a href="#翻转链表的前n个结点" class="headerlink" title="翻转链表的前n个结点"></a>翻转链表的前n个结点</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode *Nptr;</span><br><span class="line"><span class="function">ListNode* <span class="title">ReverseN</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">		Nptr = head-&gt;next;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode *last = Reverse(head-&gt;next, n<span class="number">-1</span>);</span><br><span class="line">	head-&gt;next-&gt;next = head;</span><br><span class="line">	head-&gt;next = Nptr;</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与翻转整条链表有一些区别</p>
<p>①  首先函数的参数ListNode* Reverse(ListNode *head, int n)新增了int n，表示前n个结点。<br>② if(n == 1)这个递归出口表示，当递归到了n个节点以后，将Nptr指向n+1这个节点，以便当前n个结点翻转完以后，将第一个结点的next指向n+1这个结点。</p>
<h1 id="翻转链表中一部分"><a href="#翻转链表中一部分" class="headerlink" title="翻转链表中一部分"></a>翻转链表中一部分</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ReverseBetween</span><span class="params">(ListNode *head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> ReverseN(head, n);</span><br><span class="line">	&#125;</span><br><span class="line">	head-&gt;next = ReverseBetween(head-&gt;next, m<span class="number">-1</span>, n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们已经能够翻转前n个结点，而翻转链表中一部分的话，可以通过递归思想调用ReverseN()。</p>
<p>如果我们想要翻转2-5这个部分，那么m=2,n=5，然而我们可以把第二个结点看作头结点，然后可以看作翻转1-4(m=1,n=4)这个部分，也就是翻转前4个结点，这样我们就可以调用ReverseN(ListNode *head, int n)来翻转。在翻转以后再使第一个结点的next指向ReverseN()的返回值。这样就完成了翻转链表中的一部分结点。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>马拉车算法</title>
    <url>/2021/03/25/%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个字符串，找出里面的回文串的数目，例如cabadabae</p>
<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>①首先以第三位为中心：”c<strong>aba</strong>dabae”的回文串为”aba”<br>②以第五位为中心：”c<strong>abadaba</strong>e”的回文串为”abadaba”<br>③由以上两条可以判断2-4位对称，2-8位对称，那么在判断第七位为中心的回文串时，很容易得出6-8位也同样是对称的。<br>④由于之前计算已经知道第五位为中心的”abadaba”是回文串，而以第四位为中心的a回文长度是a本身，也就是1，所以以第六位为中心的回文长度只能为1，不用再去扩展判断了。<br>⑤我们已经知道了以第七位为中心的回文串最小长度是3了，但是我们不知道加上第9位以后，以第七位为中心的回文串长度会不会改变，所以我们需要继续向后进行扩展。<br>⑥但有一种特殊情况，回文串的中心可能是连个字符的中间，有一种很巧妙的方法可以避免：在每两个字符的中间加上特殊字符’#’,新的字符串特性不变。</p>
<h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><p>①首先，先对字符串进行处理，避免下标越界，可以把字符串最左边加上’!’，最右边加上’$’，再两个字符中间加上’#’。<br>②然后遍历整个字符串，用一个数组来记录以该字符串位中心的回文长度，为了方便计算右边界，在数组中记录长度的一半。<br>③每一次遍历的时候，如果字符在已知回文串最右边界的覆盖下，那么就计算相对右边界回文串中心对称位置，便可以求出以该字符为中心的回文串长度。<br>④判断该长度和右边界，如果达到了右边界，就需要进行中心扩展。如果第三步的字符并没有在已知回文串的覆盖下，直接进行中心扩展，同时更新右边界。<br>⑤最后累加数组每个元素的一半，也就是每个回文串的长度的一半。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.size();</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        str+=<span class="string">"$#"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)&#123;</span><br><span class="line">            str+=c;</span><br><span class="line">            str+=<span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n=str.size();</span><br><span class="line">        str+=<span class="string">"!"</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> imax=<span class="number">0</span>,rmax=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=rmax)&#123;</span><br><span class="line">                f[i]=min(f[imax*<span class="number">2</span>-i],rmax-i+<span class="number">1</span>);<span class="comment">//初始化f[i]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i]=<span class="number">1</span>;<span class="comment">//如果当前字符不在已知回文串覆盖，则f[i]=1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(str[i+f[i]]==str[i-f[i]])&#123;<span class="comment">//中心拓展</span></span><br><span class="line">                f[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i+f[i]<span class="number">-1</span>&gt;rmax)&#123;<span class="comment">//维护最长回文串的左边界和右边界</span></span><br><span class="line">                rmax=i+f[i]<span class="number">-1</span>;</span><br><span class="line">                imax=i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=(f[i]/<span class="number">2</span>);<span class="comment">//因为添加了特殊字符，所以需要减半</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树展开为链表</title>
    <url>/2021/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>114.二叉树展开为链表<br>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p><img src="https://img-blog.csdnimg.cn/20210517181952729.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>示例 1：<br>输入：root = [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]</p>
<h1 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h1><p>①首先我们可以看出，题意就是将二叉树的左子树搬到右子树，然后将右子树接到当前右子树的末端。<br>②<strong>第一种可以用递归实现</strong><br>1、将root的左子树和右子树拉平<br>2、将root的右子树接到左子树的下方<br>3、然后将整个左子树作为右子树<br>需要注意的是当我们用递归实现算法的时候，一定不要跳进递归里面，而要明确函数在当前层的定义。<br>③我们发现递归方法消耗了空间，下面这种解法可以<strong>原地将二叉树拉成链表</strong>。<br>1、首先找到左子树的最右节点<br>2、然后将根节点的右子树放到左子树最右节点的右子树上<br>3、这时候再将根的左子树放到右子树上</p>
<h1 id="code1-递归"><a href="#code1-递归" class="headerlink" title="code1(递归)"></a>code1(递归)</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        flatten(root-&gt;left);<span class="comment">//递归进入左子树</span></span><br><span class="line">        flatten(root-&gt;right);<span class="comment">//递归进入右子树</span></span><br><span class="line">        <span class="comment">//左右子树已经被拉成一条链表</span></span><br><span class="line">        TreeNode *left = root-&gt;left;</span><br><span class="line">        TreeNode *right = root-&gt;right;</span><br><span class="line">        root-&gt;left = <span class="literal">nullptr</span>;<span class="comment">//将节点的左子节点置为空</span></span><br><span class="line">        root-&gt;right = left;<span class="comment">//将节点的左子节点接到节点的右子节点</span></span><br><span class="line">        TreeNode *temp = root;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;<span class="comment">//将原先的右子节点接到当前右子树的末端</span></span><br><span class="line">            temp = temp-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;right = right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="code2"><a href="#code2" class="headerlink" title="code2"></a>code2</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                TreeNode *most_right = root-&gt;left;<span class="comment">//左子树最右节点</span></span><br><span class="line">                <span class="keyword">while</span>(most_right-&gt;right != <span class="literal">nullptr</span>)&#123;<span class="comment">//找最右节点</span></span><br><span class="line">                    most_right = most_right-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                most_right-&gt;right = root-&gt;right;<span class="comment">//根的右子树接到最右节点的右子树</span></span><br><span class="line">                root-&gt;right = root-&gt;left;<span class="comment">//根的左子树接到右子树</span></span><br><span class="line">                root-&gt;left = <span class="literal">nullptr</span>;<span class="comment">//左子树置为空</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;<span class="comment">//继续下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>根据前中后序遍历构造二叉树</title>
    <url>/2021/05/18/%E6%A0%B9%E6%8D%AE%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="从前序与中序遍历中构造二叉树"><a href="#从前序与中序遍历中构造二叉树" class="headerlink" title="从前序与中序遍历中构造二叉树"></a>从前序与中序遍历中构造二叉树</h1><p>题目：<br>105. 从前序与中序遍历序列构造二叉树<br>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p>
<p>   3<br>   /  \<br>  9  20<br>    /       \<br>   15   7</p>
<h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>①首先找到根节点比较简单，根节点就是前序遍历的第一个元素。<br>②然后<strong>关键就是</strong>通过根节点在中序遍历找出二叉树的左子树与右子树的元素以及数量，递归调用构造二叉树。<br>③如下图所示对于递归构造左子树，前序遍历的范围是[preStart + 1, preStart + leftSize]，中序遍历的范围是[inStart, index - 1]。<br>④对于递归构造右子树，前序遍历的范围是[preStart + leftSize + 1, preEnd]，中序遍历的范围是[index + 1, inEnd]。</p>
<p><img src="https://img-blog.csdnimg.cn/20210518171919635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.size() - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(inStart &gt; inEnd)&#123;<span class="comment">//前序遍历数组左索引大于右索引就返回</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> rootVal = preorder[preStart];<span class="comment">//root节点对应的值就是前序遍历数组的第一个</span></span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//rootVal在中序遍历数组中的索引</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(rootVal == inorder[i])&#123;</span><br><span class="line">               index = i;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> leftSize = index - inStart;<span class="comment">//前序遍历数组中，左子树节点的数量</span></span><br><span class="line">       TreeNode *root = <span class="keyword">new</span> TreeNode(rootVal);<span class="comment">//构造当前节点</span></span><br><span class="line">       <span class="comment">//递归构造左右子树</span></span><br><span class="line">       root-&gt;left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize, inorder, inStart, index - <span class="number">1</span>);</span><br><span class="line">       root-&gt;right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd, inorder, index + <span class="number">1</span>, inEnd);</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h1 id="从后序与中序遍历中构造二叉树"><a href="#从后序与中序遍历中构造二叉树" class="headerlink" title="从后序与中序遍历中构造二叉树"></a>从后序与中序遍历中构造二叉树</h1><p>题目：<br>106. 从中序与后序遍历序列构造二叉树<br>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p>
<p>   3<br>   / \<br>  9  20<br>    /  \<br>   15   7</p>
<h2 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h2><p>与上一题相同，只需要找出根结点的左右子树对应中序遍历以及后序遍历的索引递归即可。</p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(postStart &gt; postEnd)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> rootVal = postorder[postEnd];</span><br><span class="line">       <span class="keyword">int</span> index;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(rootVal == inorder[i])&#123;</span><br><span class="line">               index = i;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> leftSize = index - inStart;</span><br><span class="line">       TreeNode *root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">       root-&gt;left = build(inorder, inStart, index - <span class="number">1</span>,postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">       root-&gt;right = build(inorder, index + <span class="number">1</span>, inEnd,postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>构造最大二叉树</title>
    <url>/2021/05/18/%E6%9E%84%E9%80%A0%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>654 最大二叉树<br>给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：</p>
<p>二叉树的根是数组 nums 中的最大元素。<br>左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。<br>右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。<br>返回有给定数组 nums 构建的 最大二叉树 。</p>
<p> <img src="https://img-blog.csdnimg.cn/20210518164315528.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>示例 1：</p>
<p>输入：nums = [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p>
<ul>
<li>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。<ul>
<li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。<ul>
<li>空数组，无子节点。</li>
<li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul>
<li>空数组，无子节点。</li>
<li>只有一个元素，所以子节点是一个值为 1 的节点。</li>
</ul>
</li>
</ul>
</li>
<li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul>
<li>只有一个元素，所以子节点是一个值为 0 的节点。</li>
<li>空数组，无子节点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h1><p>①对于构造二叉树，根节点要做的就是想办法把自己构造出来。<br>②先遍历数组找出最大值，然后把根节点构造出来，然后对最大值的左边数组和右边数组进行递归调用，作为根节点的左右子树。</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_num = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left;i &lt;= right;i++)&#123;<span class="comment">//找到[left, right]中最大的元素，以及索引</span></span><br><span class="line">            <span class="keyword">if</span>(max_num &lt; nums[i])&#123;</span><br><span class="line">                max_num = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(max_num);<span class="comment">//将最大的元素构造成当前nums的根节点</span></span><br><span class="line">        root-&gt;left = build(nums, left, index - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = build(nums, index + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>旋转数组的最小数字</title>
    <url>/2021/07/15/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<p>示例 1：</p>
<p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p>
<p>输入：[2,2,2,0,1]<br>输出：0</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>①首先发现旋转后的数组可以分为两个增序的子数组，而前面的子数组元素都大于或等于后面的子数组元素，并且最小的元素就是位于两个子数组的分界线，所以可以利用二分法来做。<br>②利用两个指针分别指向第一个元素和最后一个元素，然后找到整个数组的中间元素，如果中间元素位于前面的递增数组，那么它应该大于或等于第一个指针指向的元素，此时的最小元素应该在中间元素的后面，所以把第一个指针指向中间元素。<br>③如果中间元素位于后面的递增数组，它应该小于或等于第二个指针指向的元素，此时的最小元素应该在中间元素的左边或者本身，所以把第二个指针指向中间元素。<br>④当第一个指针与第二个指针相邻的时候，表示第一个指针指向了前面递增数组的最后一个元素，第二个指针指向了后面递增数组的第一个元素，也就是最小元素。<br>⑤考虑特殊情况。如果数组旋转0个，那么第一个元素就是最小元素，所以将mid值初始化为index1。<br>⑥如果数组只有一个元素，直接返回这个元素。<br>⑦如果数组的第一个、最后一个、中间数字都相等，那么只能使用遍历整个数组找到最小元素。</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = len;</span><br><span class="line">        <span class="keyword">int</span> mid = index1;<span class="comment">//初始化为index1</span></span><br><span class="line">        <span class="keyword">while</span>(nums[index1] &gt;= nums[index2])&#123;</span><br><span class="line">            <span class="keyword">if</span>(index1 == index2)&#123;<span class="comment">//当数组只有一个数字时</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index2 - index1 == <span class="number">1</span>)&#123;<span class="comment">//当已经找到最小数字</span></span><br><span class="line">                mid = index2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (index1 + index2) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//当中间数字小于等于最右边数字</span></span><br><span class="line">            <span class="comment">//那么中间这个数一定位于右边的递增数组</span></span><br><span class="line">            <span class="comment">//最小的数字一定位于它前面或者就是本身</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= nums[index2])&#123;</span><br><span class="line">                index2 = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当中间数字大于最左边数字时</span></span><br><span class="line">            <span class="comment">//中间数字一定位于左边的递增数组</span></span><br><span class="line">            <span class="comment">//最小的数字一定位于它的右边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[index1])&#123;</span><br><span class="line">                index1 = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果最左边、中间、最右边相等</span></span><br><span class="line">            <span class="comment">//则需要遍历数组找出最小数字</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == nums[index1] &amp;&amp; </span><br><span class="line">                nums[mid] == nums[index2])&#123;</span><br><span class="line">                <span class="keyword">return</span> Min(nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[mid];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历整个数组找到最小数字</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; result)&#123;</span><br><span class="line">                result = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>二进制中1的个数</title>
    <url>/2021/07/20/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>①第一种方法我们可以想到<strong>将一个整数的最右边一位和1进行与运算，判断是否为1，接着将整数右移一位继续和1进行与运算</strong>，可以统计出1的个数。但这只能适合正整数，如果是负数，当负数右移一位的时候，左边补的是1，这样循环就会无法结束。<br>②第二种方法就可以解决这种问题，我们可以不右移目标数，而是首先将1和目标数进行与运算，<strong>然后将1进行左移，这样就避免了负数左移是1的问题</strong>。这种方法，循环的次数是二进制的位数。<br><strong>③第三种方法可以将循环次数降低到二进制数中1的个数。</strong><br>首先我们先分析<strong>一个数减去1的情况</strong>：<br>1、如果一个整数不为0，那么二进制数中至少有一位是1，先假设最右边一位是1，那么减去1以后，最后一位变成0，其他位保持不变。<br>2、如果最右边一位不是1且位于m位，那么减去1时，第m位由1变成0，而第m位右边的0都变成1。例如一个二进制数为1100，当减去1以后变成1011。<br>结合以上两种情况我们发现一个二进制数减去1，都是把最右边的1变成0，如果它的右边还有0的，则把所有0变成1，而它左边的数不变。我们将原来的数和减去1的数进行与运算，也就是1100和1011进行与运算，结果就是1000。</p>
<p><strong>最终的思路就是把一个整数减去1，再和原整数进行与运算，会把该整数的最右边的1变成0，那么一个二进制表示中有多少1，就可以进行多少次这样的操作。</strong></p>
<p>以下是第三种方法的code</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		count++;</span><br><span class="line">		n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>打印从1到最大的n位数</title>
    <url>/2021/07/27/%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>示例 1:</p>
<p>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>①首先最初的想法就是从1遍历到最大n位数，但是一旦超过了范围就没办法打印。<br>②所以可以用字符串模拟加法。当加到首位还需进位的时候停止循环。<br>③还可以利用全排列的思想，将0-9数字从小到大全排列，则可以得到所有的数字。<br>④输出的时候注意要去掉前导0。</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><h2 id="字符串模拟"><a href="#字符串模拟" class="headerlink" title="字符串模拟"></a>字符串模拟</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(n, <span class="string">'0'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!add(str))&#123;<span class="comment">//逐一累加</span></span><br><span class="line">            inputNum(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> isntOver = <span class="literal">false</span>;<span class="comment">//是否结束</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = str[i] - <span class="string">'0'</span> + carry;<span class="comment">//当前位的结果</span></span><br><span class="line">            <span class="keyword">if</span>(i == str.length() - <span class="number">1</span>)&#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur &gt;= <span class="number">10</span>)&#123;<span class="comment">//当进位的时候</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;<span class="comment">//当进位到最高位</span></span><br><span class="line">                    isntOver = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    carry = <span class="number">1</span>;</span><br><span class="line">                    str[i] = cur - <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[i] = cur + <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isntOver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inputNum</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isntNeedZero = <span class="literal">true</span>;<span class="comment">//判断是否需要0,消除前置0</span></span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isntNeedZero &amp;&amp; str[i] != <span class="string">'0'</span>)&#123;</span><br><span class="line">                isntNeedZero = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isntNeedZero)&#123;</span><br><span class="line">                s += str[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.emplace_back(stoi(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="全排列法"><a href="#全排列法" class="headerlink" title="全排列法"></a>全排列法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(n, <span class="string">'0'</span>)</span></span>;</span><br><span class="line">        dfs(str, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == length)&#123;</span><br><span class="line">            inputNum(str);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">9</span>;i++)&#123;</span><br><span class="line">            str[index] = i + <span class="string">'0'</span>;</span><br><span class="line">            dfs(str, n, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inputNum</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isntNeedZero = <span class="literal">true</span>;<span class="comment">//判断是否需要0,消除前置0</span></span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isntNeedZero &amp;&amp; str[i] != <span class="string">'0'</span>)&#123;</span><br><span class="line">                isntNeedZero = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isntNeedZero)&#123;</span><br><span class="line">                s += str[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="string">""</span>)<span class="comment">//当s=="000"时，stoi会抛出异常</span></span><br><span class="line">            ans.emplace_back(stoi(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/2021/07/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请实现一个函数用来匹配包含’.‘和’*‘的正则表达式。模式中的字符’.‘表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<p>示例 1:</p>
<p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p>
<h1 id="解题思路以及代码"><a href="#解题思路以及代码" class="headerlink" title="解题思路以及代码"></a>解题思路以及代码</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>①每次从字符串里拿出一个字符和模式中的字符去匹配，有两种大致的情况<br>②当模式中第二个字符不是*时，<strong>如果字符串中的第一个字符和模式中的第一个字符相匹配</strong>，那么字符串和模式都往后移动一个字符，接着匹配后续的字符。<br>③当模式中的第二个字符是*时。<strong>如果*号前一个字符与字符串匹配</strong>，则可以在字符串上向后移动一位，模式不变或者向后移动两位。或者字符串不动，模式串向后移动两位。具体解释见代码注释。</p>
<h3 id="code1"><a href="#code1" class="headerlink" title="code1"></a>code1</h3><p>这个递归代码如果字符串过长则会匹配超时，但思路清晰。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">""</span> || p == <span class="string">""</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> matchCore(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> si, <span class="built_in">string</span> p, <span class="keyword">int</span> pi)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (si == s.length() &amp;&amp; pi == p.length()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (si != s.length() &amp;&amp; pi == p.length()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (p[pi + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;<span class="comment">//当下一个正则字符是*</span></span><br><span class="line">			<span class="comment">//当字符串字符和正则字符相等或正则字符为'.'且字符串还没有匹配结束</span></span><br><span class="line">			<span class="keyword">if</span> (s[si] == p[pi] || (p[pi] == <span class="string">'.'</span> &amp;&amp; si != s.length())) &#123;</span><br><span class="line">				<span class="keyword">return</span> matchCore(s, si + <span class="number">1</span>, p, pi + <span class="number">2</span>)<span class="comment">//下一个状态匹配，例如a*匹配到a一个字符</span></span><br><span class="line">					|| matchCore(s, si + <span class="number">1</span>, p, pi)<span class="comment">//继续匹配，例如a*匹配到a以后继续匹配a后面的字符，也就是a*匹配一个以上</span></span><br><span class="line">					|| matchCore(s, si, p, pi + <span class="number">2</span>);<span class="comment">//忽略*，例如a*匹配为空</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> matchCore(s, si, p, pi + <span class="number">2</span>);<span class="comment">//忽略*</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s[si] == p[pi] || (p[pi] == <span class="string">'.'</span> &amp;&amp; si != s.length())) &#123;</span><br><span class="line">			<span class="keyword">return</span> matchCore(s, si + <span class="number">1</span>, p, pi + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="code2"><a href="#code2" class="headerlink" title="code2"></a>code2</h3><p>优化版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">compareMatch</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="built_in">string</span>&amp; p, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[m] == <span class="string">'\0'</span>) <span class="keyword">return</span> s[n] == <span class="string">'\0'</span>;</span><br><span class="line">       <span class="comment">//判断字符串与模式串的字符是否匹配</span></span><br><span class="line">        <span class="keyword">bool</span> first_match = (s[n] != <span class="string">'\0'</span>) &amp;&amp; (s[n] == p[m] || p[m] == <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (p[m + <span class="number">1</span>] != <span class="string">'\0'</span> &amp;&amp; p[m + <span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">return</span> (first_match &amp;&amp; compareMatch(s, p, n + <span class="number">1</span>, m)) || compareMatch(s, p, n, m + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; compareMatch(s, p, n + <span class="number">1</span>, m + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareMatch(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>大致和递归相同<br>①状态定义：dp[i][j]代表s的前i个字符与p的前j个字符是否匹配<br>②转移方程<br>当p[j-1]==’*‘时，dp[i][j]在以下任一情况为true则为true<br>1、dp[i][j-2],即字母+*号组合看作出现0次，能否匹配<br>2、dp[i-1][j]且s[i-1]=p[j-2]，即让*号前面的字符多出现一次<br>3、dp[i-1][j]且p[j-2]=’.’，即让’.’号多出现一次<br>当p[j-1]!=’*‘时，在以下任一情况为true则为true<br>1、dp[i-1][j-1]且s[i-1]=p[j-1]，即让字符p[j-1]多出现一次，看能否匹配<br>2、dp[i-1][j-1]且p[j-1]=’.’，即将字符’.’看作s[i-1]，看能否匹配。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> si = s.size();</span><br><span class="line">        <span class="keyword">int</span> pi = p.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(si + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(pi + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= pi;i += <span class="number">2</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>] &amp;&amp; p[i - <span class="number">1</span>] == <span class="string">'*'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= si;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= pi;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j - <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j - <span class="number">2</span>]) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dp[i - <span class="number">1</span>][j] &amp;&amp; s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>]) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dp[i - <span class="number">1</span>][j] &amp;&amp; p[j - <span class="number">2</span>] == <span class="string">'.'</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>]) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">'.'</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[si][pi];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>手撸LRU</title>
    <url>/2021/07/29/%E6%89%8B%E6%92%B8LRU/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p>
<p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<p>示例：</p>
<p>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p>
<p>解释<br>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 1); // 缓存是 {1=1}<br>lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}<br>lRUCache.get(1);    // 返回 1<br>lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br>lRUCache.get(2);    // 返回 -1 (未找到)<br>lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br>lRUCache.get(1);    // 返回 -1 (未找到)<br>lRUCache.get(3);    // 返回 3<br>lRUCache.get(4);    // 返回 4</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>要让put()和get()时间复杂度为O(1)应该满足以下条件<br>①根据题目的要求，cache中的元素应该有时序以及要支持快速删除以及插入，符合这样要求的数据结构有链表。<br>②还要在cache中快速找到key并且对应的value，也就是使用哈希表。<br>③由以上两点，LRU的核心数据结构就是双向哈希链表。<br>④需要用双向链表是因为在删除节点的时候需要知道该节点的前驱节点，而只有双向链表可以做到O(1)时间复杂度下做到。<br><strong>注意:</strong><br>之所以在Node中储存key和value，考虑到当需要删除最近最久未使用的节点的时候，如果Node中没有key而只有value，我们只能删除链表中的节点，而无法找到map中对应的键。</p>
<p>其余细节见代码注释</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> key, val;</span><br><span class="line">	Node *next, *prev;</span><br><span class="line">	Node(<span class="keyword">int</span> k, <span class="keyword">int</span> v) :key(k), val(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node *head, *tail;<span class="comment">//头尾节点</span></span><br><span class="line">	<span class="keyword">int</span> size;<span class="comment">//链表长度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*初始化双向链表*/</span></span><br><span class="line">	DoubleList() &#123;</span><br><span class="line">		head = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		tail = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		head-&gt;next = tail;</span><br><span class="line">		tail-&gt;prev = head;</span><br><span class="line">		size = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*在链表结尾添加节点x,O(1)*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">		x-&gt;prev = tail-&gt;prev;</span><br><span class="line">		x-&gt;next = tail;</span><br><span class="line">		tail-&gt;prev-&gt;next = x;</span><br><span class="line">		tail-&gt;prev = x;</span><br><span class="line">		size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*在链表中删除x节点，O(1)*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">		x-&gt;prev-&gt;next = x-&gt;next;</span><br><span class="line">		x-&gt;next-&gt;prev = x-&gt;prev;</span><br><span class="line">		size--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*删除链表的第一个节点*/</span></span><br><span class="line">	<span class="function">Node* <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head-&gt;next == tail) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node *first = head-&gt;next;</span><br><span class="line">		remove(first);</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;size; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cap = capacity;</span><br><span class="line">		DoubleList *cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (Map.find(key) == Map.end()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		makeRecently(key);</span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node*&gt;::iterator iter = Map.find(key);<span class="comment">//在map中找到Node</span></span><br><span class="line">		<span class="keyword">int</span> val = (*iter).second-&gt;val;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (Map.find(key) != Map.end()) &#123;<span class="comment">//如果map找到元素</span></span><br><span class="line">			deleteKey(key);<span class="comment">//删除这个元素并重新构造新的元素加入</span></span><br><span class="line">			addRencently(key, value);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cap == cache.Size()) &#123;<span class="comment">//如果容量满了</span></span><br><span class="line">			removeLeastRencently();<span class="comment">//删除最近最久未使用的元素</span></span><br><span class="line">		&#125;</span><br><span class="line">		addRencently(key, value);<span class="comment">//构造元素加入</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/*将某个key提升为最近使用过的*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node*&gt;::iterator iter = Map.find(key);<span class="comment">//在map中找到Node</span></span><br><span class="line">		Node *x = (*iter).second;</span><br><span class="line">		cache.remove(x);<span class="comment">//从链表中删除该节点</span></span><br><span class="line">		cache.addLast(x);<span class="comment">//添加到链表尾部</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*添加最近使用过的元素*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addRencently</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		Node *x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line">		cache.addLast(x);<span class="comment">//添加到链表尾部</span></span><br><span class="line">		Map.insert(make_pair(key, x));<span class="comment">//加入map中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*删除某一个key*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteKey</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node*&gt;::iterator iter = Map.find(key);<span class="comment">//在map中找到Node</span></span><br><span class="line">		Node *x = (*iter).second;</span><br><span class="line">		cache.remove(x);<span class="comment">//从链表中删除该节点</span></span><br><span class="line">		Map.erase(iter);<span class="comment">//在map中删除</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*删除最近最久未使用的元素*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeLeastRencently</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Node *deleteNode = cache.removeFirst();</span><br><span class="line">		<span class="keyword">int</span> deletekey = deleteNode-&gt;key;</span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node*&gt;::iterator iter = Map.find(deletekey);<span class="comment">//在map中找到Node</span></span><br><span class="line">		Map.erase(iter);<span class="comment">//在map中删除</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node*&gt; Map;</span><br><span class="line">	DoubleList cache;</span><br><span class="line">	<span class="keyword">int</span> cap;<span class="comment">//最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>手撸LFU</title>
    <url>/2021/07/30/%E6%89%8B%E6%92%B8LFU/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</p>
<p>实现 LFUCache 类：</p>
<p>LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象<br>int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。<br>void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。<br>注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。</p>
<p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。</p>
<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。</p>
<p>示例：</p>
<p>输入：<br>[“LFUCache”, “put”, “put”, “get”, “put”, “get”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]<br>输出：<br>[null, null, null, 1, null, -1, 3, null, -1, 3, 4]</p>
<p>解释：<br>// cnt(x) = 键 x 的使用计数<br>// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）<br>LFUCache lFUCache = new LFUCache(2);<br>lFUCache.put(1, 1);   // cache=[1,_], cnt(1)=1<br>lFUCache.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1<br>lFUCache.get(1);      // 返回 1<br>                      // cache=[1,2], cnt(2)=1, cnt(1)=2<br>lFUCache.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小<br>                      // cache=[3,1], cnt(3)=1, cnt(1)=2<br>lFUCache.get(2);      // 返回 -1（未找到）<br>lFUCache.get(3);      // 返回 3<br>                      // cache=[3,1], cnt(3)=2, cnt(1)=2<br>lFUCache.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用<br>                      // cache=[4,3], cnt(4)=1, cnt(3)=2<br>lFUCache.get(1);      // 返回 -1（未找到）<br>lFUCache.get(3);      // 返回 3<br>                      // cache=[3,4], cnt(4)=1, cnt(3)=3<br>lFUCache.get(4);      // 返回 4<br>                      // cache=[3,4], cnt(4)=2, cnt(3)=3</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>①LFU比LRU要复杂一些，因为LFU相当于是淘汰访问频次最低的元素，如果访问频次最低的有多个，那么就需要淘汰最旧的元素。这就需要按照数据访问频次来排序。用freq表示频次。<br>②如果我们要实现O(1)的时间复杂度，那么首先想到哈希表。<br>③当我们想要通过key得到value的时候，使用一个哈希表储存key到value的映射。<br>④在我们用get()或put()方法的时候，只要访问了key就要将该key的freq加一，如果在容量满的时候进行插入，则需要将freq最小的key删除，如果有多个就删除最旧的。所以需要另一个哈希表储存key到freq的映射。<br>⑤当我们删除key的时候，就需要知道最小的freq然后再通过freq来找到对应的key，为了实现O(1)的时间复杂度，用一个minfreq来记录最小的freq。<br>⑥但是freq对应的key可能会有多个，所以需要一个freq对应一个key的列表，可以想到哈希链表，能够快速删除其中的元素。<br>⑦<strong>get()逻辑</strong>：如果keyToVal中没有找到对应的元素，返回-1，如果找到了则将freq+1。<br>⑧<strong>put()逻辑</strong>：如果key存在，则修改key所对应的val值，并将freq+1。如果key不存在并且容量未满，则直接插入即可，将freq置1，如果容量满了，则需要淘汰minfreq对应的key。</p>
<p>所以<strong>LFU的基本数据结构</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; keyToVal;<span class="comment">//key到val的映射</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; keyToFreq;<span class="comment">//key到freq的映射</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DoubleList*&gt; freqToKeys;<span class="comment">//freq到key的映射</span></span><br><span class="line"><span class="keyword">int</span> minfreq;<span class="comment">//最小频次</span></span><br><span class="line"><span class="keyword">int</span> cap;<span class="comment">//最大容量</span></span><br></pre></td></tr></table></figure>
<p>而<strong>哈希链表的基本数据结构</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node *head, *tail;<span class="comment">//头尾节点</span></span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">//链表长度</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node*&gt; Map;<span class="comment">//每条链表节点的hash</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><br>①代码简单的实现了哈希双向链表：在双向链表中加入一个哈希表来快速找到相应的节点。<br>②如果删除某个key以后，minfreq对应的列表为空，也就是minfreq需要被更新，实际上没有办法快速找到minfreq，只能通过遍历freqToKey或者keyToFreq来得到，但是就不能保证O(1)的时间复杂度。<strong>当我们需要用到minfreq的时候一定是put()中插入key之后，但插入key的时候一定会把minfreq更新成1所以可以不用更新此处的minfreq。</strong><br>③std::unordered_map::insert()，插入的时候，如果插入的key值与unordered_map中的key值相冲突的时候，容器会忽略插入的key。<strong>所以在更新unordered_map中的元素的时候需要先删除再进行插入。</strong></p>
<p>具体细节见代码注释</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> key, val;</span><br><span class="line">	Node *next, *prev;</span><br><span class="line">	Node(<span class="keyword">int</span> k, <span class="keyword">int</span> v) :key(k), val(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node *head, *tail;<span class="comment">//头尾节点</span></span><br><span class="line">	<span class="keyword">int</span> size;<span class="comment">//链表长度</span></span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node*&gt; Map;<span class="comment">//每条链表节点的hash</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*初始化双向链表*/</span></span><br><span class="line">	DoubleList() &#123;</span><br><span class="line">		head = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		tail = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		head-&gt;next = tail;</span><br><span class="line">		tail-&gt;prev = head;</span><br><span class="line">		size = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~DoubleList() &#123;</span><br><span class="line">		<span class="keyword">delete</span> head;</span><br><span class="line">		<span class="keyword">delete</span> tail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*在链表结尾添加节点x,O(1)*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">		x-&gt;prev = tail-&gt;prev;</span><br><span class="line">		x-&gt;next = tail;</span><br><span class="line">		tail-&gt;prev-&gt;next = x;</span><br><span class="line">		tail-&gt;prev = x;</span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node*&gt;::iterator iter = Map.find(x-&gt;key);<span class="comment">//****/注意要先删除map中的元素，再插入</span></span><br><span class="line">		<span class="keyword">if</span> (iter != Map.end()) &#123;</span><br><span class="line">			Map.erase(x-&gt;key);</span><br><span class="line">		&#125;</span><br><span class="line">		Map.insert(pair&lt;<span class="keyword">int</span>, Node*&gt;(x-&gt;key, x));</span><br><span class="line">		size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*在链表中删除x节点，O(1)*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">		x-&gt;prev-&gt;next = x-&gt;next;</span><br><span class="line">		x-&gt;next-&gt;prev = x-&gt;prev;</span><br><span class="line">		size--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node* <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node*&gt;::iterator iter = Map.find(key);<span class="comment">//在map中找到Node</span></span><br><span class="line">		Node *x = (*iter).second;</span><br><span class="line">		removeNode(x);<span class="comment">//从链表中删除该节点</span></span><br><span class="line">		Map.erase(iter);<span class="comment">//在map中删除</span></span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*删除链表的第一个节点*/</span></span><br><span class="line">	<span class="function">Node* <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head-&gt;next == tail) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node *first = head-&gt;next;</span><br><span class="line">		removeNode(first);</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;size; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cap = capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;minfreq = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cap == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (keyToVal.find(key) == keyToVal.end()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//增加freq,返回val</span></span><br><span class="line">		increaseFreq(key);</span><br><span class="line">		<span class="keyword">int</span> val = (*keyToVal.find(key)).second;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;cap &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果key存在，修改对应的val即可，并将freq+1</span></span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter1 = keyToVal.find(key);</span><br><span class="line">		<span class="keyword">if</span> (iter1 != keyToVal.end()) &#123;</span><br><span class="line">			keyToVal.erase(key);</span><br><span class="line">			keyToVal.insert(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(key, value));</span><br><span class="line">			increaseFreq(key);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果key不存在则需要插入一个</span></span><br><span class="line">		<span class="comment">//如果容量已满则要淘汰一个最小的freq对应的key</span></span><br><span class="line">		<span class="keyword">if</span> (keyToVal.size() == <span class="keyword">this</span>-&gt;cap) &#123;</span><br><span class="line">			removeMinFreqKeys();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//插入key和val，freq为1</span></span><br><span class="line">		<span class="comment">//插入kv</span></span><br><span class="line">		keyToVal.insert(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(key, value));</span><br><span class="line">		<span class="comment">//插入kf</span></span><br><span class="line">		keyToFreq.insert(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(key, <span class="number">1</span>));</span><br><span class="line">		<span class="comment">//插入fk</span></span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DoubleList*&gt;::iterator iter2 = freqToKeys.find(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (iter2 == freqToKeys.end()) &#123;</span><br><span class="line">			DoubleList *<span class="built_in">list</span> = <span class="keyword">new</span> DoubleList();</span><br><span class="line">			freqToKeys.insert(pair&lt;<span class="keyword">int</span>, DoubleList*&gt;(<span class="number">1</span>, <span class="built_in">list</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		iter2 = freqToKeys.find(<span class="number">1</span>);</span><br><span class="line">		DoubleList *list2 = (*iter2).second;</span><br><span class="line">		list2-&gt;addLast(<span class="keyword">new</span> Node(key, value));</span><br><span class="line">		<span class="comment">//插入新的key后，最小的freq一定是1</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;minfreq = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/*移除最小的freq且最早的key*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeMinFreqKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//找到freq最小的那个链表</span></span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DoubleList*&gt;::iterator iter = freqToKeys.find(<span class="keyword">this</span>-&gt;minfreq);</span><br><span class="line">		DoubleList *<span class="built_in">list</span> = (*iter).second;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//删除第一个节点也就是最先插入的节点</span></span><br><span class="line">		Node *node = <span class="built_in">list</span>-&gt;removeFirst();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新freqToKeys</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">list</span>-&gt;Size() == <span class="number">0</span>) &#123;</span><br><span class="line">			freqToKeys.erase(<span class="keyword">this</span>-&gt;minfreq);</span><br><span class="line">			<span class="keyword">delete</span> <span class="built_in">list</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//更新keyToVals</span></span><br><span class="line">		keyToVal.erase(node-&gt;key);</span><br><span class="line">		<span class="comment">//更新keyToFreq</span></span><br><span class="line">		keyToFreq.erase(node-&gt;key);</span><br><span class="line">		<span class="keyword">delete</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*增加key的freq*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//更新kf</span></span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter1 = keyToFreq.find(key);</span><br><span class="line">		<span class="keyword">int</span> freq = (*iter1).second;</span><br><span class="line">		keyToFreq.erase(key);</span><br><span class="line">		keyToFreq.insert(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(key, freq + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新fk</span></span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DoubleList*&gt;::iterator iter2 = freqToKeys.find(freq);</span><br><span class="line">		DoubleList *<span class="built_in">list</span> = (*iter2).second;</span><br><span class="line">		Node* x = <span class="built_in">list</span>-&gt;remove(key);<span class="comment">//将key从freq对应的链表中删除</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//将key加入freq+1的链表中</span></span><br><span class="line">		<span class="comment">//如果fk中没有键值位freq+1的映射</span></span><br><span class="line">		iter2 = freqToKeys.find(freq + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (iter2 == freqToKeys.end()) &#123;</span><br><span class="line">			DoubleList *list2 = <span class="keyword">new</span> DoubleList();</span><br><span class="line">			freqToKeys.insert(pair&lt;<span class="keyword">int</span>, DoubleList*&gt;(freq + <span class="number">1</span>, list2));</span><br><span class="line">		&#125;</span><br><span class="line">		iter2 = freqToKeys.find(freq + <span class="number">1</span>);</span><br><span class="line">		DoubleList *list3 = (*iter2).second;</span><br><span class="line">		list3-&gt;addLast(x);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果对应的freq列表空了就移除这个freq</span></span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DoubleList*&gt;::iterator iter3 = freqToKeys.find(freq);</span><br><span class="line">		DoubleList *list4 = (*iter3).second;</span><br><span class="line">		<span class="keyword">if</span> ((*iter3).second-&gt;Size() == <span class="number">0</span>) &#123;</span><br><span class="line">			freqToKeys.erase(freq);</span><br><span class="line">			<span class="keyword">delete</span> list4;</span><br><span class="line">			<span class="comment">//如果这个freq恰好是minfreq那么更新minfreq</span></span><br><span class="line">			<span class="keyword">if</span> (freq == <span class="keyword">this</span>-&gt;minfreq) &#123;</span><br><span class="line">				minfreq++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; keyToVal;<span class="comment">//key到val的映射</span></span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; keyToFreq;<span class="comment">//key到freq的映射</span></span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DoubleList*&gt; freqToKeys;<span class="comment">//freq到key的映射</span></span><br><span class="line">	<span class="keyword">int</span> minfreq;<span class="comment">//最小频次</span></span><br><span class="line">	<span class="keyword">int</span> cap;<span class="comment">//最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>ucore双向循环链表</title>
    <url>/2021/09/29/ucore%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习ucore操作系统之前，我们先要了解ucore相关数据结构，以便于后续顺利进行lab。</p>
<p>在这里提出的是ucore比较有趣的一个数据结构，双向循环链表。和普遍意义的双向链表不同，ucore中的双向循环链表没有包括传统意义上的data数据域，而是在<strong>具体的数据结构中包含链表节点</strong>。接下来我们来具体分析。</p>
<h1 id="传统双向循环链表"><a href="#传统双向循环链表" class="headerlink" title="传统双向循环链表"></a>传统双向循环链表</h1><h2 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="keyword">foo_t</span>;</span><br></pre></td></tr></table></figure>
<p>在传统的双向循环链表中，通常是在这个数据结构中定义数据域，并加入指向前后的两个指针。这种链表存在着一个潜在的问题是，虽然链表的基本操作都是一样的，但是由于不同的数据的数据类型不同，就需要对每种数据单独特定一个链表，会导致代码的冗余。</p>
<h1 id="ucore双向循环链表"><a href="#ucore双向循环链表" class="headerlink" title="ucore双向循环链表"></a>ucore双向循环链表</h1><h2 id="数据结构定义-1"><a href="#数据结构定义-1" class="headerlink" title="数据结构定义"></a>数据结构定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个链表中，并没有包含传统的数据域，而是在具体的数据结构中包含链表节点。下面以lab2中的空闲内存块列表示例：</p>
<h3 id="空闲块链表头指针定义"><a href="#空闲块链表头指针定义" class="headerlink" title="空闲块链表头指针定义"></a>空闲块链表头指针定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> free_list;         <span class="comment">//链表头节点     </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_free;           <span class="comment">//记录空闲块的数量</span></span><br><span class="line">&#125; <span class="keyword">free_area_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="空闲块链表节点定义"><a href="#空闲块链表节点定义" class="headerlink" title="空闲块链表节点定义"></a>空闲块链表节点定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> ref;               <span class="comment">//页面引用计数器</span></span><br><span class="line">    ……                          <span class="comment">//其他相关数据</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;     <span class="comment">//链表指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样就可以以free_area_t结构的数据为双向循环链表的头指针，以Page结构的数据为双向循环链表的链表节点，就可以形成一个完整的双向循环链表。如下图:<br><img src="https://img-blog.csdnimg.cn/img_convert/28d4742ec9af01a2da6658684913a350.png#pic_center" alt="在这里插入图片描述"></p>
<p>通过图片我们可以清除的看到，这种结构避免了为不同的数据定义特定的链表节点，而且可以使所有不同的数据共享通用的链表操作函数。接下来我们来分析链表的具体操作。</p>
<h2 id="链表的基础操作"><a href="#链表的基础操作" class="headerlink" title="链表的基础操作"></a>链表的基础操作</h2><p>对于一个链表，首先应该先初始化一个头指针，以便于接下来节点的插入，删除。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">list_init(<span class="keyword">list_entry_t</span> *elm) &#123;</span><br><span class="line">    elm-&gt;prev = elm-&gt;next = elm;   <span class="comment">//前后指针都指向自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用list_init(&amp;(free_area.free_list))时，就声明了一个链表头，它的next、prev指针都指向自己。现在我们就有一个表示空闲内存块链的空链表。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__list_add(<span class="keyword">list_entry_t</span> *elm, <span class="keyword">list_entry_t</span> *prev, <span class="keyword">list_entry_t</span> *next) &#123;</span><br><span class="line">    prev-&gt;next = next-&gt;prev = elm;  </span><br><span class="line">    elm-&gt;next = next;</span><br><span class="line">    elm-&gt;prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">list_add_before(<span class="keyword">list_entry_t</span> *listelm, <span class="keyword">list_entry_t</span> *elm) &#123;</span><br><span class="line">    __list_add(elm, listelm-&gt;prev, listelm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">list_add_after(<span class="keyword">list_entry_t</span> *listelm, <span class="keyword">list_entry_t</span> *elm) &#123;</span><br><span class="line">    __list_add(elm, listelm, listelm-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，对于链表的插入有两种操作，分别是头插法和尾插法，实际上ucore是利用<strong>list_add(elm, listelm, listelm-&gt;next)</strong> 和<strong>list_add(elm, listelm-&gt;prev, listelm)</strong> 来实现在表头插入和表尾插入。在表头插入是插在listelm之后，即链表的最前位置。而在表尾插入则是插在listelm-&gt;prev之后，即链表的最后位置。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">list_del(<span class="keyword">list_entry_t</span> *listelm) &#123;</span><br><span class="line">    __list_del(listelm-&gt;prev, listelm-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__list_del(<span class="keyword">list_entry_t</span> *prev, <span class="keyword">list_entry_t</span> *next) &#123;</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要删除节点，则可以调用list_del(listem)，如果要确保被删除的节点不再指向链表中的其他节点，则可有通过调用list_init()来把listelm的prev和next指针分别指向自身，即将节点置为空链状态。</p>
<h2 id="访问节点所在的宿主数据结构"><a href="#访问节点所在的宿主数据结构" class="headerlink" title="访问节点所在的宿主数据结构"></a>访问节点所在的宿主数据结构</h2><p>使用链表的重中之重当然也是要对节点数据域进行相关的处理，而ucore的双向循环链表与传统链表不同，不能直接通过节点直接访问到数据域，而要通过地址偏移量得到。</p>
<p>通过上面的描述可知，list_entry_t双向循环链表中仅保存了特定数据结构中链表节点成员变量的地址，那么如何通过这个节点访问到它的所有者呢？Linux中为此专门提供了针对数据结构XXX的le2XXX <strong>(le, member)</strong> 的宏，其中le为list entry的简称，是指向数据结构XXX中list_entry_t成员变量的指针，member则是XXX数据类型中包含的链表节点的成员变量。接下来以Page数据结构来分析如何得到宿主数据结构的地址。</p>
<p>例如我们要遍历空闲块链表中所有的节点则可以采用如下编程方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//free_area是空闲块管理结构，free_area.free_list是空闲块链表头</span></span><br><span class="line"><span class="keyword">free_area_t</span> free_area;</span><br><span class="line"><span class="keyword">list_entry_t</span> * le = &amp;free_area.free_list;  <span class="comment">//le是空闲块链表头指针</span></span><br><span class="line"><span class="keyword">while</span>((le=list_next(le)) != &amp;free_area.free_list) &#123; <span class="comment">//从第一个节点开始遍历</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">page_link</span>);</span> <span class="comment">//获取节点所在基于Page数据结构的变量</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>le2page宏的使用比较简单</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le2page(le, member)                 \</span></span><br><span class="line">to_struct((le), struct Page, member)</span><br></pre></td></tr></table></figure>
<p>而le2page使用的to_struct宏和offsetof宏则有一些难懂</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回数据结构的成员变量在本宿主数据结构中的偏移量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(type, member)                                      \</span></span><br><span class="line">((<span class="keyword">size_t</span>)(&amp;((type *)<span class="number">0</span>)-&gt;member))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回宿主数据结构的地址 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_struct(ptr, type, member)                               \</span></span><br><span class="line">((type *)((<span class="keyword">char</span> *)(ptr) - offsetof(type, member)))</span><br></pre></td></tr></table></figure>


<p>le2page是通过先求得数据结构的成员变量在宿主数据结构中的偏移量，然后根据成员变量的地址反过来得到宿主数据结构的地址。</p>
<p>要理解le2page首先要理解offsetof宏，((size_t)(&amp;((type *)0)-&gt;member))这行代码首先将0地址强制转换为type数据结构，再访问到type数据结构中的member成员的地址，即得到的是member对于type数据结构的偏移量。</p>
<p>而to_struct宏正是利用这个不变的偏移量来求得链表数据项的变量地址，在to_struct宏中，ptr变量是链表节点的地址，把它减去offsetof宏所计算得到的偏移量，即得到了宿主数据结构的变量的地址。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>当第一次看到ucore中这种通用双向循环链表的时候是非常惊艳的，它刷新了我对常规链表的理解。这种通用链表可以很大程度上减少代码的冗余度，提高代码的质量。但我觉得最巧妙的还是通过链表节点的偏移量反过来求出宿主数据结构的地址，这种编程思维是非常值得学习的。</p>
<p>本文参考：<a href="https://chyyuu.gitbooks.io/ucore_os_docs/" target="_blank" rel="noopener">ucore实验指导书</a></p>
]]></content>
      <categories>
        <category>ucore</category>
      </categories>
  </entry>
  <entry>
    <title>浅谈ucoreLab1</title>
    <url>/2021/10/04/%E6%B5%85%E8%B0%88ucoreLab1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过lab1可以了解到操作系统也是一个软件，需要通过某种机制加载并运行。而这种机制简单来讲就是一个比操作系统更简单的软件bootloader，通过bootloader来加载ucore os。在lab1中可以学习到编译运行bootloader的过程，PC启动bootloader的过程，编译、运行os的过程、分段管理以及中断管理等等。</p>
<h1 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h1><p><strong>当计算机加电之后，一般都会执行BIOS完成基本IO初始化及引导加载功能</strong>，简单来讲就是通过BIOS初始化os运行的环境，最终引导程序将操作系统内核映像加载到RAM中，并将控制权交给操作系统。<br>在ucore中，BIOS由bootasm.S和bootmain.c一起组成。BIOS实际上是被固化在ROM中为上层软件提供最底层的支持。以Intel 80386为例，计算机加电后，CPU从0xFFFFFFF0（CS:EIP CS:0xF000, IP:0xFFF0）处开始执行，在这只储存了一条跳转指令，跳转到BIOS的起始点，当BIOS完成自己的工作后就会读取设备的第一扇区（主引导扇区）到内存特定的地址0x7c00处，然后把工作交给bootloader。</p>
<h1 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h1><h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><p><strong>在bootloader接手BIOS的工作后，当前的PC系统处于实模式运行状态</strong>，在这种状态下，软件访问的物理内存空间不能超过1MB，无法发挥Intel 80386以上级别的32位CPU的4GB内存管理能力。</p>
<p>实模式将整个物理内存看成分段区域，内核和用户程序并没有区别对待，每一个指针都是指向实际的物理地址，如果一个用户的指针指向了内核区域并修改了内容，那么就是灾难性的结果。所以bootloader的第一个工作就是将PC从实模式转换到保护模式，这就需要修改A20地址线，下面简单的介绍一下A20地址线：</p>
<p>Intel早期的8086 CPU提供了20根地址线，可寻址的空间范围即0-1MB的内存空间，但是8086的数据线宽位为16位，无法直接寻址1MB的内存空间，所以8086提供了段地址加偏移量的地址转换机制，但是转换以后的地址最大值超过了1MB，也就是超过了20位的寻址范围，所以当寻址超过1MB时则会发生”回卷“。下一代80286 CPU提供了24位地址线，为了保持完全的向下兼容性，于是出现了A20 Gate。在保护模式下，为了使能所有地址的寻址能力，需要打开A20地址线。</p>
<h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><p><strong>在打开A20地址线后，PC就进入了保护模式</strong>，在保护模式下80386的全部32根地址线有效，可寻址4GB的线性地址空间。在保护模式下可以采用分段存储管理机制和分页存储管理机制，不仅为存储共享和保护提供了硬件支持，而且为虚拟存储提供了硬件支持。</p>
<h2 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h2><p><strong>只有在进入保护模式下才可以使用分段存储管理机制</strong>，分段涉及4个关键内容：逻辑地址、段描述符、段描述符表、段选择子。分段地址转换机构把逻辑地址中的选择子作为段描述符表的索引，找到表中对应的段描述符，然后把段描述符中保存的段基址加上段偏移量形成线性地址。<br><strong>段描述符：</strong><br>①段基地址：规定线性地址空间中段的起始地址。<br>②段界限：规定段的大小。<br>③段属性：确定段的各种性质，包括类型、描述符特权级、段存在位、已访问位等等。<br><strong>段描述符表：</strong> 其实就是一个保存多个段描述符的“数组”，起始地址保存在全局描述符表寄存器GDTR中。<br><strong>选择子：</strong> 用来选择哪个描述符表和在该表中索引一个描述符的。选择子的结构如下：<br>①索引：在描述符表中选择一个描述符。<br>②表指示位：选择应该访问哪一个描述符表。全局或局部。<br>③请求特权级（RPL）：进程对段访问的请求权限。<br>通过请求特权级，顺便总结一下CPL和DPL<br>CPL：当前特权级，保存在段选择子的最低两位，描述当前活动代码段的特权级。<br>DPL：描述符特权，存储在段描述符中的权限位，描述对应段所属的特权级。</p>
<p><strong>在ucore中，启动分段机制，还未启动分页机制，目前逻辑地址、线性地址、物理地址关系如下：<br>逻辑地址–&gt;（分段地址转换）–&gt;线性地址 == 物理地址</strong></p>
<h2 id="读取磁盘扇区"><a href="#读取磁盘扇区" class="headerlink" title="读取磁盘扇区"></a>读取磁盘扇区</h2><p><strong>在完成了上述工作以后，bootloader下一步就是读取硬盘扇区</strong>，当前硬盘数据时储存到硬盘扇区中，一个扇区大小为512字节。读取扇区的工作在boot/bootmain.c中的readsect函数，大致流程如下：<br>①等待磁盘准备好<br>②发出读取扇区命令<br>③等待磁盘准备好<br>④把磁盘扇区数据读到指定内存</p>
<h2 id="加载ELF格式的os"><a href="#加载ELF格式的os" class="headerlink" title="加载ELF格式的os"></a>加载ELF格式的os</h2><p>ELF文件格式是一种Linux系统下的一种常用目标文件格式，有三种主要类型：<br>①用于执行的可执行文件：用于提供提供程序镜像，加载的内存执行。<br>②用于连接的可重定位文件，与其他目标文件一起创建可执文件和共享目标文件。<br>③共享目标文件，连接器可将它与其他可重定位文件和共享目标文件连接成其他的目标文件。</p>
<p>加载ELF格式的代码在bootmain.c中的bootmain函数中。<br><strong>在读取硬盘扇区之后，接下来bootloader就要加载ELF格式的os</strong>：首先从第一个扇区（第零个扇区为bootloader）中读取os kernel最开始的4KB代码，然后判断前四个字节是否等于指定的ELF_MAGIC，用于判断ELF header是否合法。接下来从ELF头文件中获取program header表的位置，然后遍历该表的每一项，并且从每一个program header中获取到段应该被加载到内存中的位置，以及段的大小，然后调用readseg函数将每一个段加载到内存中。</p>
<p><strong>至此bootloader还剩下最后一个步骤，就是从ELF header中查询到os kernel的入口地址，然后跳转到该条指令的地址，进入ucore os。</strong></p>
<h1 id="os"><a href="#os" class="headerlink" title="os"></a>os</h1><p>目前lab1的ucore功能比较简单，完成了内存管理以及外设中断管理：<br>①初始化终端<br>②显示字符串<br>③显示堆栈中多层函数调用关系<br>④切换到保护模式，启动分段机制<br>⑤初始化中断控制器，设置中断描述符表，初始化时钟中断，使能整个系统的中断机制</p>
<p>接下来我们分析一下函数的堆栈以及中断。</p>
<h2 id="函数堆栈"><a href="#函数堆栈" class="headerlink" title="函数堆栈"></a>函数堆栈</h2><p>每一次的函数调用都会进行压栈，几乎在每个函数体之前都会有类如如下的汇编指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pushl   %ebp</span><br><span class="line">movl   %esp , %ebp</span><br></pre></td></tr></table></figure>

<p>这两条汇编指令的含义是：首先将ebp寄存器入栈，然后将栈顶指针esp赋值给ebp，表面上看是用esp覆盖ebp的值，实际上在给ebp赋值之前，原ebp的值已经被压栈，而新的ebp恰好指向栈顶。这样就会有一下数据顺序：参数、返回地址、ebp寄存器。如下图所示，栈的结构：</p>
<p><img src="https://img-blog.csdnimg.cn/344fe82bf2764caf8a3d6bfef7604fd8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWhEYWnCtw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>由栈结构可知，ss:[ebp+4]为返回地址，ss:[ebp+8]为第一个参数值，ss:[ebp-4]为第一个局部变量，ss:[ebp]为上一层ebp值。因为ebp处的值总是上一层的ebp值，而在每一层函数调用中，都能通过当前的ebp值向上获取返回地址等数据，以此形成递归，直到栈底。</p>
<p>通过对栈结构的了解，我们可以顺利完成练习5：实现函数调用堆栈跟踪函数。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>在操作系统中有三种特殊的中断事件。<br>①由CPU外部设备引起的外部事件如I/O中断、时钟中断、控制台中断等是异步产生的，与CPU的执行无关，成为异步中断也称外部中断。<br>②而在CPU执行指令期间检测到的不正常或非法条件所引起的内部事件称为同步中断也称内部中断，简称异常。<br>③把在程序中使用请求系统服务的系统调用而引发的事件称作陷入中断，也称软中断。</p>
<p>在lab1中只描述保护模式下的处理过程，当CPU收到中断或异常事件时，它会暂停当前处理的程序或任务，通过一定的机制跳转到负责处理的例程中。然后在返回刚才被打断的程序或任务中。<strong>操作系统在IDT中设置好各种中断向量对应的中断描述符，用于CPU在产生中断后进行查询相应中断例程的入口地址。</strong></p>
<h3 id="中断描述符表（IDT）"><a href="#中断描述符表（IDT）" class="headerlink" title="中断描述符表（IDT）"></a>中断描述符表（IDT）</h3><p>中断描述符表把每个中断或异常编号和一个指向中断服务例程的描述符联系起来。CPU把中断（异常）号乘以8作为IDT的索引。IDT可以存在于内存中任意的位置，CPU通过IDT寄存器的内容来寻址IDT的起始地址。<br>指令LIDT和SIDT用来操作IDTR，两条指令的含义如下：<br>LIDT：使用一个包含线性地址基址和界限的内存操作来加载IDT，os在创建IDT时需要执行它来设定IDT的起始地址。这条指令只能在特权级0执行。<br>SIDT：拷贝IDTR的基址和界限部分到一个内存地址。这条指令可以在任意特权级执行。</p>
<h3 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h3><p>在lab1中，中断处理在trap.c中的trap函数中，所有的中断在经过中断入口函数__alltraps（位于trapasm.S）预处理后，都会跳转到这里。根据不同的中断类型进行相应的处理。在处理结束后，trap会返回，被中断的程序会继续运行。整个中断处理流程大致如下：<br><img src="https://img-blog.csdnimg.cn/25e3e4c9deb843b2ab60c2a2dcca8e96.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWhEYWnCtw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><br><br></p>
<p><strong>至此lab1的工作完成</strong></p>
<p>本文参考：<br><a href="https://chyyuu.gitbooks.io/ucore_os_docs" target="_blank" rel="noopener">https://chyyuu.gitbooks.io/ucore_os_docs</a><br><a href="https://www.jianshu.com/p/2f95d38afa1d" target="_blank" rel="noopener">https://www.jianshu.com/p/2f95d38afa1d</a></p>
]]></content>
      <categories>
        <category>ucore</category>
      </categories>
  </entry>
  <entry>
    <title>在operator=中处理自我赋值</title>
    <url>/2021/10/04/%E5%9C%A8operator=%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<p>众所周知，如果有两个指针或引用指向同一个对象时，当通过一个指针释放了对象，另一个指针就变成了野指针，这是危险的。类似于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[i] = a[j]</span><br><span class="line"></span><br><span class="line">*px = *py</span><br></pre></td></tr></table></figure>
<p>这都是潜在的自我赋值，如果px和py指向的是同一个对象，就是自我赋值。所以我们需要在重载=运算符中处理这种情况。</p>
<h1 id="表面上合理的operator"><a href="#表面上合理的operator" class="headerlink" title="表面上合理的operator="></a>表面上合理的operator=</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span>&#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Bitmap *pb;<span class="comment">//一个指向从heap分配而得的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">	<span class="keyword">delete</span> pb;<span class="comment">//释放当前指向的对象</span></span><br><span class="line">	pb = <span class="keyword">new</span> Bitmap(*rhs.pb);<span class="comment">//使pb指向新的Bitmap</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的自我赋值的问题是，operator=函数内的<em>this可能和rhs是同一个对象，如果是同一个对象，那么在delete的时候就会将rhs的Bitmap也释放。*</em>这样导致的结果是当前的pb指向的是一个已经被删除的对象。**</p>
<h1 id="加入证同测试的operator"><a href="#加入证同测试的operator" class="headerlink" title="加入证同测试的operator="></a>加入证同测试的operator=</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//证同测试</span></span><br><span class="line">	<span class="keyword">delete</span> pb;</span><br><span class="line">	pb = <span class="keyword">new</span> Bitmap(*rhs.bp);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这样做具备了自我赋值安全性，但是却不具备异常安全性</strong>。确切的说如果new Bitmap时导致异常，Widget最终会持有一个指针，指向被删除的Bitmap。</p>
<h1 id="具备异常安全性的operator"><a href="#具备异常安全性的operator" class="headerlink" title="具备异常安全性的operator="></a>具备异常安全性的operator=</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">	Bitmap* pOrig = pb;<span class="comment">//记住原先的pb</span></span><br><span class="line">	pb = <span class="keyword">new</span> Bitmap(*rhs.bp);<span class="comment">//令pb指向新的Bitmap</span></span><br><span class="line">	<span class="keyword">delete</span> pOrig;<span class="comment">//删除原先的pb</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在的operator=中，就具备了异常安全性，如果new Bitmap抛出异常，pb还是会保持原状。即使没有证同测试，这段代码还是能处理自我赋值。虽然不是效率最高的。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Lab3虚拟内存管理</title>
    <url>/2021/10/07/Lab3%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>虚拟内存简单而言就是程序员或CPU看到的内存，有以下几点特征：<br>1、虚拟内存单元不一定有实际的物理内存单元对应，即实际的物理内存单元可能不存在。<br>2、如果虚拟内存单元对应有实际的物理内存单元，二者的地址一般是不相等的。<br>3、通过os实现的某种内存映射可建立虚拟内存与物理内存的对应关系，使得程序员或CPU访问虚拟内存地址时会自动转换为一个物理内存地址。</p>
<p><strong>有了内存虚拟化，就可以通过设置页表项来限定软件运行时的访问空间，确保软件运行不越界。</strong></p>
<h1 id="实验执行流程"><a href="#实验执行流程" class="headerlink" title="实验执行流程"></a>实验执行流程</h1><p>ucore总init函数中，在调用完idt_init函数后才进一步调用了lab3中才有的新函数vmm_init、ide_init和swap_init。vmm_init是用来检查练习1（给未被映射的地址映射上物理页）是否正确实现。ide_init是完成对用于页换入换出的硬盘（swap硬盘）的初始化工作。swap_init完成页面替换过程的主要功能模块。</p>
<p>对于要实现上述描述的技术时，首先要解决一个问题：<strong>当程序运行中访问内存产生page fault异常时，如何判定这个引起异常的虚拟地址内存访问是越界、写只读页的非法地址访问还是由于数据被临时换出到磁盘上或还没有分配内存的合法地址访问？</strong></p>
<h1 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h1><p>为了解决上述问题，ucore建立了相关的数据结构。page_fault函数不知道哪些是合法的虚拟页，所以ucore通过建立mm_struct和vma_struct数据结构，描述了ucore模拟应用程序运行所需的合法内存空间。当访问内存产生page fault异常时，通过获得的虚拟内存地址来查询是否属于vma_struct中描述的合法地址范围以及该内存是否可读可写等属性，如果地址在合法范围中，则可根据实际情况进行请求调页/页换入换出处理。如果不在则报错。<br>vma_struct和mm_struct数据结构如下：</p>
<h2 id="vm-struct"><a href="#vm-struct" class="headerlink" title="vm_struct"></a>vm_struct</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">//指向一个比vma_struct更高的抽象层次的数据结构mm_struct </span></span><br><span class="line">        <span class="keyword">uintptr_t</span> vm_start;     <span class="comment">//vma的开始地址</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> vm_end;       <span class="comment">//vma的结束地址</span></span><br><span class="line">        <span class="keyword">uint32_t</span> vm_flags;     <span class="comment">// 虚拟内存空间的属性</span></span><br><span class="line">        <span class="keyword">list_entry_t</span> list_link;<span class="comment">//双向链表，按照从小到大的顺序把虚拟内存空间链接起来</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>vm_start和vm_end描述的是一个合理的地址空间范围，确保vm_start &lt; vm_end的关系。<br>vm_flags表示了虚拟内存空间的属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VM_READ 0x00000001   <span class="comment">//只读</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VM_WRITE 0x00000002  <span class="comment">//可读写</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VM_EXEC 0x00000004   <span class="comment">//可执行</span></span></span><br></pre></td></tr></table></figure>
<p>vm_mm是一个指向mm_struct的指针。</p>
<h2 id="mm-struct"><a href="#mm-struct" class="headerlink" title="mm_struct"></a>mm_struct</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span>  </span><br><span class="line">        <span class="keyword">list_entry_t</span> mmap_list;  <span class="comment">//双向链表头，连接了所有属于同一页目录表的虚拟内存空间</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span>  <span class="comment">//指向当前正在使用的虚拟内存空间</span></span><br><span class="line">        <span class="keyword">pde_t</span> *pgdir; <span class="comment">//指向的就是 mm_struct数据结构所维护的页表</span></span><br><span class="line">        <span class="keyword">int</span> map_count; <span class="comment">//记录mmap_list里面链接的vma_struct的个数</span></span><br><span class="line">        <span class="keyword">void</span> *sm_priv; <span class="comment">//指向用来连接记录页访问情况的链表头</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>mmap_cache是指向当前正在使用的虚拟内存空间，由于操作系统的局部性原理，当前正在用到的虚拟内存空间在接下来的操作中可能还会用到。加快了访问速度。<br>pgdir所指向的就是mm_struct所维护的页表，通过访问pgdir可以查到某虚拟地址对应的页表项是否存在以及页表项的属性等。</p>
<p>mm_struct和vma_struct数据结构结合页表示意图：<br><img src="https://img-blog.csdnimg.cn/img_convert/a32add56fdc756e3196101f64a300595.png#pic_center" alt="虚拟地址空间和物理地址空间的示意图"></p>
<h1 id="page-fault异常处理"><a href="#page-fault异常处理" class="headerlink" title="page fault异常处理"></a>page fault异常处理</h1><p>实现虚存管理的关键就是page fault异常处理。在程序执行的过程中由于页面不存在或写到只读页时，使CPU无法访问到相应的物理内存单元，CPU就会产生一次页访问异常，从而需要进行相应的页访问异常的中断服务例程。产生页访问异常的主要原因有：<br>1、目标页帧不存在<br>2、相应的物理页帧不在内存中<br>3、不满足访问权限<br>当出现上面情况之一，那么就会产生page fault（#PF）异常，CPU会把产生异常的线性地址储存在CR2中，并且把页访问异常类型的值（页访问异常错误码，errorCode）保存在中断栈中。</p>
<p>在ucore中处理page fault异常的函数就是do_pgfault函数。它根据从CPU的控制寄存器CR2中获取的页访问异常的物理地址以及根据errorCode的错误类型来查找此地址是否在某个vma的地址范围内以及是否满足正确的读写权限，如果在此范围内并读写权限也正确，便认为这是一次合法访问，但没有建立虚实对应关系。所以需要分配一个空闲的内存页，并修改页表完成虚地址到物理地址的映射，刷新TLB，然后调用IRET中断，返回到产生页访问异常的指令处重新执行此指令。如果该虚地址不在vma范围内，则认为是一次非法访问。</p>
<h1 id="页面置换机制"><a href="#页面置换机制" class="headerlink" title="页面置换机制"></a>页面置换机制</h1><p>要实现页面置换机制还需要解决下面的问题</p>
<h2 id="可以被换出的页"><a href="#可以被换出的页" class="headerlink" title="可以被换出的页"></a>可以被换出的页</h2><p>在操作系统的设计中，有一个基本的原则：并非并非所有的物理页都可以交换出去的，只有映射到用户空间且被用户程序直接访问的页面才能被交换，而被内核直接使用的内核空间的页面不能被换出。<br>主要是因为操作系统是执行的关键代码，需要保证运行的高效性和实时性，如果在操作系统执行中发生了缺页现象，则操作系统不得不等很长时间，这将导致整个系统运行低效。</p>
<h2 id="虚存中的页与硬盘上的扇区之间的映射关系"><a href="#虚存中的页与硬盘上的扇区之间的映射关系" class="headerlink" title="虚存中的页与硬盘上的扇区之间的映射关系"></a>虚存中的页与硬盘上的扇区之间的映射关系</h2><p>如果一个页被置换到了硬盘上面，那操作系统该如何表示呢？在ucore的设计中，充分利用了页表项PTE来表示这种情况：<strong>当一个PTE用来描述一般意义上的物理页时</strong>，应该有PTE_P标记，而当<strong>用来描述一个被置换出去的物理页时</strong>，PTE用来维护该物理页与swap磁盘上扇区的映射关系。</p>
<p>如果一个页（4KB/页）被置换到了硬盘某8个扇区（0.5KB/扇区），该PTE的最低位–present位应该位0，接下来的7位暂时保留用作各种扩展，而包括原来高20位页帧号的高24位数据，恰好可以用来表示此页在硬盘上的起始扇区的位置。如下图所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">swap_entry_t</span></span><br><span class="line">-------------------------</span><br><span class="line">| offset | reserved | <span class="number">0</span> |</span><br><span class="line">-------------------------</span><br><span class="line"><span class="number">24</span> bits    <span class="number">7</span> bits   <span class="number">1</span> <span class="built_in">bit</span></span><br></pre></td></tr></table></figure>

<h2 id="执行换入换出的时机"><a href="#执行换入换出的时机" class="headerlink" title="执行换入换出的时机"></a>执行换入换出的时机</h2><h3 id="换入"><a href="#换入" class="headerlink" title="换入"></a>换入</h3><p>在lab3中，check_mm_struct数据结构表示了目前ucore认为合法的所有虚拟内存空间集合，而mm中的每个vma表示了一段地址连续的合法虚拟空间。当ucore或应用程序访问地址所在页不存在时，就会产生page fault异常，引起调用do_pgfault函数，此函数会判断产生访问异常的地址属于check_mm_struct某个vma表示的合法虚拟地址空间，且保存在硬盘swap文件中，则是执行页换入的时机。</p>
<h3 id="换出"><a href="#换出" class="headerlink" title="换出"></a>换出</h3><p>对于换出有不同的策略：积极换出策略，指操作系统周期性的主动把某些认为不常用的页面换出到硬盘上，从而确保系统中总有一定数量的空闲页存在；消极换出策略，指只是当试图得到空闲页，发现当前没有空闲的物理页可供分配时，这才开始找不常用的页面将它换出。</p>
<p>在ucore中执行的时第二种消极换出策略，在调用alloc_pages函数获取空闲页时，此函数如果发现无法从物理内存页分配器获得空闲页，就会进一步调用swap_out函数换出某页。</p>
<p>本文参考：<a href="https://chyyuu.gitbooks.io/ucore_os_docs" target="_blank" rel="noopener">https://chyyuu.gitbooks.io/ucore_os_docs</a></p>
]]></content>
      <categories>
        <category>ucore·</category>
      </categories>
  </entry>
  <entry>
    <title>Lab2物理内存管理</title>
    <url>/2021/10/06/Lab2%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>在lab2中，bootloader的工作有所增加，主要在两个方面，<strong>第一个是bootloader完成了对物理内存资源的探测工作</strong>，让ucore后续能够在探测出的物理内存情况下进行物理内存管理初始化工作。<strong>第二个是进入kern_init()函数之前，bootloader建立了一个C语言运行环境</strong>（设置堆栈），并且临时建立了一个段映射关系，为之后建立分页机制做一个准备。<br>lab2的主题是物理内存管理，ucore完成的主要工作包括：<br>1、初始化物理内存框架页面pmm_manager<br>2、建立空闲page链表<br>3、检查物理内存页分配算法<br>4、建立临时二级页表<br>5、建立一一映射关系的二级页表<br>6、使能分页机制<br>7、重新设置GDT<br>8、取消临时二级页表<br>9、检查页表建立是否正确<br>接下来分析ucore lab2的具体实现。</p>
<h1 id="以页为单位管理物理内存"><a href="#以页为单位管理物理内存" class="headerlink" title="以页为单位管理物理内存"></a>以页为单位管理物理内存</h1><p>在获取可用物理内存范围之后，系统需要建立相应的数据结构来管理以物理页（4KB）为最小单位的物理内存。Page的数据结构如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;        <span class="comment">//页面引用计数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags; <span class="comment">//描述页面的属性</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;<span class="comment">//连续内存空闲块的个数</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;<span class="comment">//空闲块链表指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_reserved                 0       <span class="comment">//页描述符预留给内核或无法使用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_property                 1       <span class="comment">//页面是有效的</span></span></span><br></pre></td></tr></table></figure>
<p><strong>目前flags用到了两个bit表示页面具有的两种属性</strong>，bit 0表示页面是否被保留，如果被保留的页，bit 0会被设置为1，且不能放到空闲页链表中。bit 1表示页面是否是free的，如果设置为1，表示页面是free的，可以被分配。</p>
<h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><p>property用来记录连续内存空闲块的大小即空闲页的个数，但需要用到property这个成员变量的Page比较特殊，一般是这个空闲块地址最小的一页，即头一页（Head Page）。</p>
<h1 id="Page结构的内存空间"><a href="#Page结构的内存空间" class="headerlink" title="Page结构的内存空间"></a>Page结构的内存空间</h1><p>在有了上述数据结构后，ucore就可以初步管理以页为单位的物理内存空间。而在这之前还需要确定两个问题：<br>1、管理页级物理内存空间所需的Page结构的内存空间从哪里开始，占多大空间？<br>2、空闲内存空间的起始地址在哪里？</p>
<p>要解决这两个问题，首先要根据bootloader给出的内存布局信息找出最大的物理内存地址。<strong>根据最大物理地址maxpa就可以得知物理页的个数</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">npage = maxpa / PGSIZE</span><br></pre></td></tr></table></figure>

<p><strong>有了物理页的数量，就可以得知Page数据结构需要的内存大小</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(struct Page) * npage</span><br></pre></td></tr></table></figure>

<p>由于bootloader加载ucore的结束地址（end指针）以上的空间没有被使用，所以可以把end按页大小为边界取整后作为管理页物理内存空间所需Page结构的内存空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pages = (struct Page *)ROUNDUP((<span class="keyword">void</span> *)<span class="built_in">end</span>, PGSIZE)</span><br></pre></td></tr></table></figure>

<p>由以上可知，从0地址到地址pages + (sizeof(struct Page) * npage)物理内存空间设定已占用的物理内存空间，所以空闲空间的起始地址为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span> freemem = PADDR((<span class="keyword">uintptr_t</span>)pages + <span class="keyword">sizeof</span>(struct Page) * npage)</span><br></pre></td></tr></table></figure>

<p>完成物理内存页管理初始化工作后，ucore的内存布局如下:<br><img src="https://img-blog.csdnimg.cn/img_convert/f200265c680a8ecb56db41c465f35c4b.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="物理内存页的分配算法实现"><a href="#物理内存页的分配算法实现" class="headerlink" title="物理内存页的分配算法实现"></a>物理内存页的分配算法实现</h1><p>物理页内存分配由很多种算法，在lab2练习一中完成的是first-fit的分配算法，first_fit分配算法需要维护一个地址从小到大排列的空闲块的双向链表。具体实现在kern/mm/pmm.c中，具体代码就不贴出了。</p>
<h1 id="实现分页机制"><a href="#实现分页机制" class="headerlink" title="实现分页机制"></a>实现分页机制</h1><h2 id="段页式管理基本概念"><a href="#段页式管理基本概念" class="headerlink" title="段页式管理基本概念"></a>段页式管理基本概念</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/56b4dc43f3548a6750e8c61ddb721ef4.png#pic_center" alt="在这里插入图片描述"><br>如上图所示，x86体系结构将内存地址分为三种：<strong>逻辑地址、线性地址和物理地址</strong>，逻辑地址即使程序中使用的地址，物理地址是实际访问内存的地址。逻辑地址通过段式管理的地址映射可以得到线性地址，线性地址在页式管理的地址映射得到物理地址。<br><strong>但ucore弱化了段式管理，在ucore中段式管理将逻辑地址不加转换的直接映射成线性地址。</strong></p>
<h2 id="系统执行地址映射的三个阶段"><a href="#系统执行地址映射的三个阶段" class="headerlink" title="系统执行地址映射的三个阶段"></a>系统执行地址映射的三个阶段</h2><h3 id="第一个阶段"><a href="#第一个阶段" class="headerlink" title="第一个阶段"></a>第一个阶段</h3><p>开启保护模式，创建启动段表，这是在bootloader阶段完成的任务。即从boot/bootasm.S/start函数到执行ucore kernel的kern_entry函数之前，其虚拟地址、线性地址和物理地址之间的关系如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lab2 stage <span class="number">1</span>: virt addr = linear addr = phy addr</span><br></pre></td></tr></table></figure>
<h3 id="第二个阶段"><a href="#第二个阶段" class="headerlink" title="第二个阶段"></a>第二个阶段</h3><p>创建初始页目录表，开启分页模式。从kern_enrty函数到pmm_init函数执行之前。</p>
<p>编译好的ucore自带了一个设置好的页目录表和页表，将0-4M的线性地址一一映射到物理地址。目前的地址之间的关系如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lab2 stage <span class="number">2</span> before:</span><br><span class="line">    virt addr = linear addr = phy addr # 线性地址在<span class="number">0</span>~<span class="number">4</span>MB之内三者的映射关系</span><br><span class="line">    virt addr = linear addr = phy addr + <span class="number">0xC0000000</span> # 线性地址在<span class="number">0xC0000000</span>~<span class="number">0xC0000000</span>+<span class="number">4</span>MB之内三者的映射关系</span><br></pre></td></tr></table></figure>
<p>此时的内核还在0-4M的低虚拟地址运行，而在之后这个区域是要给用户程序使用的，所以这一阶段的目的就是更新映射关系的同时将内核从低虚拟地址迁移到高虚拟地址。</p>
<h3 id="第三个阶段"><a href="#第三个阶段" class="headerlink" title="第三个阶段"></a>第三个阶段</h3><p>完善段表和页表，从pmm_init函数调用开始。<br>pmm_init函数将页目录表项扩充完成，然后更新了段映射机制。于是形成了地址之间的映射关系：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lab2 stage <span class="number">3</span>: virt addr = linear addr = phy addr + <span class="number">0xC0000000</span></span><br></pre></td></tr></table></figure>

<h2 id="建立虚拟页和物理页帧的地址映射关系"><a href="#建立虚拟页和物理页帧的地址映射关系" class="headerlink" title="建立虚拟页和物理页帧的地址映射关系"></a>建立虚拟页和物理页帧的地址映射关系</h2><p>完成前一节前两个阶段的地址映射变化后，把物理地址一一映射到页目录项和页表项的内容，大致流程如下:<br>1、页目录表指针存储在boot_pgdir变量中<br>2、填充好0-4MB的首个页表<br>3、调用boot_map_segment函数建立映射关系</p>
<p>对于第三点具体来讲，假设一个32bit线性地址la有一个对应的32bit物理地址pa，如果la的高10为索引值的页目录项中的存在位（PTE_P）为0，表示缺少对应的页表空间，则通过alloc_page获得一个空闲物理页给页表，具体填写页目录项如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">页目录项内容 = (页表起始物理地址 &amp; ~<span class="number">0x0FFF</span>) | PTE_U | PTE_W | PTE_P</span><br></pre></td></tr></table></figure>

<p>填充页表项如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">页表项内容 = (pa &amp; ~<span class="number">0x0FFF</span>) | PTE_P | PTE_W</span><br></pre></td></tr></table></figure>
<p>建立好一一映射的二级页表结构后，分页机制初始化完毕，新的段页式映射已经建立好了。</p>
<p>本文参考：<a href="https://chyyuu.gitbooks.io/ucore_os_docs" target="_blank" rel="noopener">https://chyyuu.gitbooks.io/ucore_os_docs</a></p>
]]></content>
      <categories>
        <category>ucore</category>
      </categories>
  </entry>
  <entry>
    <title>Lab4内核线程管理</title>
    <url>/2021/10/10/Lab4%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>在lab2和lab3中ucore完成了物理和虚拟内存管理，这给创建内核线打下了提供内存管理的基础。内核线程是一种特殊的进程，内核线程与用户进程的区别如下：<br>1、内核线程只运行在内核态<br>2、用户进程会在用户态和内核态交替运行<br>3、所有内核线程共用ucore内核内存空间，不需要为每个内核线程维护单独的内存空间<br>4、用户进程需要维护各自的内存空间</p>
<h1 id="实验执行流程概述"><a href="#实验执行流程概述" class="headerlink" title="实验执行流程概述"></a>实验执行流程概述</h1><p>在lab3时，整个控制流还是一条线串行执行，而lab4在此基础上进行CPU的虚拟化，既让ucore实现分时共享CPU，实现多条控制流能够并发执行。为了实现内核线程，首先需要设计管理线程的数据结构，也就是进程控制块（在这里也可以叫做线程控制块）。如果要让内核线程运行，首先需要创建进程控制块，还需要把这些进程控制块通过链表连在一起，便于随时进行插入、删除等操作。<br>在lab4中的总控init函数中，当完成虚拟内存的初始化工作后，就调用了proc_init函数，这个函数完成了对idleproc内核线程和initproc内核线程的创建或复制工作。idleproc内核线程的工作就是不停的查询，寻找是否有其他内核线程可以执行，如果有就让调度器选择那个内核线程进行执行。<strong>所以idleproc内核线程是当ucore没有内核线程可执行的情况下才会被调用。</strong> 接着就是调用kernel_thread函数来创建initproc内核线程，initproc内核线程的工作就是显示“Hello World”，表示自己存在且能正常工作了。<br>接下来主要介绍PCB以及ucore创建并执行内核线程idleproc和内核线程initproc的两种不同方式。</p>
<h1 id="关键数据结构–进程控制块（PCB）"><a href="#关键数据结构–进程控制块（PCB）" class="headerlink" title="关键数据结构–进程控制块（PCB）"></a>关键数据结构–进程控制块（PCB）</h1><p>在lab4中，进程管理用struct proc_struct表示，在kern/process/proc.h中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROC_NAME_LEN               15</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> proc_state state; <span class="comment">// 进程状态</span></span><br><span class="line">    <span class="keyword">int</span> pid; <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="keyword">int</span> runs; <span class="comment">// 运行时间</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> kstack; <span class="comment">// 内核栈</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span> need_resched; <span class="comment">// 是否需要调度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span> <span class="comment">// 父进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">// 进程的虚拟内存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span> <span class="comment">// 进程上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span> <span class="comment">// 当前终端帧指</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cr3; <span class="comment">// 当前页表地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags; <span class="comment">// 进程属性</span></span><br><span class="line">    <span class="keyword">char</span> name[PROC_NAME_LEN + <span class="number">1</span>]; <span class="comment">// 进程名</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link; <span class="comment">//进程链表</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link; <span class="comment">//</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来对几个重要的成员变量进行解释：</p>
<h2 id="mm"><a href="#mm" class="headerlink" title="mm"></a>mm</h2><p>内存管理的信息，包括内存映射列表，页表指针等。在lab5中涉及到了用户进程，才需要考虑用户内存空间的swap page，mm才会发挥作用，所以在lab4中mm对于内核线程并没有什么作用。但是mm里面有个很重要的pgdir，记录的是该进程使用的一级页表（页目录）的物理地址，所以用cr3代替。</p>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>进程所处的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> proc_state &#123;              <span class="comment">//进程状态</span></span><br><span class="line">    PROC_UNINIT = <span class="number">0</span>,           <span class="comment">//未初始状态 </span></span><br><span class="line">    PROC_SLEEPING,             <span class="comment">//睡眠（阻塞）状态 </span></span><br><span class="line">    PROC_RUNNABLE,             <span class="comment">//运行与就绪态 </span></span><br><span class="line">    PROC_ZOMBIE,               <span class="comment">//僵死状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h2><p>用户进程的父进程。在所有的进程中，只有内核创建的idleproc没有父进程。内核根据这个父子关系建立一个树形结构，用于维护一些特殊的操作。</p>
<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>进程的上下文，用于进程的切换。在ucore中所有的进程在内核中也是相对独立的。使用context保存寄存器的目的就在于内核态中能够进行上下文的切换。</p>
<h2 id="tf"><a href="#tf" class="headerlink" title="tf"></a>tf</h2><p>中断帧指针，总是指向内核的某个位置。当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。当内核需要跳回用户控件时，需要调整中断帧以恢复让进程继续执行的各寄存器值。除此之外，在ucore中内核允许嵌套中断。因此为了保证嵌套中断发生时tf总指向当前的trapframe，ucore在内核栈上维护了tf的链。</p>
<h2 id="cr3"><a href="#cr3" class="headerlink" title="cr3"></a>cr3</h2><p>保存页表的物理地址。目的就是进程切换时方便直接使用lcr3实现页表切换。当某个进程是一个普通用户态进程时，PCB中的cr3就是mm中pgdir，而当它是内核线程时候，cr3就等于boot_cr3，而boot_cr3指向了ucore启动时建立好的内核虚拟空间的页目录表首地址。</p>
<h2 id="kstack"><a href="#kstack" class="headerlink" title="kstack"></a>kstack</h2><p>每个线程都有一个内核栈，并且位于内核地址空间的不同位置。对于内核线程，该栈就是运行时程序使用的栈，而对于普通进程，该栈是发生特权级改变的时候保存被打断的硬件信息所用的栈。</p>
<h1 id="创建并执行内核线程"><a href="#创建并执行内核线程" class="headerlink" title="创建并执行内核线程"></a>创建并执行内核线程</h1><p>在建立PCB（proc.c中的alloc_proc函数）后，就可以通过PCB创建具体的线程/进程了。首先lab4中是对内核线程的创建，通常只是内核中的一小段代码，没有自己的专属空间。这是因为ucore启动后，已经对整个内核内存空间进行管理，通过设置页表建立了内核虚拟空间。所以内核线程就不需要再建立自己的页表，只需要共享这个内核虚拟空间就可以访问整个物理内存了。</p>
<h2 id="创建第0个线程"><a href="#创建第0个线程" class="headerlink" title="创建第0个线程"></a>创建第0个线程</h2><p>在init.c::kern_init函数中调用了proc.c::proc_init函数。proc_init函数启动了创建内核线程的步骤。<br>首先调用alloc_proc函数来获取proc_struct结构的一块内存，作为第0个PCB。并把proc进程初步的初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">proc-&gt;state = PROC_UNINIT;   <span class="comment">//设置进程为“初始”态</span></span><br><span class="line">proc-&gt;pid = <span class="number">-1</span>;             <span class="comment">//设置进程pid的未初始化值</span></span><br><span class="line">proc-&gt;cr3 = boot_cr3;       <span class="comment">//使用内核页目录表的基址</span></span><br></pre></td></tr></table></figure>
<p>第一条语句设置了进程状态为初始态。第二条语句设置进程的pid为-1,表示进程ID还没有设置。第三条语句表示该线程在内核中运行。</p>
<p>接下来proc_init函数对idleproc内核线程进行进一步初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">idleproc-&gt;pid = <span class="number">0</span>;</span><br><span class="line">idleproc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">idleproc-&gt;kstack = (<span class="keyword">uintptr_t</span>)bootstack;</span><br><span class="line">idleproc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">set_proc_name(idleproc, <span class="string">"idle"</span>);</span><br></pre></td></tr></table></figure>

<p>第一条语句表示idleproc的合法ID为0，进一步说明idleproc是第0个线程。第二条语句改变了idleproc的状态，从初始态转变到了就绪态。第三条语句设置了idleproc所使用的内核栈的起始地址。第四条语句表示当need_resched=1时，就需要调用schedule函数要求调度器切换到其他进程执行。</p>
<h2 id="创建第1个线程initproc"><a href="#创建第1个线程initproc" class="headerlink" title="创建第1个线程initproc"></a>创建第1个线程initproc</h2><p>第0个内核线程主要工作是完成内核中各个子系统的初始化，然后就调用kernel_thread创建了第一个内核线程。在lab4中，这个内核线程主要是输出一些字符串然后就返回了。接下来我们来分析以下创建内核线程的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kernel_thread(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">uint32_t</span> clone_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    tf.tf_cs = KERNEL_CS;</span><br><span class="line">    tf.tf_ds = tf_struct.tf_es = tf_struct.tf_ss = KERNEL_DS;</span><br><span class="line">    tf.tf_regs.reg_ebx = (<span class="keyword">uint32_t</span>)fn;</span><br><span class="line">    tf.tf_regs.reg_edx = (<span class="keyword">uint32_t</span>)arg;</span><br><span class="line">    tf.tf_eip = (<span class="keyword">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kernel_thread函数采用了局部变量tf来保存内核线程的临时中断帧，并把中断帧指针传给do_fork函数，而do_fork函数会调用copy_thread函数在新的进程内核栈上专门给进程的中断帧分配一块空间。</p>
<p>do_fork函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC; <span class="comment">//尝试为进程分配内存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span> <span class="comment">//定义新进程</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123; <span class="comment">//分配进程数大于4096,返回</span></span><br><span class="line">        <span class="keyword">goto</span> fork_out;  <span class="comment">//返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;  <span class="comment">//因内存不足而分配失败</span></span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>) &#123; <span class="comment">//分配内存失败</span></span><br><span class="line">        <span class="keyword">goto</span> fork_out; <span class="comment">//返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent = current; <span class="comment">//设置父进程名字</span></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) &#123;<span class="comment">//分配内核栈</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc; <span class="comment">//返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123; <span class="comment">//复制父进程内存信息</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack; <span class="comment">//返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf); <span class="comment">//复制中断帧和上下文信息</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag; </span><br><span class="line">    local_intr_save(intr_flag);  <span class="comment">//屏蔽中断，intr_flag置为1</span></span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid(); <span class="comment">//获取当前进程PID</span></span><br><span class="line">        hash_proc(proc);  <span class="comment">//建立hash映射</span></span><br><span class="line">        list_add(&amp;proc_list,&amp;(proc-&gt;list_link));<span class="comment">//加入进程链表</span></span><br><span class="line">        nr_process ++;  <span class="comment">//进程数加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">//恢复中断</span></span><br><span class="line">    wakeup_proc(proc); <span class="comment">//唤醒新进程</span></span><br><span class="line">    ret = proc-&gt;pid; <span class="comment">//返回当前进程的PID</span></span><br><span class="line">fork_out:  <span class="comment">//已分配进程数大于4096</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_fork_cleanup_kstack: <span class="comment">//分配内核栈失败</span></span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc: </span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>do_fork主要做了以下7件事情：<br>1、分配并初始化PCB（alloc_proc函数）<br>2、分配并初始化内核栈（setup_stack函数）<br>3、根据clone_flag标志复制或共享进程内存管理结构（copy_mm函数）<br>4、设置进程在内核运行和调度所需的中断帧和执行上下文（copy_thread函数）<br>5、把设置好的PCB放入hash_list和proc_list两个全局链表中<br>6、将进程设置为就绪态<br>7、返回进程的pid</p>
<h2 id="调度并执行内核线程initproc"><a href="#调度并执行内核线程initproc" class="headerlink" title="调度并执行内核线程initproc"></a>调度并执行内核线程initproc</h2><p>在ucore执行完proc_init函数后，就创建好了idleproc和initproc，目前的执行现场就是idleproc，等到执行到init函数的最后一个函数cpu_idle之前，ucore的所有初始化工作就结束了，idleproc调用cpu_idle函数让出CPU给其他线程执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">cpu_idle(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;need_resched) &#123;</span><br><span class="line">            schedule();</span><br><span class="line">            ……</span><br></pre></td></tr></table></figure>

<p>在ucore lab4中只实现了一个最简单的FIFO调度器，核心就是schedule函数，执行逻辑如下：<br>1、设置当前的内核线程current-&gt;need_resched为0<br>2、在proc_list队列中查找下一个处于就绪态的PCB<br>3、找到以后就调用proc_run函数，保存当前进程的上下文，恢复新进程的执行现场。<br>至此新进程就开始执行了</p>
<p>至此lab4的工作大致描述完毕。</p>
<p>本文参考：<br><a href="https://chyyuu.gitbooks.io/ucore_os_docs" target="_blank" rel="noopener">https://chyyuu.gitbooks.io/ucore_os_docs</a></p>
<p><a href="https://blog.csdn.net/tangyuanzon" target="_blank" rel="noopener">https://blog.csdn.net/tangyuanzon</a></p>
]]></content>
      <categories>
        <category>ucore</category>
      </categories>
  </entry>
  <entry>
    <title>muduo分析之EventLoop、Channel、Poller</title>
    <url>/2021/11/02/muduo%E5%88%86%E6%9E%90%E4%B9%8BEventLoop%E3%80%81Channel%E3%80%81Poller/</url>
    <content><![CDATA[<h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>首先在muduo中强调的就是<strong>one loop per thread</strong>，也就是每个线程只能由一个EventLoop对象，所以EventLoop的构造函数会检查当前线程是否创建了其他的EventLoop。<br>实现方式是通过EventLoop的构造函数会记住本对象所属的线程id。</p>
<p>下面是EventLoop的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">EventLoop::EventLoop():looping_(<span class="literal">false</span>),<span class="comment">//事件循环是否开始</span></span><br><span class="line">threadId_(CurrentThread::tid()),<span class="comment">//获取当前线程id</span></span><br><span class="line">quit_(<span class="literal">false</span>),</span><br><span class="line">poller_(<span class="keyword">new</span> Poller(<span class="keyword">this</span>)),<span class="comment">//创建一个poll</span></span><br><span class="line">timerQueue_(<span class="keyword">new</span> TimerQueue(<span class="keyword">this</span>)),</span><br><span class="line">wakeupFd_(createEventfd()),<span class="comment">//创建了eventfd作为线程间等待、唤醒</span></span><br><span class="line">wakeupChannel_(<span class="keyword">new</span> Channel(<span class="keyword">this</span>,wakeupFd_))<span class="comment">//创建wakeupChannel通道</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(t_loopInThisThread)&#123;<span class="comment">//判断是否已有EventLoop</span></span><br><span class="line">        perror(<span class="string">"Another EventLoop"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t_loopInThisThread=<span class="keyword">this</span>;</span><br><span class="line">    wakeupChannel_-&gt;setReadCallback(boost::bind(&amp;EventLoop::handleRead,<span class="keyword">this</span>));<span class="comment">//设定wakeupChannel的回调函数</span></span><br><span class="line">    wakeupChannel_-&gt;enableReading();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理活跃事件"><a href="#处理活跃事件" class="headerlink" title="处理活跃事件"></a>处理活跃事件</h2><p>处理网络事件时，一般通过select/poll/epoll阻塞等待，根据返回的事件调用相应的处理函数，下面函数就是主要处理这件事情的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(!looping_);</span><br><span class="line">    assertInLoopThread();<span class="comment">//断言处于创建线程中</span></span><br><span class="line">    looping_=<span class="literal">true</span>;</span><br><span class="line">    quit_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!quit_)</span><br><span class="line">    &#123;</span><br><span class="line">        activeChannels_.clear();</span><br><span class="line">        pollReturnTime_=poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_);<span class="comment">//调用poll返回活跃的事件，也有可能被唤醒</span></span><br><span class="line">        <span class="keyword">for</span>(ChannelList::iterator it = activeChannels_.begin();it != activeChannels_.end();it++)&#123;</span><br><span class="line">            (*it)-&gt;handleEvent(pollReturnTime_);<span class="comment">//遍历通道来唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">        doPendingFunctors();<span class="comment">//处理用户回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个线程其实就是一个IO事件线程，阻塞等待活跃事件，<strong>活跃的描述符通过activeChannels_带回来</strong>，然后依次进行处理。这个在后面进行介绍。</p>
<h2 id="执行用户回调函数"><a href="#执行用户回调函数" class="headerlink" title="执行用户回调函数"></a>执行用户回调函数</h2><p>在上面的loop()函数中，执行完所有的event后，<strong>有一个doPendingFunctors()</strong>，用来执行用户指定的回调函数。其实就是让IO线程来执行额外的计算任务的，如果没有发生事件那么loop()大概率会阻塞在poll上，所以可以让IO线程空闲时进行处理。</p>
<p>由于在muduo中使用的时one loop per thread，所以就需要用到runInloop()。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(<span class="keyword">const</span> Functor&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isInLoopThread())&#123;</span><br><span class="line">        cb();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        queueInLoop(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(<span class="keyword">const</span> Functor&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.push_back(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!isInLoopThread() || callingPendingFunctors_)&#123;</span><br><span class="line">        wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是我认为非常精妙的一个地方，在runInloop()中，<strong>如果是IO线程主动调用该函数想要执行，那么就直接调用该函数，如果是其他线程给IO线程的任务，那么其他线程需要把回调函数加入IO线程的队列等待执行。这样不需要加锁就可以保证安全的在线程间进行任务调配。</strong><br>接下来queueInloop()，因为pendingFunctors_是暴露给其他线程的，所以需要锁住，然后当加入到回调队列后，当然希望IO线程尽快执行任务，所以立即唤醒IO线程。而这个唤醒是通过eventfd来实现的。</p>
<h2 id="eventfd"><a href="#eventfd" class="headerlink" title="eventfd"></a>eventfd</h2><p>poll的唤醒操作是通过eventfd来实现的，实现的方式就是在唤醒的过程中调用write()函数，唤醒之后调用之前注册好的回调函数handleRead()。也就是EventLoop构造函数中的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设定wakeupChannel的回调函数</span></span><br><span class="line">wakeupChannel_-&gt;setReadCallback(boost::bind(&amp;EventLoop::handleRead,<span class="keyword">this</span>));</span><br><span class="line">wakeupChannel_-&gt;enableReading();</span><br></pre></td></tr></table></figure>
<p>调用write()来唤醒：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> one =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span>  n = ::write(wakeupFd_,&amp;one,<span class="keyword">sizeof</span>(one));</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="keyword">sizeof</span>(one))&#123;</span><br><span class="line">        perror(<span class="string">"EventLoop::wakeup() writes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p><strong>Channel是muduo的Reactor模式的关键结构，也就是负责对描述符及事件的封装以及分发。</strong></p>
<p>每个Channel对象只属于一个EventLoop，因此每个Channel对象都只属于某一个IO线程。</p>
<p>每个Channel对象只负责一个文件描述符的事件分发，但并不拥有这个fd也就是不负责fd的创建以及关闭。</p>
<p>Channel的函数成员都只能在IO线程调用，所以可以不用加锁。</p>
<h2 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h2><p>首先我们来看Channel的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Channel::Channel(EventLoop* loop,<span class="keyword">int</span> fdArg):</span><br><span class="line">loop_(loop),<span class="comment">//保存EventLoop的指针</span></span><br><span class="line">fd_(fdArg),<span class="comment">//描述符</span></span><br><span class="line">events_(<span class="number">0</span>),<span class="comment">//用户关心的事件</span></span><br><span class="line">revents_(<span class="number">0</span>),<span class="comment">//实际发生的事件</span></span><br><span class="line">index_(<span class="number">-1</span>),<span class="comment">//记录当前fd在pollfd的位置</span></span><br><span class="line">eventHanding_(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数设置了该Channel所属的EventLoop和所关心的fd。</p>
<h2 id="handleEvent"><a href="#handleEvent" class="headerlink" title="handleEvent"></a>handleEvent</h2><p>Channel::handleEvent()是Channel的核心部分，由EventLoop::loop()调用，是根据revents_的值分别调用不同的回调函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::handleEvent</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eventHanding_=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(revents_ &amp; POLLNVAL)&#123;</span><br><span class="line">        perror(<span class="string">"Channel::handle_event() POLLNVAL"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((revents_&amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(closeCallback_) closeCallback_();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(revents_ &amp; (POLLERR | POLLNVAL))&#123;</span><br><span class="line">        <span class="keyword">if</span>(errCallback_) errCallback_();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))&#123;</span><br><span class="line">        <span class="keyword">if</span>(readCallback_) readCallback_(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(revents_ &amp; POLLOUT)&#123;</span><br><span class="line">        <span class="keyword">if</span>(writeCallback_) writeCallback_();</span><br><span class="line">    &#125;</span><br><span class="line">    eventHanding_=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>EventLoop和Channel配合协调工作的一个函数就是update()，它将二者联系起来。所以我们可以从EventLoop中的wakeupfd来分析。在EventLoop的构造函数中有这么一行代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wakeupChannel_-&gt;enableReading();</span><br></pre></td></tr></table></figure>
<p>简单来说这行代码干了两件事情，<strong>一件事设置关心的事件为POLL_IN，事件可读。<br>第二件事是将fd添加到Pollfd数组中。</strong><br>第二件事以此调用Channel::update—&gt;EventLooop::updateChannel—&gt;Poller::updateChannel。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Channel::<span class="keyword">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123; events_ |= kReadEvent; update(); &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;updateChannel(<span class="keyword">this</span>);<span class="comment">//将指针传到了EventLoop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    poller_-&gt;updateChannel(channel);<span class="comment">//将Channel指针传给Poller</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Poller::updateChannel()函数在下一节介绍。</p>
<h1 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h1><p>接下来我们来看Poller，Poller class是对IO multiplexing的封装。同样也是<strong>Reactor的关键部分，负责获取活跃的事件。</strong></p>
<p>Poller是EventLoop的间接成员，只供owner EventLoop在IO线程内调用，因此无需加锁。生命周期与EventLoop相等。</p>
<p>Poller并不拥有Channel，Channel在析构之前必须自己unregister，避免空悬指针。</p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h2><p>Poller::poll()是Poller的核心功能，它调用::poll()获得当前活动的IO事件，然后填充调用方传入的activeChannels，并返回::poll()的return时刻。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Timestamp <span class="title">Poller::poll</span><span class="params">(<span class="keyword">int</span> timeoutms, ChannelList* activeChannels)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numEvents = ::poll(&amp;*pollfds_.begin(),pollfds_.size(),timeoutms);<span class="comment">//poll调用</span></span><br><span class="line">    <span class="function">Timestamp <span class="title">now</span><span class="params">(Timestamp::now())</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(numEvents&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        fillActiveChannels(numEvents,activeChannels);<span class="comment">//填充活跃的事件Channel</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(numEvents ==<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(numEvents&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"Poller::poll()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;<span class="comment">//返回poll的return时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="fillActiveChannels"><a href="#fillActiveChannels" class="headerlink" title="fillActiveChannels"></a>fillActiveChannels</h2><p>当有活跃事件返回时，调用fillActiveChannels()遍历pollfds_，找出有活动事件的fd，把它对应的Channel填入activeChannels。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poller::fillActiveChannels</span><span class="params">(<span class="keyword">int</span> numEvents, ChannelList* activeChannels)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(PollFdList::const_iterator pfd = pollfds_.begin();pfd != pollfds_.end() &amp;&amp; numEvents &gt; <span class="number">0</span>;pfd++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pfd-&gt;revents &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            --numEvents;</span><br><span class="line">            ChannelMap::const_iterator ch = channels_.find(pfd-&gt;fd);</span><br><span class="line">            assert(ch != channels_.end());</span><br><span class="line">            Channel* channel = ch-&gt;second;</span><br><span class="line">            assert(channel-&gt;fd() == pfd-&gt;fd);</span><br><span class="line">            channel-&gt;set_revents(pfd-&gt;revents);</span><br><span class="line">            activeChannels-&gt;push_back(channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了提前结束循环，每找到一个活跃的fd就将numEvents减一，这样当numEvents为0的时候就表示活动的fd已经找完了。</p>
<h2 id="updateChannel"><a href="#updateChannel" class="headerlink" title="updateChannel"></a>updateChannel</h2><p>接下来我们来分析上一节提到的Poller::updateChannel()，在得到了Channel指针以后，<strong>负责维护和更新pollfds_数组</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poller::updateChannel</span><span class="params">(Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span>(channel-&gt;index()&lt;<span class="number">0</span>)&#123;<span class="comment">//new one</span></span><br><span class="line">        assert(channels_.find(channel-&gt;fd()) == channels_.end());</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd</span>;</span><span class="comment">//pollfd结构体</span></span><br><span class="line">        pfd.fd = channel-&gt;fd();</span><br><span class="line">        pfd.events = <span class="keyword">static_cast</span>&lt;short&gt;(channel-&gt;events());</span><br><span class="line">        pfd.revents =<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pollfds_是pollfd类型的vector，充当poll的第一个参数</span></span><br><span class="line">        pollfds_.push_back(pfd);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pollfds_.size())<span class="number">-1</span>;<span class="comment">//重新计算索引，方便下次快速定位</span></span><br><span class="line">        channel-&gt;set_index(index);</span><br><span class="line">        channels_[pfd.fd] = channel;<span class="comment">//channels_是fd和channel的一个map</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        assert(channels_.find(channel-&gt;fd()) != channels_.end());</span><br><span class="line">        assert(channels_[channel-&gt;fd()] == channel);</span><br><span class="line">        <span class="keyword">int</span> index = channel-&gt;index();</span><br><span class="line">        assert(index&gt;=<span class="number">0</span>&amp;&amp;index &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pollfds_.size()));<span class="comment">//////</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&amp; <span class="title">pfd</span> = <span class="title">pollfds_</span>[<span class="title">index</span>];</span></span><br><span class="line">        assert(pfd.fd == channel-&gt;fd() || pfd.fd == -channel-&gt;fd()<span class="number">-1</span>);</span><br><span class="line">        pfd.events = <span class="keyword">static_cast</span>&lt;short&gt;(channel-&gt;events());</span><br><span class="line">        pfd.revents = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(channel-&gt;isNoneEvent())&#123;</span><br><span class="line">            pfd.fd = -channel-&gt;fd()<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>muduo</category>
      </categories>
  </entry>
</search>
