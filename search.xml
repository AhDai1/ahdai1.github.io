<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SIGCHILD信号</title>
    <url>/2020/05/19/SIGCHILD%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="SIGCHILD的产生条件"><a href="#SIGCHILD的产生条件" class="headerlink" title="SIGCHILD的产生条件"></a>SIGCHILD的产生条件</h1><p>1、子进程终止时<br>2、子进程接收到SIGSTOP信号停止时<br>3、子进程处在停止态，接受到SIGCONT后唤醒时</p>
<h1 id="子进程结束status处理方式"><a href="#子进程结束status处理方式" class="headerlink" title="子进程结束status处理方式"></a>子进程结束status处理方式</h1><p>函数原型：pid_t waitpid(pid_t pid, int <em>status, int options)<br>*</em>options：**</p>
<p>WNOHANG：没有子进程结束，立即返回</p>
<p>WUNTRACED：如果子进程由于被停止产生的SIGCHLD，waitpid则立即返回</p>
<p>WCONTINUED：如果子进程由于被SIGCONT唤醒而产生的SIGCHLD，waitpid则立即返回</p>
<p><strong>status：</strong><br>    WIFEXITED(status):子进程正常exit终止，返回真<br>    WEXITSTATUS(status):返回子进程正常退出值<br>    WIFSIGNALED(status):子进程被信号终止，返回真<br>    WTERMSIG(status):返回终止子进程的信号值<br>    WIFSTOPPED(status):子进程被停止，返回真<br>    WSTOPSIG(status):返回停止子进程的信号值<br>    WIFCONTINUED(status):子进程接收到SIGCONT信号继续执行</p>
<h1 id="借助SIGCHILD信号回收子进程"><a href="#借助SIGCHILD信号回收子进程" class="headerlink" title="借助SIGCHILD信号回收子进程"></a>借助SIGCHILD信号回收子进程</h1><p>解释:子进程结束运行，其父进程会收到SIGCHLD信号。该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="comment">//如果用if 在linux内核中，收到多个信号，只会记录一个信号</span></span><br><span class="line">	<span class="comment">//用if的话只会回收其中的某些子进程</span></span><br><span class="line">	<span class="keyword">while</span>((pid = waitpid(<span class="number">0</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"child %d exit %d\n"</span>,pid, WEXITSTATUS(status));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"child %d cancel signal %d\n"</span>,pid, WTERMSIG(status));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">//阻塞SIGCHLD</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">			sys_err(<span class="string">"fork "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(n--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"child ID %d\n"</span>,getpid());</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span> )<span class="comment">//父进程捕捉SIGCHILD信号</span></span><br><span class="line">	&#123;</span><br><span class="line">		struct sigaction act;</span><br><span class="line">		act.sa_handler = do_sig_child;</span><br><span class="line">		sigemptyset(&amp;act.sa_mask);</span><br><span class="line">		act.sa_flags = <span class="number">0</span>;</span><br><span class="line">		sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"parent ID %d\n"</span>, getpid());</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多态例子与C语言利用函数指针实现多态</title>
    <url>/2020/05/14/C++%E5%A4%9A%E6%80%81%E4%BE%8B%E5%AD%90%E4%B8%8EC%E8%AF%AD%E8%A8%80%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>本程序解释：诸葛亮交给赵云三个锦囊，三种情况下分别打开不同的锦囊。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TIP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">open_tip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	TIP(<span class="built_in">string</span> from, <span class="built_in">string</span> to)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;from = from;</span><br><span class="line">		<span class="keyword">this</span>-&gt;to = to;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">get_from</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;from;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">get_to</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;to;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> from;</span><br><span class="line">	<span class="built_in">string</span> to;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tip1</span>:</span><span class="keyword">public</span> TIP</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tip1(<span class="built_in">string</span> from, <span class="built_in">string</span> to) :TIP(from, to)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">open_tip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"打开了锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"此锦囊由"</span> &lt;&lt; get_from() &lt;&lt; <span class="string">"写给"</span> &lt;&lt; get_to() &lt;&lt; <span class="string">"的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内容是:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"一到东吴就拜会乔国老"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tip2</span> :</span><span class="keyword">public</span> TIP</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tip2(<span class="built_in">string</span> from, <span class="built_in">string</span> to) :TIP(from, to)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">open_tip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"打开了锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"此锦囊由"</span> &lt;&lt; get_from() &lt;&lt; <span class="string">"写给"</span> &lt;&lt; get_to() &lt;&lt; <span class="string">"的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内容是:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"如果主公乐不思蜀，就谎称曹贼来袭"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tip3</span> :</span><span class="keyword">public</span> TIP</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tip3(<span class="built_in">string</span> from, <span class="built_in">string</span> to) :TIP(from, to)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">open_tip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"打开了锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"此锦囊由"</span> &lt;&lt; get_from() &lt;&lt; <span class="string">"写给"</span> &lt;&lt; get_to() &lt;&lt; <span class="string">"的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内容是:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"如果被孙权追杀，向孙尚香求救"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_tips</span><span class="params">(TIP *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tp-&gt;open_tip();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tip1 *t1 = <span class="keyword">new</span> tip1(<span class="string">"孔明"</span>, <span class="string">"赵云"</span>);</span><br><span class="line">	tip2 *t2 = <span class="keyword">new</span> tip2(<span class="string">"孔明"</span>, <span class="string">"赵云"</span>);</span><br><span class="line">	tip3 *t3 = <span class="keyword">new</span> tip3(<span class="string">"孔明"</span>, <span class="string">"赵云"</span>);</span><br><span class="line">	open_tips(t1);</span><br><span class="line">	open_tips(t2);</span><br><span class="line">	open_tips(t3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//抽象层</span></span><br><span class="line"><span class="comment">//定义一个拆开锦囊方法的类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(TIPS)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//定义锦囊类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tip</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> from[<span class="number">64</span>];<span class="comment">//谁写的</span></span><br><span class="line">	<span class="keyword">char</span> to[<span class="number">64</span>];<span class="comment">//写给谁的</span></span><br><span class="line">	TIPS *tp;<span class="comment">//相当于抽象类的纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//需要一个打开锦囊的架构函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_tip</span><span class="params">(struct tip *tip_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"打开了锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"此锦囊由"</span> &lt;&lt; tip_p-&gt;from &lt;&lt; <span class="string">"写给"</span> &lt;&lt; tip_p-&gt;to &lt;&lt; <span class="string">"的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"内容是："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	tip_p-&gt;tp();<span class="comment">//发生多态现象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供创建锦囊的方法</span></span><br><span class="line"><span class="function">struct tip* <span class="title">Create_tip</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, TIPS *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tip</span> *<span class="title">temp</span> = (<span class="title">struct</span> <span class="title">tip</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">tip</span>));</span></span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(temp-&gt;from, from);</span><br><span class="line">	<span class="built_in">strcpy</span>(temp-&gt;to, to);</span><br><span class="line">	<span class="comment">//给一个回调函数赋值，一般称为注册回调函数</span></span><br><span class="line">	temp-&gt;tp = tp;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供一个销毁锦囊的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(struct tip *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tp != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(tp);</span><br><span class="line">		tp = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现层</span></span><br><span class="line"><span class="comment">//诸葛亮写了三个锦囊</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tip1_func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"一到东吴就拜会乔国老"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tip2_func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"如果主公乐不思蜀，就谎称曹贼来袭"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tip3_func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"如果被孙权追杀，向孙尚香求救"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//业务层</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建出三个锦囊</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tip</span> *<span class="title">tip1</span> = <span class="title">Create_tip</span>("孔明", "赵云", <span class="title">tip1_func</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tip</span> *<span class="title">tip2</span> = <span class="title">Create_tip</span>("孔明", "赵云", <span class="title">tip2_func</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tip</span> *<span class="title">tip3</span> = <span class="title">Create_tip</span>("孔明", "赵云", <span class="title">tip3_func</span>);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//由赵云进行拆锦囊</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"刚刚来到东吴，赵云打开第一个锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	open_tip(tip1);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"刘备乐不思蜀，赵云打开第二个锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	open_tip(tip2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"孙权大军追杀"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	open_tip(tip3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	destroy(tip1);</span><br><span class="line">	destroy(tip2);</span><br><span class="line">	destroy(tip3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>mmap</title>
    <url>/2020/05/16/mmap/</url>
    <content><![CDATA[<h1 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h1><p>mmap()函数将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。</p>
<p>mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read(),write()等操作。</p>
<p><strong>函数原型：</strong><br><strong>void * mmap(void * start, size_t length, int port, int flags, int fd, off_t offsize)**</strong></p>
<p>参数的意义：<br><strong>start:</strong> 指向欲映射的内存初始地址，通常设为NULL，代表让系统自动选定地址，映射成功后返回该地址。</p>
<p><strong>length:</strong> 代表将文件中的多大的部分映射到内存。</p>
<p><strong>port:</strong> 映射区域的保护方式<br>PROT_EXEC：映射区域可被执行<br>PROT_READ：映射区域可被读取<br>PROT_WRITE：映射区域可被写入<br>PROT_NONE：映射区域不能存取</p>
<p><strong>flags:</strong> 影响映射区域的各种属性。</p>
<p>在调用mmap()时必须指定MAP_SHARED或MAP_PRIVATE<br>MAP_FIXED：如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。<br>MAP_SHARED：对映射区域的写入数据会复制回文件内，而且允许其它映射文件的进程共享。<br>MAP_PRIVATE：对映射区域的写入操作会产生一个映射文件的复制，即私人的“写时复制”对此区域的任何修改都不会写回原来的文件内容。<br>MAP_ANONYMOUS：建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。<br>MAP_DENYWRITE：只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。<br>MAP_LOCKED：将映射区域锁定住，这表示该区域不会被置换（swap）。</p>
<p><strong>fd:</strong> 要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。</p>
<p><strong>offset:</strong> 文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。<br>返回值：若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(－1)，错误原因存于errno 中。</p>
<h2 id="通过mmap向文件中写数据"><a href="#通过mmap向文件中写数据" class="headerlink" title="通过mmap向文件中写数据"></a>通过mmap向文件中写数据</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	fd = <span class="built_in">open</span>(<span class="string">"mytest.txt"</span>, O_CREAT | O_RDWR ,<span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"open "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = ftruncate(fd, <span class="number">4</span>);<span class="comment">//将文件大小改为4K</span></span><br><span class="line">	<span class="keyword">if</span>(len == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftruncate "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	p = mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(p == MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"mmap "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">strcpy</span>(p, <span class="string">"abc"</span>);<span class="comment">//写数据</span></span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">int</span> ret = munmap(p, <span class="number">4</span>);<span class="comment">//取消映射文件</span></span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"munmap "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="父子进程通过mmap通信"><a href="#父子进程通过mmap通信" class="headerlink" title="父子进程通过mmap通信"></a>父子进程通过mmap通信</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> fd</span><br><span class="line">	<span class="comment">//fd = open("/dev/zero",O_RDWR);//还可以通过系统文件创建映射区</span></span><br><span class="line">	fd = <span class="built_in">open</span>(<span class="string">"temp"</span>, O_CREAT | O_RDWR, <span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"open "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	unlink(<span class="string">"temp"</span>);<span class="comment">//删除临时文件目录项，使之具备被释放的条件</span></span><br><span class="line">	ftruncate(fd, <span class="number">4</span>);</span><br><span class="line">	p = mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_WRITE | PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//p = mmap(NULL, 4, PROT_WRITE | PROT_READ, MAP_PRIVATE, fd, 0);</span></span><br><span class="line">	<span class="keyword">if</span>(p == MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"mmap "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*p = <span class="number">2000</span>;</span><br><span class="line">		var = <span class="number">1000</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child, *p = %d,var = %d\n"</span>,*p,var);<span class="comment">//父子进程拥有不同的全局变量</span></span><br><span class="line">																								<span class="comment">//val值在父进程中还是为100</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);<span class="comment">//确保数据已经被子进程修改</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"parent, *p = %d,var = %d\n"</span>,*p, var);</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">int</span> ret = munmap(p, <span class="number">4</span>);</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"munmap "</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非血缘关系进程间通信"><a href="#非血缘关系进程间通信" class="headerlink" title="非血缘关系进程间通信"></a>非血缘关系进程间通信</h2><p>启动写端程序时，同时打开读端程序，可以看到数据的持续写入</p>
<h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span> = &#123;</span><span class="number">10</span>, <span class="string">"xiaoming"</span>, <span class="string">'m'</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> *<span class="title">mm</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"./a.out file_shared\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">	ftruncate(fd, <span class="keyword">sizeof</span>(student));</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(<span class="string">"file open "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(mm == MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(<span class="string">"mmap "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//通过while(1)持续向文件中写入数据，可以启动读端程序进行读取</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">memcpy</span>(mm, &amp;student, <span class="keyword">sizeof</span>(student));</span><br><span class="line">		student.id++;	</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	munmap(mm, <span class="keyword">sizeof</span>(student));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(<span class="string">"str"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> *<span class="title">mm</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"./a.out file_shared\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(<span class="string">"mmap "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student), PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"id = %d\tname = %s\t %c\n"</span>,mm-&gt;id, mm-&gt;name, mm-&gt;sex);</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	munmap(mm, <span class="keyword">sizeof</span>(student));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>利用mmap实现多进程复制文件</title>
    <url>/2020/05/16/%E5%88%A9%E7%94%A8mmap%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>程序将文件分为五部分，四个子进程进行前面的复制工作，父进程进行回收四个子进程，并完成最后的复制工作<br><strong>注意:</strong><br>    1.mmap函数指定的读写方式是对mmap映射区而言的<br>    2.创建映射区的权限要小于等于打开文件的权限，映射区创建过程当中存在一次对文件的读操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"./a.out file "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd1, fd2;</span><br><span class="line">	<span class="keyword">int</span> len, i;</span><br><span class="line">	fd1 = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd1 == <span class="number">-1</span>)</span><br><span class="line">	&#123;		</span><br><span class="line">		perror(<span class="string">"open file1 error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	len = lseek(fd1, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	<span class="keyword">void</span>*mmap_r = mmap(<span class="literal">NULL</span>, len, PROT_READ , MAP_SHARED, fd1, <span class="number">0</span>);<span class="comment">//创建读映射区</span></span><br><span class="line">	<span class="keyword">if</span>(mmap_r == MAP_FAILED)</span><br><span class="line">	&#123;		</span><br><span class="line">		perror(<span class="string">"mmap_r error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fd2 = <span class="built_in">open</span>(argv[<span class="number">2</span>], O_CREAT | O_RDWR, <span class="number">0644</span>);</span><br><span class="line">	<span class="comment">//因为创建映射区会对文件进行一次读操作，所以需要读权限</span></span><br><span class="line">	<span class="keyword">if</span>(fd2 == <span class="number">-1</span>)	</span><br><span class="line">	&#123;		</span><br><span class="line">		perror(<span class="string">"open file2 error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ret = ftruncate(fd2, len);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftruncate error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> *mmap_w = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd2, <span class="number">0</span>);<span class="comment">//创建写映射区</span></span><br><span class="line">	<span class="keyword">if</span>(mmap_w == MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"mmap_w error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">//循环创建进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"fork error\n"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> wpid;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">4</span>)<span class="comment">//父进程进行回收子进程，并进行最后的复制工作</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">			<span class="keyword">if</span>(wpid &gt; <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				n--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span>(n);</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w+<span class="number">4</span>*len/<span class="number">5</span>, mmap_r+<span class="number">4</span>*len/<span class="number">5</span>, len<span class="number">-4</span>*len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"parent copy 5th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w, mmap_r, len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"son1 copy 1th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w+i*len/<span class="number">5</span>, mmap_r+i*len/<span class="number">5</span>, len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"son2 copy 2th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w+i*len/<span class="number">5</span>, mmap_r+i*len/<span class="number">5</span>, len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"son3 copy 3th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w+i*len/<span class="number">5</span>, mmap_r+i*len/<span class="number">5</span>, len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"son4 copy 4th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd1);</span><br><span class="line">	<span class="built_in">close</span>(fd2);</span><br><span class="line">	munmap(mmap_w, len);</span><br><span class="line">	munmap(mmap_r, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>mmap</tag>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>信号</title>
    <url>/2020/05/17/%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="信号的机制和特点"><a href="#信号的机制和特点" class="headerlink" title="信号的机制和特点"></a>信号的机制和特点</h1><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><p>A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。</p>
<p>与硬件中断类似——异步模式。但信号是软件层面上实现的中断，常被称为“软中断”。</p>
<p>信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。</p>
<p><strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、简单<br>2、不能携带大量信息<br>3、满足某个特设条件才发送</p>
<h1 id="信号四要素"><a href="#信号四要素" class="headerlink" title="信号四要素"></a>信号四要素</h1><p>1、编号<br>2、名称<br>3、事件<br>4、默认处理动作<br>默认动作：<br>    Term：终止进程<br>    Ign： 忽略信号 (默认即时对该种信号忽略操作)<br>    Core：终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试)<br>    Stop：停止（暂停）进程<br>    Cont：继续运行进程<br><strong>9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</strong></p>
<h1 id="与信号相关的事件"><a href="#与信号相关的事件" class="headerlink" title="与信号相关的事件"></a>与信号相关的事件</h1><h2 id="递达和未决"><a href="#递达和未决" class="headerlink" title="递达和未决"></a>递达和未决</h2><h3 id="递达"><a href="#递达" class="headerlink" title="递达"></a>递达</h3><p>递达并且到达进程</p>
<h3 id="未决"><a href="#未决" class="headerlink" title="未决"></a>未决</h3><p>产生和递达之间的状态，主要由于阻塞（屏蔽）导致该状态</p>
<h4 id="阻塞信号集（信号屏蔽字）"><a href="#阻塞信号集（信号屏蔽字）" class="headerlink" title="阻塞信号集（信号屏蔽字）"></a>阻塞信号集（信号屏蔽字）</h4><p>将某些信号加入集合，对他们设置屏蔽，当屏蔽某信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)</p>
<h4 id="未决信号集"><a href="#未决信号集" class="headerlink" title="未决信号集"></a>未决信号集</h4><p>1、信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。<br>2、信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。   </p>
<h1 id="信号的处理方式"><a href="#信号的处理方式" class="headerlink" title="信号的处理方式"></a>信号的处理方式</h1><p>第一种是类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理。</p>
<p>第二种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。</p>
<p>第三种方法是，对该信号的处理保留系统的默认值，这种缺省操作，对大部分的信号的缺省操作是使得进程终止。进程通过系统调用signal来指定进程对某个信号的处理行为。</p>
<h1 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h1><p>1、按键产生，如：Ctrl+c、Ctrl+z、Ctrl+<br>2、系统调用产生，如：kill、raise、abort<br>3、软件条件产生，如：定时器alarm<br>4、硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)<br>5、命令产生，如：kill命令</p>
<h2 id="kill函数-命令产生信号"><a href="#kill函数-命令产生信号" class="headerlink" title="kill函数/命令产生信号"></a>kill函数/命令产生信号</h2><p>kill命令产生信号：kill -SIGKILL pid<br>kill函数：给指定进程发送指定信号(<strong>不一定杀死</strong>)<br>函数原型：int kill(pid_t pid, int sig)   成功：0；失败：-1 (ID非法，信号非法，普通用户杀init进程等权级问题)，设置errno</p>
<p>sig：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。<br>pid &gt; 0:  发送信号给指定的进程。<br>pid = 0:  发送信号给 与调用kill函数进程属于同一进程组的所有进程。<br>pid &lt; 0:  取|pid|发给对应进程组。<br>pid = -1：发送给进程有权限发送的系统中所有进程。</p>
<p>进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</p>
<p>权限保护：super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的<br>例如kill -9 (root用户的pid)  是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。普通用户基本规则是：发送者实际或有效用户ID等于接收者实际或有效用户ID</p>
<h2 id="raise和abort函数"><a href="#raise和abort函数" class="headerlink" title="raise和abort函数"></a>raise和abort函数</h2><p>raise 函数：给当前进程发送指定信号(自己给自己发)    <strong>raise(signo) == kill(getpid(), signo)</strong><br>函数原型：int raise(int sig)  成功：0，失败非0值</p>
<p>abort 函数：给自己发送异常终止信号 6) SIGABRT 信号，终止并产生core文件<br>函数原型：void abort(void)  该函数无返回</p>
<h2 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h2><p>作用：设置定时器(闹钟)<br>在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。</p>
<p><strong>每个进程都有且只有唯一个定时器。</strong></p>
<p>函数原型：unsigned int alarm(unsigned int seconds) 返回0或剩余的秒数，无失败。<br><strong>常用：取消定时器使用alarm(0)，返回旧闹钟余下秒数。</strong><br>定时，与进程状态无关(自然定时法)，就绪、运行、挂起(阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm都计时。<br>使用time命令查看程序执行的时间。    </p>
<p><strong>程序运行的瓶颈在于IO，优化程序，首选优化IO。</strong><br>实际执行时间 = 系统时间 + 用户时间 + 等待时间</p>
<h2 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h2><p>作用：设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。<br>函数原型：int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value)    成功：0；失败：-1，设置errno</p>
<p>参数<br>which：指定定时方式<br>1、自然定时：ITIMER_REAL → 14）SIGLAR——计算自然时间<br>2、虚拟空间计时(用户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM——只计算进程占用cpu的时间<br>3、运行时计时(用户+内核)：ITIMER_PROF → 27）SIGPROF——计算占用cpu及执行系统调用的时间</p>
<p><strong>it_interval：用来设定两次定时任务之间间隔的时间<br>it_value：定时的时长<br>两个参数都设置为0，即清0操作。</strong></p>
<h3 id="setitimer函数实现alarm函数，实现计算机1秒数数程序。"><a href="#setitimer函数实现alarm函数，实现计算机1秒数数程序。" class="headerlink" title="setitimer函数实现alarm函数，实现计算机1秒数数程序。"></a>setitimer函数实现alarm函数，实现计算机1秒数数程序。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	struct itimerval </span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		struct timeval</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			it_value.tv_sec;</span></span><br><span class="line"><span class="comment">			it_value.tv_usec;	</span></span><br><span class="line"><span class="comment">		&#125;it_interval;//用来设定两次定时任务之间间隔的时间</span></span><br><span class="line"><span class="comment">		struct timeval</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			it_value.tv_sec;</span></span><br><span class="line"><span class="comment">			it_value.tv_usec;	</span></span><br><span class="line"><span class="comment">		&#125;it_value;//定时的时长</span></span><br><span class="line"><span class="comment">	&#125;it, oldit;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">my_alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> sec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	it.it_value.tv_sec = sec;</span><br><span class="line">	it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">	it.it_interval.tv_sec = <span class="number">0</span>;<span class="comment">//两次定时之间的间隔</span></span><br><span class="line">	it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">	ret = setitimer(ITIMER_REAL, &amp;it, &amp;oldit);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"setitimer\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> oldit.it_value.tv_sec;<span class="comment">//返回剩余的秒数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	my_alarm(<span class="number">1</span>);<span class="comment">//alarm(1);</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用setitimer函数的参数实现定时间隔"><a href="#利用setitimer函数的参数实现定时间隔" class="headerlink" title="利用setitimer函数的参数实现定时间隔"></a>利用setitimer函数的参数实现定时间隔</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">	signal(SIGALRM, myfunc);<span class="comment">//注册SIGALRM信号的捕捉处理函数</span></span><br><span class="line">	it.it_value.tv_sec = <span class="number">5</span>;</span><br><span class="line">	it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">	it.it_interval.tv_sec = <span class="number">3</span>;</span><br><span class="line">	it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(setitimer(ITIMER_REAL, &amp;it, &amp;oldit) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"setitimer error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h1><p>内核通过读取未决信号集来判断信号是否应被处理<br>信号屏蔽字mask可以影响未决信号集。而我们可以在应用程序中自定义set来改变mask。已达到屏蔽指定信号的目的。</p>
<h2 id="信号集设定函数"><a href="#信号集设定函数" class="headerlink" title="信号集设定函数"></a>信号集设定函数</h2><p>sigset_t  set;        // typedef unsigned long sigset_t;<br>int sigemptyset(sigset_t *set)：将某个信号集清0<br>成功：0，失败：-1</p>
<p>int sigfillset(sigset_t *set)：将某个信号集置1<br>成功：0，失败：-1</p>
<p>int sigaddset(sigset_t *set, int signum)：将某个信号加入信号集<br>成功：0，失败：-1</p>
<p>int sigdelset(sigset_t *set, int signum)    ：将某个信号清出信号集<br>成功：0，失败：-1</p>
<p>int sigismember(const sigset_t *set, int signum)：判断某个信号是否在信号集中<br>返回值：在集合：1，不在：0，出错：-1  </p>
<p><strong>sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</strong></p>
<h2 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h2><p>用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB中)<br><strong>严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。</strong><br>函数原型：int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)    成功：0，失败：-1，设置errno<br>参数：<br>set：传入参数，是一个位图，set中哪位置1，就表示当前进程屏蔽哪个信号。oldset：传出参数，保存旧的信号屏蔽集。<br>how参数取值：假设当前的信号屏蔽字为mask。<br>1、SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask = mask|set<br>2、SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask = mask &amp;~set<br>3、SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于 mask = set，若调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</p>
<h2 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h2><p>读取当前进程的未决信号集<br>函数原型：int sigpending(sigset_t *set)    set传出参数。<br>返回值：成功：0，失败：-1，设置errno</p>
<h2 id="所有常规信号的未决状态打印至屏幕"><a href="#所有常规信号的未决状态打印至屏幕" class="headerlink" title="所有常规信号的未决状态打印至屏幕"></a>所有常规信号的未决状态打印至屏幕</h2><p>解释：在程序执行过程中使用终端按键产生信号观察未决信号集的变化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printped</span><span class="params">(<span class="keyword">sigset_t</span> *ped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++)<span class="comment">//打印前31个未决信号集</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">if</span>(sigismember(ped, i) == <span class="number">1</span>)<span class="comment">//判断是否处于未决状态</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">sigset_t</span> myset, oldset, ped;</span><br><span class="line">	sigemptyset(&amp;myset);<span class="comment">//将myset置为空</span></span><br><span class="line">	sigaddset(&amp;myset, SIGQUIT);<span class="comment">//将三个信号添加到信号集中</span></span><br><span class="line">	sigaddset(&amp;myset, SIGINT);</span><br><span class="line">	sigaddset(&amp;myset, SIGTSTP);</span><br><span class="line">	<span class="keyword">int</span> ret = sigprocmask(SIG_BLOCK, &amp;myset, &amp;oldset);<span class="comment">//设置屏蔽信号</span></span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"sigprocmask error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sigpending(&amp;ped);</span><br><span class="line">		printped(&amp;ped);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h1><h2 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h2><p>作用：注册一个信号捕捉函数<br>typedef void (<em>sighandler_t)(int);<br>sighandler_t signal(int signum, sighandler_t handler);<br>*</em>该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。**</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catchsigint</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;catch\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">__sighandler_t</span> handler;</span><br><span class="line">	handler = signal(SIGINT, catchsigint);<span class="comment">//捕捉SIGINT信号</span></span><br><span class="line">	<span class="comment">//当接收到SIGINT信号时，执行信号捕捉函数</span></span><br><span class="line">	<span class="keyword">if</span>(handler == SIG_ERR)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"signal error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h2><p>作用：修改信号处理动作（通常在Linux用其来注册一个信号的捕捉函数）<br>函数原型:int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)<br>成功：0；失败：-1，设置errno</p>
<p>参数：<br>act：传入参数，新的处理方式。<br>oldact：传出参数，旧的处理方式。</p>
<p>struct sigaction结构体<br>struct sigaction {<br>    void     (<em>sa_handler)(int);<br>    void     (</em>sa_sigaction)(int, siginfo_t <em>, void *);<br>    sigset_t   sa_mask;<br>    int       sa_flags;<br>    void     (</em>sa_restorer)(void);<br>};<br>sa_restorer：该元素是过时的，不应该使用，POSIX.1标准将不指定该元素。(弃用)<br>sa_sigaction：当sa_flags被指定为SA_SIGINFO标志时，使用该信号处理程序。(很少使用)<br>1、sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作<br>2、sa_mask: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。<strong>注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</strong><br>3、sa_flags：通常设置为0，表使用默认属性。    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">docatch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d signal is catched\n"</span>,signo);</span><br><span class="line">	<span class="comment">//在此期间SIGQUIT信号被屏蔽，等到睡晚10秒以后SIGQUIT信号会被执行一次</span></span><br><span class="line">	sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">	act.sa_handler = docatch;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	sigaddset(&amp;act.sa_mask, SIGQUIT);</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;<span class="comment">//使用默认属性 信号捕捉函数执行期间，屏蔽本信号</span></span><br><span class="line">	<span class="keyword">int</span> ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"sigaction error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//sleep(5);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>全局变量的异步I_O</title>
    <url>/2020/05/18/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%82%E6%AD%A5I_O/</url>
    <content><![CDATA[<p>以一个程序来演示：该程序是父子进程通过一个全局变量进行相互数数。</p>
<h1 id="初级版（存在问题）"><a href="#初级版（存在问题）" class="headerlink" title="初级版（存在问题）"></a>初级版（存在问题）</h1><p>解释:通过flag变量标记程序实行进度。flag置1表示数数完成。flag置0表示给对方发送信号完成。<br>问题出现的位置，在父子进程kill函数之后需要紧接着调用 flag，将其置0，标记信号已经发送。但，在这期间很有可能被kernel调度，失去执行权利，而对方获取了执行时间，通过发送信号回调捕捉函数，从而修改了全局的flag。</p>
<p>程序执行期间会造成程序无法唤醒的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//父子进程相互数数,全局变量的异步IO</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I am child %d\t%d\n"</span>, getpid(), n);</span><br><span class="line">	n += <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	flag = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_parent</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I am parent %d\t%d\n"</span>, getpid(), n);</span><br><span class="line">	n += <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	flag = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(<span class="string">"fork"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n = <span class="number">1</span>;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		act.sa_handler = do_sig_parent;</span><br><span class="line">		sigemptyset(&amp;act.sa_mask);</span><br><span class="line">		act.sa_flags = <span class="number">0</span>;</span><br><span class="line">		sigaction(SIGUSR2, &amp;act, <span class="literal">NULL</span>);<span class="comment">//注册自己的信号捕捉函数</span></span><br><span class="line">		do_sig_parent(<span class="number">0</span>);		<span class="comment">//父使用SIGUSR2信号</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//等待信号</span></span><br><span class="line">			<span class="keyword">if</span>(flag == <span class="number">1</span>)<span class="comment">//父进程数数完成</span></span><br><span class="line">			&#123;</span><br><span class="line">				kill(pid, SIGUSR1);</span><br><span class="line">			<span class="comment">//----如果失去cpu，已给子进程发信号，此时flag = 1</span></span><br><span class="line">			<span class="comment">//子进程数完后给父进程发信号，数完之后，获得cpu</span></span><br><span class="line">			<span class="comment">//标志flag = 0,子进程已经发过信号，都在等待信号</span></span><br><span class="line">			<span class="comment">//所以flag一直会等于0 ，程序停止</span></span><br><span class="line">			<span class="comment">//在子进程同样位置有此时间空档情况</span></span><br><span class="line">				flag = <span class="number">0</span>;<span class="comment">//标志已给子进程发送完信号</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n = <span class="number">2</span>;</span><br><span class="line">		act.sa_handler = do_sig_child;</span><br><span class="line">		sigemptyset(&amp;act.sa_mask);</span><br><span class="line">		act.sa_flags = <span class="number">0</span>;</span><br><span class="line">		sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>);<span class="comment">//父进程数数完成发送SIGUSR1</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)			<span class="comment">//给子进程</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//等待信号</span></span><br><span class="line">			<span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				kill(getppid(), SIGUSR2);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完善版"><a href="#完善版" class="headerlink" title="完善版"></a>完善版</h1><p>通过在信号处理函数中父进程（子进程）数完数以后发送信号给子进程（父进程），避免了程序无法唤醒的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//父子进程交替数数升级版</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>, num1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pid_t</span> son_pid;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"parent\tnum = %d\n"</span>,num1);</span><br><span class="line">	num1 += <span class="number">2</span>;</span><br><span class="line">	kill(son_pid, SIGUSR2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child\tnum = %d\n"</span>, num);</span><br><span class="line">	num += <span class="number">2</span>;</span><br><span class="line">	kill(getppid(), SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act1</span>, <span class="title">act2</span>;</span></span><br><span class="line">	pid = fork();</span><br><span class="line">	son_pid = pid;</span><br><span class="line">	<span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		act1.sa_handler = parent;</span><br><span class="line">		sigemptyset(&amp;act1.sa_mask);</span><br><span class="line">		act1.sa_flags = <span class="number">0</span>;</span><br><span class="line">		sigaction(SIGUSR1, &amp;act1, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);<span class="comment">//让父进程先注册捕获函数</span></span><br><span class="line">		act2.sa_handler = child;</span><br><span class="line">		sigemptyset(&amp;act2.sa_mask);</span><br><span class="line">		act2.sa_flags = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> ret = sigaction(SIGUSR2, &amp;act2, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perr(<span class="string">"sigaction error"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		kill(getppid(), SIGUSR1);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		perr(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>回收子进程</title>
    <url>/2020/05/15/%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：</p>
<p>如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。</p>
<p>我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p>
<h1 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h1><p>父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</p>
<h1 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h1><p>进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</p>
<h1 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h1><p>该函数有三个功能：<br>① 阻塞等待子进程退出<br>② 回收子进程残留资源<br>③ 获取子进程结束状态(退出原因)。</p>
<p> 原型:pid_t wait(int *status)</p>
<p>成功：清理掉的子进程ID；失败：-1 (没有子进程)</p>
<p>当进程终止时，操作系统的隐式回收机制：</p>
<p>1.关闭所有文件描述符 </p>
<p>2.释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)</p>
<p>可使用wait函数传出参数status来保存进程的退出状态。</p>
<p>借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：<br> 1.WIFEXITED(status) 为非0    → 进程正常结束<br>    WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)</p>
<p> 2.WIFSIGNALED(status) 为非0 → 进程异常终止<br>    WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</p>
<p>3.WIFSTOPPED(status) 为非0 → 进程处于暂停状态<br>    WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。<br>    WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">pid_t</span> pid,wpid;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm child,my parent = %d,going to sleep 10s\n"</span>,getppid());</span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"child die\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">76</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                wpid = wait(&amp;status);<span class="comment">//阻塞等待回收</span></span><br><span class="line">                <span class="keyword">if</span>(wpid == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">"wait "</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"child exit with %d\n"</span>,WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"child killed by%d\n"</span>,WTERMSIG(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"I'm parent,pid = %d,myson =%d\n"</span>,getpid(),pid);</span><br><span class="line">                        sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">"fork "</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid()"></a>waitpid()</h1><p>原型：pid_t waitpid(pid_t pid, int *status, in options)    </p>
<p>成功：返回清理掉的子进程ID  失败：-1(无子进程)</p>
<p>特殊参数和返回情况<br>参数pid:<br>pid &gt; 0 回收指定ID的子进程<br>pid = -1 回收任意子进程（相当于wait）<br>pid = 0 回收和当前调用waitpid一个组的所有子进程<br>pid &lt; -1 回收指定进程组内的任意子进程</p>
<p>参数options指定为WNOHANG，设置为非阻塞，且子进程正在运行</p>
<p>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>当程序执行之后，通过while(1)阻止父进程结束，可通过ps aux查看是否存在僵尸进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>,i;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">pid_t</span> wpid;</span><br><span class="line">        <span class="keyword">int</span> q,p;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                p = fork();</span><br><span class="line">                <span class="keyword">if</span>(p == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                &#125;    </span><br><span class="line">                <span class="comment">//else if(i == 3)</span></span><br><span class="line">                <span class="comment">//&#123;</span></span><br><span class="line">                <span class="comment">//        q = p;//设置回收指定子进程</span></span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == i)<span class="comment">//父进程</span></span><br><span class="line">        &#123;</span><br><span class="line">                sleep(n);<span class="comment">//等待子进程执行完</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm parent,pid = %d\n"</span>,getppid());</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                        wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">                        <span class="keyword">if</span>(wpid &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                n--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(n &gt; <span class="number">0</span>); </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"wait finish\n"</span>);</span><br><span class="line">                <span class="comment">//while(waitpid(q, NULL, WNOHANG))</span></span><br><span class="line">				<span class="comment">//wait(NULL);</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm %dth child, pid = %d, gpid = %d\n"</span>,i+<span class="number">1</span>, getpid(),getppid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>竞态条件（时序竞态）</title>
    <url>/2020/05/18/%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%88%E6%97%B6%E5%BA%8F%E7%AB%9E%E6%80%81%EF%BC%89/</url>
    <content><![CDATA[<h1 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a>pause函数</h1><p>调用该函数可以造成进程主动挂起，等待信号唤醒。<br>调用该系统调用的进程将处于阻塞状态(主动放弃cpu) 直到有信号递达将其唤醒。<br>函数原型：int pause(void）<br>返回值：-1 并设置errno为EINTR<br>返回值：<br>1、如果信号的默认处理动作是终止进程，则进程终止，pause函数没有机会返回。<br>2、如果信号的默认处理动作是忽略，进程继续处于挂起状态，pause函数不返回。<br>3、如果信号的处理动作是捕捉，则调用完信号处理函数之后，pause返回-1，errno设置为EINTR，表示“被信号中断”。<br>4、pause收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒。</p>
<h1 id="sleep实现"><a href="#sleep实现" class="headerlink" title="sleep实现"></a>sleep实现</h1><h2 id="存在时序竞态问题"><a href="#存在时序竞态问题" class="headerlink" title="存在时序竞态问题"></a>存在时序竞态问题</h2><p>pause函数和alarm函数实现sleep<br>可以通过设置屏蔽SIGALRM的方法来控制程序执行逻辑，但无论如何设置，程序都有可能在“解除信号屏蔽”与“挂起等待信号”这个两个操作间隙失去cpu资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_sigalarm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">	act.sa_handler = catch_sigalarm;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = sigaction(SIGALRM, &amp;act, &amp;oldact);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"sigaction error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	alarm(seconds);</span></span><br><span class="line"><span class="comment">	//如果失去了CPU，优先级较高的程序较多，长时间没有分配CPU</span></span><br><span class="line"><span class="comment">	//如果2S后再获得CPU，先处理信号，程序则不能被唤醒</span></span><br><span class="line"><span class="comment">	ret = pause();</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	alarm(seconds);</span><br><span class="line">	<span class="comment">//屏蔽</span></span><br><span class="line">	ret = pause();</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINTR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pause successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = alarm(<span class="number">0</span>);</span><br><span class="line">	sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);<span class="comment">//恢复SIGALRM信号旧有的处理方式</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ret = mysleep(<span class="number">1</span>);<span class="comment">//睡1S</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d------\n"</span>,ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可将某个信号（如SIGALRM）从临时信号屏蔽字mask中删除，这样在调用sigsuspend时将解除对该信号的屏蔽，然后挂起等待，当sigsuspend返回时，进程的信号屏蔽字恢复为原来的值。如果原来对该信号是屏蔽态，sigsuspend函数返回后仍然屏蔽该信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nsecs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">	<span class="keyword">sigset_t</span> newmask, oldmask, suspmask;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line">	<span class="comment">//1、为SIGALRM设置捕捉函数</span></span><br><span class="line">	newact.sa_handler = sig_alrm;</span><br><span class="line">	sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">	newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigaction(SIGALRM, &amp;newact, &amp;oldact);</span><br><span class="line">	<span class="comment">//2、设置阻塞信号集，阻塞SIGALRM信号</span></span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigaddset(&amp;newmask, SIGALRM);</span><br><span class="line">	sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);<span class="comment">//屏蔽信号字 mask</span></span><br><span class="line">	<span class="comment">//3、定时n秒，到时后可以产生SIGALRM信号</span></span><br><span class="line">	alarm(nsecs);</span><br><span class="line">	<span class="comment">//4、构造一个调用sigsuspend临时有效的阻塞信号集</span></span><br><span class="line">	<span class="comment">//在临时阻塞信号集里解除SIGALRM的阻塞</span></span><br><span class="line">	suspmask = oldmask;                 <span class="comment">//SIGALRM没有被阻塞</span></span><br><span class="line">	sigdelset(&amp;suspmask, SIGALRM);<span class="comment">//保证SIGALRM一定没有被屏蔽</span></span><br><span class="line">	<span class="comment">//5、sigsuspend调用期间，采用临时阻塞信号集suspmask替换原有</span></span><br><span class="line">	<span class="comment">//这个信号集中不包括SIGALRM信号，同时挂起等待</span></span><br><span class="line">	<span class="comment">//当sigsuspend被信号唤醒返回时，恢复原有的阻塞信号集</span></span><br><span class="line">	sigsuspend(&amp;suspmask);<span class="comment">//解除屏蔽调用信号处理函数，同时执行</span></span><br><span class="line">	unslept = alarm(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//6、恢复SIGALRM原有的处理动作-----回应注释1</span></span><br><span class="line">	sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//7、解除对SIGALRM阻塞-------回应注释2</span></span><br><span class="line">	sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> unslept;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mysleep(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"------\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</p>
<p>不可靠由其实现原理所致：信号是通过软件方式实现(跟内核调度高度依赖，延时性强)，每次系统调用结束后，或中断处理处理结束后，需通过扫描PCB中的未决信号集，来判断是否应处理某个信号。当系统负载过重时，会出现时序混乱。</p>
<p>这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。且由于该错误不具规律性，后期捕捉和重现十分困难。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>管道</title>
    <url>/2020/05/15/%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<p><strong>管道是一种最基本的IPC机制</strong><br>作用于有血缘关系的进程之间，完成数据传递。</p>
<p>调用pipe系统函数即可创建一个管道。有如下特征：<br>1.其本质是一个伪文件(实为内核缓冲区)<br>2.由两个文件描述符引用，一个表示读端，一个表示写端。<br>3.规定数据从管道的写端流入管道，从读端流出。</p>
<p><strong>管道的原理：</strong><br>管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p>
<p><strong>管道的局限性：</strong><br>1.数据自己读不能自己写。<br>2. 数据一旦被读走，便不在管道中存在，不可反复读取。<br>3. 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。<br>4. 只能在有公共祖先的进程间使用管道。</p>
<p>常见的通信方式有，单工通信、半双工通信、全双工通信</p>
<h1 id="pipe"><a href="#pipe" class="headerlink" title="pipe()"></a>pipe()</h1><p>函数原型：int pipe(int pipefd[2])<br>成功：0；失败：-1，设置errno</p>
<p>1.父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。<br> 2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。<br> 3. 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];<span class="comment">//读写文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe err"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork err"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">//子进程，读数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="built_in">close</span>(fd[<span class="number">1</span>]);<span class="comment">//关闭写端</span></span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        ret = <span class="built_in">read</span>(fd[<span class="number">0</span>], buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"--------\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in">write</span>(STDOUT_FILENO, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);<span class="comment">//关闭读端</span></span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>],<span class="string">"hello pipe\n"</span>, <span class="built_in">strlen</span>(<span class="string">"hello pipe\n"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>进程的创建以及exec族函数的应用</title>
    <url>/2020/05/14/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BB%A5%E5%8F%8Aexec%E6%97%8F%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="父子进程共享"><a href="#父子进程共享" class="headerlink" title="父子进程共享"></a>父子进程共享</h2><p>父子进程间遵循读时共享写时复制的原则。</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>全局变量、.date、.text、栈、堆、环境变量、用户ID、宿主ID、进程工作目录、信号处理方式…</p>
<h3 id="非共享"><a href="#非共享" class="headerlink" title="非共享"></a>非共享</h3><p>进程ID、fork返回值、父进程ID、进程运行时间、闹钟、未决信号集</p>
<h2 id="循环创建多个多进程"><a href="#循环创建多个多进程" class="headerlink" title="循环创建多个多进程"></a>循环创建多个多进程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"xxxxxxxx\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">//关键所在</span></span><br><span class="line">                <span class="comment">//如果不break则会导致子进程继续fork，从而导致不只有5个子进程</span></span><br><span class="line">                <span class="comment">//      printf("I'm %dth child ,pid = %u,ppid = %u\n",i+1,getpid(),getppid());</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm %dth child, pid = %u\n"</span>,i+<span class="number">1</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm parent"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"yyyyyyyyyyyy\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="exec族函数"><a href="#exec族函数" class="headerlink" title="exec族函数"></a>exec族函数</h2><p>用途：加载某一个进程</p>
<h3 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h3><p>加载一个进程，借助PATH环境变量</p>
<p>int execlp(const char *file, const char *arg, …)成功：无返回；失败：-1<br>参数1 : 要加载的程序的名字。</p>
<p>execlp(“ls”, “ls”, “-l”, “-F”, NULL);         使用程序名在PATH中搜索。<br>该函数通常调用系统程序例如：ls date cp</p>
<h3 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h3><p>加载一个进程， 通过 路径+程序名 来加载。</p>
<p>int execl(const char *path, const char *arg, …成功：无返回；失败：-1</p>
<p>execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL);<br>使用参数1给出的绝对路径搜索。</p>
<h3 id="execvp"><a href="#execvp" class="headerlink" title="execvp"></a>execvp</h3><p>加载一个进程，使用自定义环境变量env</p>
<p>int execvp(const char *file, const char *argv[]);<br>变参形式： ①… ② argv[]  (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, …)) </p>
<p>变参终止条件：① NULL结尾 ② 固参指定</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">"fork "</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"parent\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//execl("./while","while",NULL);</span></span><br><span class="line">                execl(<span class="string">"/bin/ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"-F"</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">//execlp("ls", "ls","-l","-a",NULL);</span></span><br><span class="line">                <span class="keyword">char</span> *argv[] = &#123;<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="string">"-a"</span>,<span class="string">"-h"</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">                <span class="comment">//execv("/bin/ls",argv);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用dup2-重定向输出到文件中"><a href="#利用dup2-重定向输出到文件中" class="headerlink" title="利用dup2()重定向输出到文件中"></a>利用dup2()重定向输出到文件中</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd; </span><br><span class="line">        fd = <span class="built_in">open</span>(<span class="string">"ps.out"</span>, O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">"open ps.out"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">        dup2(fd, STDOUT_FILENO);<span class="comment">//dup2(3,1);</span></span><br><span class="line">        <span class="comment">//将标准输出重定向到自己创建的文件中</span></span><br><span class="line">        execlp(<span class="string">"ps"</span>,<span class="string">"ps"</span>,<span class="string">"aux"</span>,<span class="literal">NULL</span>);<span class="comment">//no successful return</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2020/05/19/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h1><p>LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)</p>
<p>进程：独立地址空间，拥有PCB<br>线程：也有PCB，但没有独立的地址空间(共享)<br>区别：在于是否共享地址空间。<br>Linux下：<br><strong>线程：最小的执行单位<br>进程：最小分配资源单位，可看成是只有一个线程的进程。</strong></p>
<h1 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a>Linux内核线程实现原理</h1><p>1、线程也有PCB，创建线程使用的底层函数和进程一样，都是clone<br>2、从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的<br>3、进程可以蜕变成线程<br>4、线程可看做寄存器和栈的集合<br>5、<strong>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</strong></p>
<p>对于进程来说，相同的地址(同一个虚拟地址)在不同的进程中，反复使用而不冲突。原因是他们虽虚拟址一样，但，页目录、页表、物理页面各不相同。相同的虚拟址，映射到不同的物理页面内存单元，最终访问不同的物理页面。</p>
<p><strong>但线程不同</strong>，两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。<br>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。<br>如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。<br><strong>因此</strong>：Linux内核是不区分进程和线程的。只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</p>
<h1 id="线程资源的共享与非共享"><a href="#线程资源的共享与非共享" class="headerlink" title="线程资源的共享与非共享"></a>线程资源的共享与非共享</h1><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>1、文件描述符表<br>2、每种信号的处理方式<br>3、当前工作目录<br>4、用户ID和组ID<br>5、内存地址空间 (.text/.data/.bss/heap/共享库)</p>
<h2 id="非共享"><a href="#非共享" class="headerlink" title="非共享"></a>非共享</h2><p>1、线程id<br>2、处理器现场和栈指针(内核栈)<br>3、独立的栈空间(用户空间栈)<br>4、errno变量<br>5、信号屏蔽字<br>6、调度优先级</p>
<h1 id="线程的控制原语"><a href="#线程的控制原语" class="headerlink" title="线程的控制原语"></a>线程的控制原语</h1><h2 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h2><p>作用：获取线程ID。<br>函数原型：pthread_t pthread_self(void）<br>返回值：成功：线程ID；    失败：无</p>
<p>线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现</p>
<p>线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同)<br><strong>注意：不应使用全局变量 pthread_t tid，而在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。</strong></p>
<h2 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h2><p>作用：创建一个新线程。<br>函数原型：int pthread_create(pthread_t <em>thread, const pthread_attr_t *attr, void *(</em>start_routine) (void *), void *arg)<br>返回值：成功：0，    失败：错误号    —–Linux环境下，所有线程特点，失败均直接返回错误号。</p>
<p>参数：<br>pthread_t：typedef unsigned long int pthread_t;<strong>(Linux)</strong><br>参数1：传出参数，保存系统为我们分配好的线程ID<br>参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。<br>参数3：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。<br>参数4：线程主函数执行期间所使用的参数。</p>
<h2 id="创建新线程，打印线程ID"><a href="#创建新线程，打印线程ID" class="headerlink" title="创建新线程，打印线程ID"></a>创建新线程，打印线程ID</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In thread:thread id = %lu\n"</span>, pthread_self());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %u\n"</span>,getpid());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In main1:thread id = %lu\n"</span>, pthread_self());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %u\n"</span>,getpid());</span><br><span class="line">	ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span> ,<span class="string">"pthread_create error:%s\n"</span>,strerror(ret));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In main2:thread id = %lu\n"</span>, pthread_self());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %u\n"</span>,getpid());</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环创建多个线程"><a href="#循环创建多个线程" class="headerlink" title="循环创建多个线程"></a>循环创建多个线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int i = *(int *)arg;这样是错误的</span></span><br><span class="line">	<span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line">	sleep(i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%dth thread:"</span>,i+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In thread:thread id = %lu\n"</span>, pthread_self());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %u\n"</span>,getpid());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="comment">//在线程取地址之后，有可能i的值发生变化</span></span><br><span class="line">		<span class="comment">//ret = pthread_create(&amp;tid, NULL, thrd_func, (void *)&amp;i);</span></span><br><span class="line">		ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span> *)i);</span><br><span class="line">		<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span> ,<span class="string">"pthread_create error:%s\n"</span>,strerror(ret));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程之间共享全局变量"><a href="#线程之间共享全局变量" class="headerlink" title="线程之间共享全局变量"></a>线程之间共享全局变量</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//线程之间共享全局变量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	var = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"at first var = %d\n"</span>, var);</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"after pthread_create, var = %d\n"</span>, var);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h2><p>作用：将单个线程退出<br>函数原型：void pthread_exit(void <em>retval)<br>参数：retval表示线程退出状态，通常传NULL<br>*</em>注意：线程中，禁止使用exit函数，会导致进程内所有线程全部退出。**</p>
<h2 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h2><p>作用：阻塞等待线程退出，获取线程退出状<br>函数原型：int pthread_join(pthread_t thread, void **retval)</p>
<p>成功：0；失败：错误号<br>参数：thread：线程ID,retval：存储线程结束状态。</p>
<p>1、如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。<br>2、如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。<br>3、如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。<br>4、如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。</p>
<h2 id="回收多个子线程"><a href="#回收多个子线程" class="headerlink" title="回收多个子线程"></a>回收多个子线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//循环回收多个子线程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	i = (<span class="keyword">int</span>)arg;</span><br><span class="line">	sleep(i);</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">1</span>)<span class="comment">//第二个线程修改val=333</span></span><br><span class="line">	&#123;</span><br><span class="line">		var = <span class="number">333</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"var = %d\n"</span>,var);</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">void</span> *)var;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>)<span class="comment">//第4个线程修改val=777</span></span><br><span class="line">	&#123;</span><br><span class="line">		var = <span class="number">777</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm %dth pthread, id = %lu\n var = %d\n"</span>,i+<span class="number">1</span>, pthread_self(), var);</span><br><span class="line">		pthread_exit((<span class="keyword">void</span> *)var);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm %dth pthread, id = %lu\n var = %d\n"</span>,i+<span class="number">1</span>, pthread_self(), var);</span><br><span class="line">		pthread_exit((<span class="keyword">void</span> *)var);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> *ret[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_create(&amp;tid[i], <span class="literal">NULL</span>, tfn, (<span class="keyword">void</span> *)i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span> ;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_join(tid[i], (<span class="keyword">void</span> **)&amp;ret[i]);<span class="comment">//回收子线程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d 's ret = %d\n"</span>, i+<span class="number">1</span>, (<span class="keyword">int</span>)ret[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I'm main pthread tid = %lu\t var = %d\n"</span>,pthread_self(), var);</span><br><span class="line">	sleep(i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pthread-deatch函数"><a href="#pthread-deatch函数" class="headerlink" title="pthread_deatch函数"></a>pthread_deatch函数</h2><p>作用：实现线程分离<br>函数原型：int pthread_detach(pthread_t thread<br>成功：0，失败：错误号<br><strong>线程分离状态</strong>：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放<br>网络、多线程服务器常用。</p>
<h2 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h2><p>作用：杀死(取消)线程<br>函数原型：int pthread_cancel(pthread_t thread<br>成功：0，失败：错误号</p>
<p>线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。<br><strong>取消点</strong>：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write….. </p>
<p>可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthreestcancel函数自行设置一个取消点。</p>
<p>被取消的线程，退出值定义在Linux的pthread库中<br>常数PTHREAD_CANCELED的值是-1。可在头文件pthread.h中找到它的定义：#define PTHREAD_CANCELED ((void *) -1)。因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1。</p>
<h2 id="杀死线程的三种方式"><a href="#杀死线程的三种方式" class="headerlink" title="杀死线程的三种方式"></a>杀死线程的三种方式</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//杀死线程3种方式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 1 returning\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 2 exiting\n"</span>);</span><br><span class="line">	pthread_exit((<span class="keyword">void</span> *)<span class="number">222</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn3</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//printf("thread 3:I'm going to die in 3 seconds\n");</span></span><br><span class="line">		<span class="comment">//sleep(1);</span></span><br><span class="line">		pthread_testcancel();<span class="comment">//自己设置取消点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">666</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">void</span> *tred = <span class="literal">NULL</span>;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid, &amp;tred);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 1 exit code = %d\n\n"</span>, (<span class="keyword">int</span>)tred);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn2, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid, &amp;tred);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 2 exit code = %d\n\n"</span>, (<span class="keyword">int</span>)tred);</span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn3, <span class="literal">NULL</span>);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">	pthread_cancel(tid);<span class="comment">//需要到达某个取消点 系统调用</span></span><br><span class="line">	pthread_join(tid, &amp;tred);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 3 exit code = %d\n\n"</span>, (<span class="keyword">int</span>)tred);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>LWP</tag>
      </tags>
  </entry>
  <entry>
    <title>线程属性</title>
    <url>/2020/05/20/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="线程属性结构体"><a href="#线程属性结构体" class="headerlink" title="线程属性结构体"></a>线程属性结构体</h1><pre><code>typedef struct
{
    int                     etachstate;     //线程的分离状态
    int                     schedpolicy;     //线程调度策略
    struct sched_param    schedparam;     //线程的调度参数
    int                     inheritsched;     //线程的继承性
    int                     scope;         //线程的作用域
    size_t                 guardsize;     //线程栈末尾的警戒缓冲区大小
    int                    stackaddr_set; //线程的栈设置
    void*                 stackaddr;     //线程栈的位置
    size_t                 stacksize;     //线程栈的大小
} pthread_attr_t; </code></pre><p>主要结构体成员：<br><strong>1、线程分离状态<br>2、线程栈大小（默认平均分配）<br>3、线程栈警戒缓冲区大小（位于栈末尾）</strong>    </p>
<p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。<br>之后须用pthread_attr_destroy函数来释放资源。</p>
<p>线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</p>
<h2 id="pthread-attr-init函数"><a href="#pthread-attr-init函数" class="headerlink" title="pthread_attr_init函数"></a>pthread_attr_init函数</h2><p>作用：初始化线程属性<br>函数原型：int pthread_attr_init(pthread_attr_t *attr)<br>成功：0,失败：错误号</p>
<h2 id="pthread-attr-destroy"><a href="#pthread-attr-destroy" class="headerlink" title="pthread_attr_destroy"></a>pthread_attr_destroy</h2><p>作用：销毁线程属性所占用的资源<br>函数原型：int pthread_attr_destroy(pthread_attr_t *attr)<br>成功：0，失败：错误号</p>
<h1 id="线程的分离状态"><a href="#线程的分离状态" class="headerlink" title="线程的分离状态"></a>线程的分离状态</h1><p>线程的分离状态决定一个线程以什么样的方式来终止自己。<br><strong>非分离状态</strong>：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。<br><strong>分离状态</strong>：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。<br>线程分离状态的函数：<br>设置线程属性，分离or非分离<br>int <strong>pthread_attr_setdetachstate</strong>(pthread_attr_t <em>attr, int detachstate);<br>获取程属性，分离or非分离<br> int *</em>pthread_attr_getdetachstate<strong>(pthread_attr_t <em>attr, int *detachstate);<br>参数：<br>*</em>attr</strong>：已初始化的线程属性<br><strong>detachstate</strong>：<br>PTHREAD_CREATE_DETACHED（分离线程）<br>PTHREAD _CREATE_JOINABLE（非分离线程）<br><strong>注意</strong>：如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</p>
<h2 id="pthread-deatch函数"><a href="#pthread-deatch函数" class="headerlink" title="pthread_deatch函数"></a>pthread_deatch函数</h2><p>作用：实现线程分离<br>函数原型:int pthread_detach(pthread_t thread)<br>成功：0,失败：错误号</p>
<p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。<br>进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。<br>也可使用 pthread_create函数参2(线程属性)来设置线程分离。</p>
<p><strong>可以通过pthread_detach设置分离状态，也可以通过线程属性设置分离状态</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;//线程分离</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"thread count %d\n"</span>, n);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_exit((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">void</span> *tred;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	<span class="keyword">pthread_attr_t</span> attr;<span class="comment">//通过线程属性来设置游离态</span></span><br><span class="line">	<span class="keyword">int</span> ret = pthread_attr_init(&amp;attr);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_init error:%s\n"</span>, strerror(ret));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">	ret = pthread_creat(&amp;tid, &amp;attr, tfn, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create error:%s\n"</span>, strerror(ret));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_detach(tid);<span class="comment">//线程分离，自动退出，无系统残留资源</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		err = pthread_join(tid, &amp;tred);<span class="comment">//设置分离属性以后，err=22</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"err = %d\n"</span>,err);</span><br><span class="line">		<span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"thread_join error: %s\n"</span>, strerror(err));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"thread exit code %d\n"</span>, (<span class="keyword">int</span>)tred);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>LWP</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程拷贝文件</title>
    <url>/2020/05/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_COUNT 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_BUF 1024</span></span><br><span class="line"><span class="comment">//作为线程创建的参数，包括两个文件的文件描述符和每个线程复制的大小</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd1;</span><br><span class="line">	<span class="keyword">int</span> fd2;</span><br><span class="line">	<span class="keyword">size_t</span> start;</span><br><span class="line">	<span class="keyword">size_t</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_copy</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_block</span> *<span class="title">block</span> = (<span class="title">struct</span> <span class="title">thread_block</span> *)<span class="title">arg</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[THREAD_BUF];</span><br><span class="line">	<span class="keyword">size_t</span> count = block-&gt;start;</span><br><span class="line">	<span class="comment">//打印线程ID和线程复制的起始位置和终点位置</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread id = %lu start = %ld end = %ld\n"</span>, pthread_self(), block-&gt;start, block-&gt;<span class="built_in">end</span>);</span><br><span class="line">	<span class="keyword">int</span> ret = lseek(block-&gt;fd1, block-&gt;start, SEEK_SET);<span class="comment">//将文件指针移到线程复制的起始位置</span></span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"lseek fd1 "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = lseek(block-&gt;fd2, block-&gt;start, SEEK_SET);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"lseek fd2 "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(count &lt; block-&gt;<span class="built_in">end</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">size_t</span> read_size, write_size;</span><br><span class="line">		read_size = <span class="built_in">read</span>(block-&gt;fd1, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="keyword">if</span>(read_size &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			count += read_size;<span class="comment">//加上读到的内容</span></span><br><span class="line">			<span class="keyword">if</span>(read_size == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				perror(<span class="string">"read "</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">char</span> *ptr = buf;<span class="comment">//*</span></span><br><span class="line">			<span class="keyword">do</span><span class="comment">//避免一次性不能写完全</span></span><br><span class="line">			&#123;</span><br><span class="line">				write_size = <span class="built_in">write</span>(block-&gt;fd2, ptr, read_size);</span><br><span class="line">				<span class="keyword">if</span>(write_size == <span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					perror(<span class="string">"write "</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(write_size &gt; <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ptr += write_size;<span class="comment">//*</span></span><br><span class="line">					read_size -= write_size;<span class="comment">//当一次没写完时，使数据减去已写入的数据</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">while</span>(write_size != <span class="number">0</span>);<span class="comment">//当没有数据可写的时候退出</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread exit %lu\n"</span>, pthread_self());</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"./a.out error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd1 = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd1 &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"open file1:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd2 = <span class="built_in">open</span>(argv[<span class="number">2</span>], O_CREAT | O_WRONLY, <span class="number">0664</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd2 &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"open file2:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = fstat(fd1, &amp;st);<span class="comment">//获取文件状态</span></span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"stat "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">size_t</span> file_size = st.st_size;<span class="comment">//获取文件的大小</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_block</span> *<span class="title">blocks</span>;</span></span><br><span class="line">	blocks = (struct thread_block *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct thread_block)* THREAD_COUNT);</span><br><span class="line">	<span class="keyword">size_t</span> percent = file_size/THREAD_COUNT;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"filesize = %ld\t each percent = %ld\n"</span>, file_size, percent);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		blocks[i].fd1 = fd1;</span><br><span class="line">		blocks[i].fd2 = fd2;</span><br><span class="line">		blocks[i].start = i*percent;</span><br><span class="line">		blocks[i].<span class="built_in">end</span> = blocks[i].start + percent;</span><br><span class="line">	&#125;</span><br><span class="line">	blocks[i<span class="number">-1</span>].<span class="built_in">end</span> = file_size;<span class="comment">//最后一份</span></span><br><span class="line">	<span class="keyword">pthread_t</span> tid[THREAD_COUNT];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread_copy, (<span class="keyword">void</span> *)&amp;blocks[i]);</span><br><span class="line">		<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"creat error:%s\n"</span>, strerror(ret));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"join error:%s\n"</span>, strerror(ret));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(blocks);</span><br><span class="line">	ret = <span class="built_in">close</span>(fd1);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"close fd1"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">close</span>(fd2);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"close fd2"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"copy successful\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>LWP</tag>
      </tags>
  </entry>
  <entry>
    <title>树的非递归遍历</title>
    <url>/2020/05/26/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversal</span><span class="params">(TNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TNode *rt = root;</span><br><span class="line">	<span class="built_in">stack</span>&lt;TNode*&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (rt || s.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (rt)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(rt-&gt;rchild);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; rt-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			rt = rt-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		rt = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">(TNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TNode *rt = root;</span><br><span class="line">	<span class="built_in">stack</span>&lt;TNode*&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (rt || s.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (rt)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(rt);</span><br><span class="line">			rt = rt-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		rt = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; rt-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		rt = rt-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><p>因为程序是通过根，右，左遍历，所以最后需要倒置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTraversal</span><span class="params">(TNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TNode *rt = root;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v;</span><br><span class="line">	<span class="built_in">stack</span>&lt;TNode*&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (rt || s.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (rt)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(rt-&gt;lchild);</span><br><span class="line">			v.push_back(rt-&gt;data);</span><br><span class="line">			rt = rt-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		rt = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(v.begin(), v.end());<span class="comment">//倒转v</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = v.begin(); iter != v.end(); iter++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>并发服务器</title>
    <url>/2020/09/05/%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"192.168.44.138"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> n;</span><br><span class="line">        <span class="keyword">while</span>((n = waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG)) &gt; <span class="number">0</span>); </span><br><span class="line"><span class="comment">/*      while(1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                n = waitpid(0, NULL, WNOHANG);</span></span><br><span class="line"><span class="comment">                if(n == -1)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                        perror("waitpid error");</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ];</span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        <span class="comment">//serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span></span><br><span class="line">        inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"client IP :%s, port:%d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">                pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">"fork error"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        Close(lfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                        Close(cfd);</span><br><span class="line">                        signal(SIGCHLD, wait_child);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        n = Read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="comment">//client close</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                Close(cfd);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                perror(<span class="string">"read error"</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                                <span class="built_in">write</span>(cfd, buf, n);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8888</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_info</span>//将地址与<span class="title">cfd</span>捆绑</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> connfd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_work</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> *<span class="title">ts</span> = (<span class="title">struct</span> <span class="title">s_info</span> *)<span class="title">arg</span>;</span></span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                n = Read(ts-&gt;connfd, buf, MAXLINE);</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"the client %d closed \n"</span>, ts-&gt;connfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>, inet_ntop(AF_INET, &amp;(*ts).clie_addr.sin_addr.s_addr, str, <span class="keyword">sizeof</span>(str)), ntohs((*ts).clie_addr.sin_port));</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span> ;i &lt; n ;i++)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                Write(STDOUT_FILENO, buf, n); </span><br><span class="line">                Write(ts-&gt;connfd, buf, n); </span><br><span class="line">        &#125;</span><br><span class="line">        Close(ts-&gt;connfd);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> <span class="title">ts</span>[256];</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(listenfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(listenfd, <span class="number">128</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Acceptint client connect \n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);<span class="comment">//阻塞监听客户端链接请求</span></span><br><span class="line">                ts[i].clie_addr = clie_addr;</span><br><span class="line">                ts[i].connfd = connfd;</span><br><span class="line">                <span class="comment">//达到线程最大时，pthread_create出错处理，增加服务器稳定性</span></span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, do_work, (<span class="keyword">void</span> *)&amp;ts[i]);</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux网络编程基础</title>
    <url>/2020/09/05/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h1><h2 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h2><p>传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p>
<h2 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a>B/S模式</h2><p>浏览器/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p>
<h1 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p><strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。<br><strong>数据链路层</strong>：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。<br><strong>网络层</strong>：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。<br><strong>传输层</strong>：定义了一些传输数据的协议和端口号，如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。<br><strong>会话层</strong>：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。<br><strong>表示层</strong>：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。<br><strong>应用层</strong>：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</p>
<h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h2><p>TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。</p>
<p>TCP是一种面向连接的、可靠的协议，TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。</p>
<p>UDP是无连接的传输协议，不保证可靠性。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。</p>
<h1 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h1><h2 id="数据包封装"><a href="#数据包封装" class="headerlink" title="数据包封装"></a>数据包封装</h2><p>传输层及其以下的机制由内核提供，应用层由用户进程提供，应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装。<br><img src="https://img-blog.csdnimg.cn/20200213122053413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）<br>数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p>
<h2 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213122226138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>源地址和目的地址是指MAC地址，长度48位，是出厂时固化的。<br>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。最大值1500称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片。</p>
<h2 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a>ARP数据报格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213122429235.png#pic_center" alt="在这里插入图片描述"><br>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。</p>
<h2 id="IP段格式"><a href="#IP段格式" class="headerlink" title="IP段格式"></a>IP段格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213122614798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。</p>
<p>对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节为单位的，最小值为5，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。8位TOS字段有3个位用来指定IP数据报的优先级，还有4个位表示可选的服务类型，还有一个位总是0。</p>
<p>总长度是整个数据报（包括IP首部和IP层payload）的字节数。</p>
<p>每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。</p>
<p>3位标志和13位片偏移用于分片。</p>
<p>TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。</p>
<p>协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。</p>
<h2 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213122856215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>TFTP是基于文本的协议<br>UDP首部：源端口号是客户端的端口号。</p>
<p>目的端口号是TFTP服务的well-known端口号。<br>使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。</p>
<p>一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。</p>
<h2 id="TCP数据报格式"><a href="#TCP数据报格式" class="headerlink" title="TCP数据报格式"></a>TCP数据报格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213123238703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。<br>32位序号、32位确认序号、窗口大小稍后详细解释。<br>4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节<br>如果没有选项字段，TCP协议头最短20字节。<br>URG、ACK、PSH、RST、SYN、FIN是六个控制位</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>TCP协议</title>
    <url>/2020/09/05/TCP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="TCP通讯时序"><a href="#TCP通讯时序" class="headerlink" title="TCP通讯时序"></a>TCP通讯时序</h1><p><img src="https://img-blog.csdnimg.cn/20200213153208834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>三次握手<br>1、客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。<br>2、服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。<br>3、客户必须再次回应服务器端一个ACK报文，这是报文段3。<br>数据传输<br>1、客户端发出段4，包含从序号1001开始的20个字节数据。<br>2、服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback。<br>3、客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。<br>四次握手<br>1、客户端发出段7，FIN位表示关闭连接的请求。<br>2、服务器发出段8，应答客户端的关闭连接请求。<br>3、服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。<br>4、客户端发出段10，应答服务器的关闭连接请求。</p>
<h1 id="TCP状态转换图"><a href="#TCP状态转换图" class="headerlink" title="TCP状态转换图"></a>TCP状态转换图</h1><p><img src="https://img-blog.csdnimg.cn/20200213153538726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>CLOSED：表示初始状态。</p>
<p>LISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</p>
<p>SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</p>
<p>SYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</p>
<p>ESTABLISHED：表示连接已经建立。</p>
<p>FIN_WAIT_1: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：</p>
<p>FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。</p>
<p>FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用<br>netstat看到。</p>
<p>FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。</p>
<p>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</p>
<p>CLOSING: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是<br>CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭<br>SOCKET连接。</p>
<p>CLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。</p>
<p>LAST_ACK: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>UDP服务器</title>
    <url>/2020/09/06/UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>UDP不需要在数据传输之前建立、维护连接。只专心获取数据就好。省去了三次握手的过程，通信速度可以大大提高，但与之伴随的通信的稳定性和正确率便得不到保证。</p>
<h1 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C/S模型"></a>C/S模型</h1><p><img src="https://img-blog.csdnimg.cn/20200217112900490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="keyword">int</span> sfd;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="keyword">int</span> i, n;</span><br><span class="line">        sfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        bind(sfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Accepting connections\n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                n = recvfrom(sfd, buf, BUFSIZ, <span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>) </span><br><span class="line">                        perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)), ntohs(clie_addr.sin_port));</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                n = sendto(sfd, buf, n , <span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>) </span><br><span class="line">                perror(<span class="string">"sendto error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> sfd, n;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        sfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;serv_addr.sin_addr);</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        <span class="keyword">while</span>(fgets(buf, BUFSIZ, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                n = sendto(sfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>) </span><br><span class="line">                        perror(<span class="string">"sendto error"</span>);</span><br><span class="line">                n = recvfrom(sfd, buf, BUFSIZ, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//NULL不关心对端</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>) </span><br><span class="line">                        perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">                <span class="built_in">write</span>(STDOUT_FILENO, buf, n); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Socket编程</title>
    <url>/2020/09/05/Socket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200213154454718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。</p>
<h1 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h1><p>TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。如果主机是大端字节序的，发送和接收都不需要做转换。</p>
<h2 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h2><pre><code>#include &lt;arpa/inet.h&gt;
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);</code></pre><h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><pre><code>#include &lt;arpa/inet.h&gt;
int inet_pton(int af, const char *src, void *dst);
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code></pre><h1 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a>网络套接字函数</h1><h2 id="socket模型"><a href="#socket模型" class="headerlink" title="socket模型"></a>socket模型</h2><p><img src="https://img-blog.csdnimg.cn/20200213154852852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int socket(int domain, int type, int protocol);</code></pre><p>domain:<br>AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址<br>AF_INET6 与上面类似，不过是来用IPv6的地址<br>AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</p>
<p>type:<br>SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。<br>SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。<br>SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。<br>SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。<br>SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</p>
<p>protocol:<br>传0 表示使用默认协议。</p>
<p>返回值：<br>成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno</p>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号<br>    #include &lt;sys/types.h&gt;<br>    #include &lt;sys/socket.h&gt;<br>    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>sockfd：<br>socket文件描述符</p>
<p>addr:<br>构造出IP地址加端口号</p>
<p>addrlen:<br>sizeof(addr)长度</p>
<p>返回值：<br>成功返回0，失败返回-1, 设置errno</p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int listen(int sockfd, int backlog);</code></pre><p>sockfd:<br>socket文件描述符</p>
<p>backlog:<br>排队建立3次握手队列和刚刚建立3次握手队列的链接数和</p>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></pre><p>sockdf:<br>socket文件描述符</p>
<p>addr:<br>传出参数，返回链接客户端地址信息，含IP地址和端口号</p>
<p>addrlen:<br>传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小</p>
<p>返回值：<br>成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno</p>
<p>addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。</p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><p>sockdf:<br>socket文件描述符</p>
<p>addr:<br>传入参数，指定服务器端地址信息，含IP地址和端口号</p>
<p>addrlen:<br>传入参数,传入sizeof(addr)大小</p>
<p>返回值：<br>成功返回0，失败返回-1，设置errno</p>
<h1 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ];</span><br><span class="line">        <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line">        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client IP :%s, client port = %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                n = Read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                Write(cfd, buf, n);</span><br><span class="line">        &#125;</span><br><span class="line">        Close(lfd);</span><br><span class="line">        Close(cfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">int</span> cfd, n;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> serv_addr_len;</span><br><span class="line">        cfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        inet_pton(AF_INET, SERV_IP , &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">        Connect(cfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">int</span> r = Write(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"write  %d\n"</span>, r); </span><br><span class="line">                n = Read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"read len %d\n"</span>, n); </span><br><span class="line">                Write(STDOUT_FILENO, buf, n); </span><br><span class="line">        &#125;</span><br><span class="line">        Close(cfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="出错处理封装函数"><a href="#出错处理封装函数" class="headerlink" title="出错处理封装函数"></a>出错处理封装函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        perror(s);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *salenptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//start:</span></span><br><span class="line">                <span class="keyword">if</span> ((n = accept(fd, sa, salenptr)) &lt; <span class="number">0</span>)  </span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line">                                <span class="comment">//goto start;</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                perr_exit(<span class="string">"accept error"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">return</span> n;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> ((n = bind(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">                perr_exit(<span class="string">"bind error"</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        n = <span class="built_in">connect</span>(fd, sa, salen);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)  </span><br><span class="line">        &#123;</span><br><span class="line">                perr_exit(<span class="string">"connect error"</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> ((n = <span class="built_in">listen</span>(fd, backlog)) &lt; <span class="number">0</span>)</span><br><span class="line">                perr_exit(<span class="string">"listen error"</span>);</span><br><span class="line">                        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n; </span><br><span class="line">        <span class="keyword">if</span> ((n = socket(family, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">                perr_exit(<span class="string">"socket error"</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//start:</span></span><br><span class="line">                <span class="keyword">if</span> ( (n = <span class="built_in">read</span>(fd, ptr, nbytes)) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                                <span class="comment">//goto start;</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//start:</span></span><br><span class="line">                <span class="keyword">if</span> ((n = <span class="built_in">write</span>(fd, ptr, nbytes)) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                                <span class="comment">//goto start;</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> ((n = <span class="built_in">close</span>(fd)) == <span class="number">-1</span>)</span><br><span class="line">                perr_exit(<span class="string">"close error"</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*参三: 应该读取的字节数*/</span>                          <span class="comment">//socket 4096  readn(cfd, buf, 4096)   nleft = 4096-1500</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span>  nleft;              <span class="comment">//usigned int 剩余未读取的字节数</span></span><br><span class="line">        <span class="keyword">ssize_t</span> nread;              <span class="comment">//int 实际读到的字节数</span></span><br><span class="line">        <span class="keyword">char</span>   *ptr;</span><br><span class="line">        ptr = vptr;</span><br><span class="line">        nleft = n;                  <span class="comment">//n 未读取字节数</span></span><br><span class="line">        <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> ((nread = <span class="built_in">read</span>(fd, ptr, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                                nread = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                nleft -= nread;   <span class="comment">//nleft = nleft - nread </span></span><br><span class="line">                ptr += nread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> nleft;</span><br><span class="line">        <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line">        ptr = vptr;</span><br><span class="line">        nleft = n;</span><br><span class="line">        <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (nwritten = <span class="built_in">write</span>(fd, ptr, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">                                nwritten = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nleft -= nwritten;</span><br><span class="line">                ptr += nwritten;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">my_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> read_cnt;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> *read_ptr;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> read_buf[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//while(1)</span></span><br><span class="line">                <span class="comment">//&#123;</span></span><br><span class="line">start:</span><br><span class="line">                        <span class="keyword">if</span> ( (read_cnt = <span class="built_in">read</span>(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span>) &#123;   <span class="comment">//"hello\n"</span></span><br><span class="line">                                <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                                        <span class="keyword">goto</span> start;</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//else </span></span><br><span class="line">                        <span class="comment">//      break;</span></span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line">                read_ptr = read_buf;</span><br><span class="line">        &#125;</span><br><span class="line">        read_cnt--;</span><br><span class="line">        *ptr = *read_ptr++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*readline --- fgets*/</span></span><br><span class="line"><span class="comment">//传出参数 vptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Readline</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> n, rc;</span><br><span class="line">        <span class="keyword">char</span>    c, *ptr;</span><br><span class="line">        ptr = vptr;</span><br><span class="line">        <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rc = my_read(fd, &amp;c)) == <span class="number">1</span>)</span><br><span class="line">                &#123;   <span class="comment">//ptr[] = hello\n</span></span><br><span class="line">                        *ptr++ = c;</span><br><span class="line">                        <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        *ptr = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>poll</title>
    <url>/2020/09/06/poll/</url>
    <content><![CDATA[<p>#include &lt;poll.h&gt;<br>    int poll(struct pollfd *fds, nfds_t nfds, int timeout)</p>
<pre><code>struct pollfd {
int fd; /* 文件描述符 /
short events; / 监控的事件 /
short revents; / 监控事件中满足条件返回的事件 */
};</code></pre><p>POLLIN 普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND<br>POLLRDNORM 数据可读<br>POLLRDBAND 优先级带数据可读<br>POLLPRI 高优先级可读数据<br>POLLOUT 普通或带外数据可写<br>POLLWRNORM 数据可写<br>POLLWRBAND 优先级带数据可写<br>POLLERR 发生错误<br>POLLHUP 发生挂起<br>POLLNVAL 描述字不是一个打开的文件<br>nfds 监控数组中有多少文件描述符需要被监控<br>timeout 毫秒级等待<br>-1：阻塞<br>0：立即返回，不阻塞进程<br>.&gt;0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值<br>如果不再监控某个文件描述符时，可以把pollfd中，fd设置为-1，poll不再监控此pollfd，下次返回时，把revents设置为0。</p>
<h1 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ], str[INET_ADDRSTRLEN];<span class="comment">//缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> lfd, cfd, sfd;</span><br><span class="line">        <span class="keyword">int</span> n, maxfd, maxi;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> nready;<span class="comment">//接收poll返回值</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line">    </span><br><span class="line">        client[<span class="number">0</span>].fd = lfd;</span><br><span class="line">        client[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt; OPEN_MAX;i++)</span><br><span class="line">                client[i].fd = <span class="number">-1</span>; </span><br><span class="line">        maxi = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//每次循环都重新设置select监控信号集</span></span><br><span class="line">        &#123;</span><br><span class="line">                nready = poll(client, maxi+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">                        perr_exit(<span class="string">"poll error"</span>);</span><br><span class="line">                <span class="keyword">if</span>(client[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">                &#123;</span><br><span class="line">                        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                        cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);<span class="comment">//不会阻塞</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"client IP :%s, client port = %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">                        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; OPEN_MAX;i++)</span><br><span class="line">                                <span class="keyword">if</span>(client[i].fd &lt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="comment">//保存accept返回的文件描述符</span></span><br><span class="line">                                        client[i].fd = cfd;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        <span class="keyword">if</span>(i == OPEN_MAX)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="built_in">fputs</span>(<span class="string">"too many clients\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        client[i].events = POLLIN;<span class="comment">//设置刚刚返回cfd读</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt; maxi)</span><br><span class="line">                                maxi = i;<span class="comment">//保证maxi存的总是最后一个元素下标</span></span><br><span class="line">                        <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= maxi;i++)<span class="comment">//检测哪个客户端有数据就绪</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span>((sfd = client[i].fd) &lt; <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(client[i].revents &amp; POLLIN)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">if</span>((n = Read(sfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, i);</span><br><span class="line">                                        Close(sfd);<span class="comment">//说明客户端先关闭链接</span></span><br><span class="line">                                        client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                                                buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                                        Write(sfd, buf, n);</span><br><span class="line">                                        Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">if</span>(errno == ECONNRESET)<span class="comment">//收到RST</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                                <span class="built_in">printf</span>(<span class="string">"client[%d] aborted connection\n"</span>, i);</span><br><span class="line">                                                Close(sfd);</span><br><span class="line">                                                client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">else</span></span><br><span class="line">                                                perr_exit(<span class="string">"read error"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Close(lfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>epoll</title>
    <url>/2020/09/06/epoll/</url>
    <content><![CDATA[<p>1、创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。</p>
<pre><code>#include &lt;sys/epoll.h&gt;
int epoll_create(int size)</code></pre><p>size：监听数目</p>
<p>2、控制某个epoll监控的文件描述符上的事件：注册、修改、删除。</p>
<pre><code>#include &lt;sys/epoll.h&gt;
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></pre><p>epfd： 为epoll_creat的句柄<br>op： 表示动作，用3个宏来表示：<br>EPOLL_CTL_ADD (注册新的fd到epfd)，<br>EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，<br>EPOLL_CTL_DEL (从epfd删除一个fd)；<br>event： 告诉内核需要监听的事件</p>
<pre><code>struct epoll_event {
__uint32_t events; /* Epoll events /
epoll_data_t data; / User data variable */
};
typedef union epoll_data {
void *ptr;
int fd;
uint32_t u32;
uint64_t u64;
} epoll_data_t;</code></pre><p>EPOLLIN ： 表示对应的文件描述符可以读（包括对端SOCKET正常关闭）<br>EPOLLOUT： 表示对应的文件描述符可以写<br>EPOLLPRI： 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）<br>EPOLLERR： 表示对应的文件描述符发生错误<br>EPOLLHUP： 表示对应的文件描述符被挂断<br>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的<br>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>
<p>3、等待所监控文件描述符上有事件的产生，类似于select()调用。</p>
<pre><code>#include &lt;sys/epoll.h&gt;
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code></pre><p>events： 用来存内核得到事件的集合，<br>maxevents： 告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，<br>timeout： 是超时时间<br>-1： 阻塞<br>0： 立即返回，非阻塞<br>.&gt;0： 指定毫秒<br>返回值： 成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</p>
<h1 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ], str[INET_ADDRSTRLEN];<span class="comment">//缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> lfd, cfd, sfd;</span><br><span class="line">        <span class="keyword">int</span> n, maxfd, maxi, num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">ssize_t</span> efd, res;</span><br><span class="line">        <span class="keyword">int</span> nready;<span class="comment">//接收poll返回值</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">tep</span>, <span class="title">ep</span>[<span class="title">OPEN_MAX</span>];</span><span class="comment">//tep:epoll_ctl参数 </span></span><br><span class="line">                                                <span class="comment">//ep[]:epoll_wait参数</span></span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">        efd =   epoll_create(OPEN_MAX);</span><br><span class="line">        <span class="keyword">if</span>(efd == <span class="number">-1</span>) </span><br><span class="line">                perr_exit(<span class="string">"epoll create error"</span>);</span><br><span class="line">        tep.events = EPOLLIN;<span class="comment">//设置为读</span></span><br><span class="line">        tep.data.fd = lfd;</span><br><span class="line">        res = epoll_ctl(efd, EPOLL_CTL_ADD, lfd, &amp;tep);<span class="comment">//将lfd设置到树上</span></span><br><span class="line">        <span class="keyword">if</span>(res == <span class="number">-1</span>) </span><br><span class="line">                perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//每次循环都重新设置select监控信号集</span></span><br><span class="line">        &#123;</span><br><span class="line">                nready = epoll_wait(efd, ep, OPEN_MAX, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">                        perr_exit(<span class="string">"poll error"</span>);</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; nready;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!(ep[i].events &amp; EPOLLIN))<span class="comment">//如果不是读，继续循环</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(ep[i].data.fd == lfd)<span class="comment">//判断满足的是不是lfd</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                                cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);<span class="comment">//不会阻塞</span></span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">"client IP :%s, client port = %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">                                tep.events = EPOLLIN;</span><br><span class="line">                                tep.data.fd = cfd;</span><br><span class="line">                                res = epoll_ctl(efd, EPOLL_CTL_ADD, cfd, &amp;tep);</span><br><span class="line">                                <span class="keyword">if</span>(res == <span class="number">-1</span>)</span><br><span class="line">                                        perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                sfd = ep[i].data.fd;</span><br><span class="line">                                <span class="keyword">if</span>((n = Read(sfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        res = epoll_ctl(efd, EPOLL_CTL_DEL, sfd, <span class="literal">NULL</span>);</span><br><span class="line">                                        <span class="keyword">if</span>(res == <span class="number">-1</span>)</span><br><span class="line">                                                perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line"></span><br><span class="line">                                        <span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, i);</span><br><span class="line">                                        Close(sfd);<span class="comment">//说明客户端先关闭链接</span></span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                                                buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                                        Write(sfd, buf, n);</span><br><span class="line">                                        Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">if</span>(errno == ECONNRESET)<span class="comment">//收到RST</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                                res = epoll_ctl(efd, EPOLL_CTL_DEL, sfd, <span class="literal">NULL</span>);</span><br><span class="line">                                                <span class="built_in">printf</span>(<span class="string">"client[%d] aborted connection\n"</span>, i);</span><br><span class="line">                                                Close(sfd);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">else</span></span><br><span class="line">                                                perr_exit(<span class="string">"read error"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Close(lfd);</span><br><span class="line">        Close(efd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>多播（组播）</title>
    <url>/2020/09/06/%E5%A4%9A%E6%92%AD%EF%BC%88%E7%BB%84%E6%92%AD%EF%BC%89/</url>
    <content><![CDATA[<p>组播组可以是永久的也可以是临时的。<br>组播组地址中，有一部分由官方分配的，称为永久组播组。<br>永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。<br>永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。</p>
<p>可以使用ip -ad查看网卡编号<br>可以使用if_nametoindex函数根据网卡名获取网卡序号</p>
<p>224.0.0.0～224.0.0.255 为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；<br>224.0.1.0～224.0.1.255 是公用组播地址，可以用于Internet；欲使用需申请。<br>224.0.2.0～238.255.255.255 为用户可用的组播地址（临时组地址），全网范围内有效；<br>239.0.0.0～239.255.255.255 为本地管理组播地址，仅在特定的本地范围内有效。</p>
<h1 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIE_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">"239.0.0.2"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sfd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">char</span> buf[MAXLINE] = <span class="string">"ahdai\n"</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span></span><br><span class="line">        sfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port =htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        bind(sfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    </span><br><span class="line">        inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);<span class="comment">//设置组地址</span></span><br><span class="line">        inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;group.imr_address);<span class="comment">//本地任意IP</span></span><br><span class="line">        group.imr_ifindex = if_nametoindex(<span class="string">"ens33"</span>);</span><br><span class="line">        setsockopt(sfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;group, <span class="keyword">sizeof</span>(group));<span class="comment">//组播权限</span></span><br><span class="line">        bzero(&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));<span class="comment">//构造 client地址</span></span><br><span class="line">        clie_addr.sin_family = AF_INET;</span><br><span class="line">        inet_pton(AF_INET, GROUP, &amp;clie_addr.sin_addr.s_addr);<span class="comment">//239.0.0.0</span></span><br><span class="line">        clie_addr.sin_port = htons(CLIE_PORT);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(buf, <span class="string">"ahdai %d\n"</span>, i++);</span><br><span class="line">                sendto(sfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIE_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">"239.0.0.2"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">lo_addr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> cfd;</span><br><span class="line">        <span class="keyword">ssize_t</span> len;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span></span><br><span class="line">        cfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;lo_addr, <span class="keyword">sizeof</span>(lo_addr));</span><br><span class="line">        lo_addr.sin_family = AF_INET;</span><br><span class="line">        inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;lo_addr.sin_addr.s_addr);</span><br><span class="line">        lo_addr.sin_port = htons(CLIE_PORT);</span><br><span class="line">        bind(cfd, (struct sockaddr *)&amp;lo_addr, <span class="keyword">sizeof</span>(lo_addr));</span><br><span class="line">        inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);</span><br><span class="line">        inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;group.imr_address);</span><br><span class="line">        group.imr_ifindex = if_nametoindex(<span class="string">"ens33"</span>);</span><br><span class="line">        setsockopt(cfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, <span class="keyword">sizeof</span>(group));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                len = recvfrom(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>); </span><br><span class="line">                <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(cfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>多路I_O转接服务器select</title>
    <url>/2020/09/06/%E5%A4%9A%E8%B7%AFI_O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8select/</url>
    <content><![CDATA[<p>多路IO转接服务器也叫做多任务IO服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件。</p>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>1、select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数<br>2、解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效</p>
<pre><code>#include &lt;sys/select.h
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout)</code></pre><p>nfds: 监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态</p>
<p>readfds： 监控有读数据到达文件描述符集合，传入传出参数</p>
<p>writefds： 监控写数据到达文件描述符集合，传入传出参数</p>
<p>exceptfds： 监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数</p>
<p>timeout： 定时阻塞监控时间，3种情况<br>1、NULL，永远等下去<br>2、设置timeval，等待固定时间<br>3、设置timeval里时间均为0，检查描述字后立即返回，轮<br>struct timeval {<br>long tv_sec; /* seconds /<br>long tv_usec; / microseconds */<br>};</p>
<p>void FD_CLR(int fd, fd_set *set); //把文件描述符集合里fd清0</p>
<p>int FD_ISSET(int fd, fd_set *set); //测试文件描述符集合里fd是否置1</p>
<p>void FD_SET(int fd, fd_set *set); //把文件描述符集合里fd位置1</p>
<p>void FD_ZERO(fd_set *set); //把文件描述符集合里所有位清0</p>
<h2 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ], str[INET_ADDRSTRLEN];<span class="comment">//缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> lfd, cfd, sfd;</span><br><span class="line">        <span class="keyword">int</span> n, maxfd, maxi;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> nready, client[FD_SETSIZE];<span class="comment">//自定义数组,防止便利1024文件描述符</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        fd_set rset, allset;</span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line">    </span><br><span class="line">        maxfd = lfd;<span class="comment">//起初lfd 为最大文件描述符</span></span><br><span class="line">        maxi = <span class="number">-1</span>;<span class="comment">//初始值指向0个元素之前下标位置</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">                client[i] = <span class="number">-1</span>;<span class="comment">//初始化</span></span><br><span class="line">        FD_ZERO(&amp;allset);</span><br><span class="line">        FD_SET(lfd, &amp;allset);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//每次循环都重新设置select监控信号集</span></span><br><span class="line">        &#123;</span><br><span class="line">                rset = allset;</span><br><span class="line">                nready = select(maxfd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">                        perr_exit(<span class="string">"select errpr"</span>);</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(lfd, &amp;rset))<span class="comment">//说明有新的客户端链接请求</span></span><br><span class="line">                &#123;</span><br><span class="line">    </span><br><span class="line">                        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                        cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);<span class="comment">//不会阻塞</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"client IP :%s, client port = %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">                        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; FD_SETSIZE;i++)</span><br><span class="line">                                <span class="keyword">if</span>(client[i] &lt; <span class="number">0</span>)<span class="comment">//找client[i]中没有使用的位置</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="comment">//保存accept返回的文件描述符</span></span><br><span class="line">                                        client[i] = cfd;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        <span class="keyword">if</span>(i == FD_SETSIZE)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="built_in">fputs</span>(<span class="string">"too many clients\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        FD_SET(cfd, &amp;allset);<span class="comment">//向监控文件描述符集添加新的</span></span><br><span class="line">                        <span class="keyword">if</span>(cfd &gt; maxfd)</span><br><span class="line">                                maxfd = cfd;<span class="comment">//select第一个参数</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt; maxi)</span><br><span class="line">                                maxi = i;<span class="comment">//保证maxi存的总是最后一个元素下标</span></span><br><span class="line">                        <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= maxi;i++)<span class="comment">//检测哪个客户端有数据就绪</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span>((sfd = client[i]) &lt; <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(FD_ISSET(sfd, &amp;rset))</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="comment">//当客户端关闭链接时,服务器端也关闭也关闭</span></span><br><span class="line">                                <span class="keyword">if</span>((n = Read(sfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        Close(sfd);</span><br><span class="line">                                        FD_CLR(sfd, &amp;allset);<span class="comment">//解除监控</span></span><br><span class="line">                                        client[i] = <span class="number">-1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                                                buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                                        Write(sfd, buf, n);</span><br><span class="line">                                        Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Close(lfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>尽量以const、enum、inline替换define</title>
    <url>/2020/10/18/%E5%B0%BD%E9%87%8F%E4%BB%A5const%E3%80%81enum%E3%80%81inline%E6%9B%BF%E6%8D%A2define/</url>
    <content><![CDATA[<h1 id="const替换-define"><a href="#const替换-define" class="headerlink" title="const替换#define"></a>const替换#define</h1><p>这个规则也许可以改为“宁可以编译器替换预处理器”，#define不被视作语言的一部分，这正是问题的所在。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure>
<p>记号名称ASPECT_RATIO也许从未被编译器看见，它在编译器开始处理之前就被预处理器移走了，于是这个记号名称并没有进入记号表（symbol table）内。<br>当使用这个常量但是却或者一个编译错误信息时，这个错误信息也许会提到1.653而绝不会提到ASPECT_RATIO。如果这个记号被定义在一个非本人写的头文件内，肯定对1.653毫无概念。而这解决方法便是用const替换#define</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;</span><br></pre></td></tr></table></figure>
<p>作为一个语言常量肯定会被编译器所看到。</p>
<p>值得注意的是class专属变量。为了将常量的作用域限制于class内，必须让它称为class的一个成员，而还需要确保此常量最多只有一份实体，所以必须用static修饰。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//static const int Numturns;//常量声明,位于头文件内</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Numturns = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> scores[Numturns];</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//const int GamePlayer::Numturns = 5;//常量定义，位于实现文件内</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::Numturns;</span><br><span class="line"><span class="comment">//如果程序不需要取Numturns的地址，则可以不用定义</span></span><br></pre></td></tr></table></figure>
<p>我们无法用#define创建一个class专属常量，因为#define并不重视作用域。一旦宏被定义，就在其后的编译过程中有效。这就意味着#define不仅不能用来定义class专属变量，也不能提供任何的封装性。</p>
<h1 id="enum替换-define"><a href="#enum替换-define" class="headerlink" title="enum替换#define"></a>enum替换#define</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gameplayer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123; Numturns = <span class="number">5</span>&#125;;<span class="comment">//令Numturns成为5的一个记号名称</span></span><br><span class="line">	<span class="keyword">int</span> scores[Numturns];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>enum的行为与#define比较相似，例如取一个#define的地址是非法的，同样取一个enum的地址也是非法的。</p>
<h1 id="inline替换-define"><a href="#inline替换-define" class="headerlink" title="inline替换#define"></a>inline替换#define</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>
<p>这样的宏函数有非常多的缺点，必须为所有的实参加上小括号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不需要在函数体内中为参数加上括号。</p>
<p><strong>总结：</strong><br> <strong>1. 对于单纯常量，最好以const对象或enums替换#define。<br> 2. 对于形似函数的宏，最好以inline函数替换#define</strong></p>
]]></content>
  </entry>
  <entry>
    <title>尽可能使用const</title>
    <url>/2020/10/18/%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/</url>
    <content><![CDATA[<h1 id="const-iterator"><a href="#const-iterator" class="headerlink" title="const_iterator"></a>const_iterator</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();</span><br><span class="line">*iter = <span class="number">10</span>;<span class="comment">//没问题，改变的是iter所指的值</span></span><br><span class="line">iter++;<span class="comment">//错误，iter是const,类似于const T*</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator citer = vec.begin();</span><br><span class="line">*citer = <span class="number">10</span>;<span class="comment">//错误，*citer是const</span></span><br><span class="line">citer++;<span class="comment">//没问题，类似于T * const</span></span><br></pre></td></tr></table></figure>
<h1 id="降低客户的错误造成的意外"><a href="#降低客户的错误造成的意外" class="headerlink" title="降低客户的错误造成的意外"></a>降低客户的错误造成的意外</h1><p>例如一个有理数的operator*声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span>……&#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,<span class="keyword">const</span> Rational&amp; rhs)</span><br></pre></td></tr></table></figure>
<p>很多人会疑惑为什么要返回一个const，原因是如果不返回const，客户可以实现以下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Rational a,b,c;</span><br><span class="line">(a * b) = c;<span class="comment">//在a * b的成果上调用operator=</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a * b = c)<span class="comment">//其实只是想做一个比较动作，少输了一个等号</span></span><br></pre></td></tr></table></figure>
<p>如果a和b都是内置类型，这样的代码就是不合法的，将operator*的回传值声明为const则可以预防这个毫无意义的赋值</p>
<h1 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span></span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> text[position];<span class="comment">//const对象</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> text[position];<span class="comment">//non-const对象</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TextBlock的operator[]可以被这么使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tb[<span class="number">0</span>];<span class="comment">//调用non-const TextBlock::operator[]</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ctb[<span class="number">0</span>];<span class="comment">//调用const TextBlock::operator[]</span></span><br><span class="line"></span><br><span class="line">tb[<span class="number">0</span>]=<span class="string">'x'</span>;<span class="comment">//可以，写一个non-const TextBlock</span></span><br><span class="line">ctb[<span class="number">0</span>]=<span class="string">'x'</span>;<span class="comment">//错误，写一个const TextBlock</span></span><br></pre></td></tr></table></figure>
<p>上述的错误只因operator[]的返回类型，错误起因是企图对一个const char&amp;施行赋值动作。</p>
<p>下面有一个很有趣的事情，将operator[]声明为const成员函数却返回一个引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span><span class="comment">//其实并不适当</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> pText[position]</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;<span class="comment">//声明一个常量对象</span></span><br><span class="line"><span class="keyword">char</span>* pc = &amp;cctb[<span class="number">0</span>];<span class="comment">//调用const operator[]取得一个指针指向cctb的数据</span></span><br><span class="line">*pc = <span class="string">'J'</span>;<span class="comment">//cctb现在有了"Jello"的内容</span></span><br></pre></td></tr></table></figure>
<p>看起来没有任何的错误，创建一个常量对象并设以某值，而且只对他调用const成员函数，但你终究还是改变了他的值。所以引用与const相结合需要非常谨慎。<br>如果想修改const成员函数中的内容，成员变量只需要在声明的时候前面加上mutable就可以了。</p>
<h1 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h1><p>假设一个TextBlock内的operator[]不止返回一个指向某个字符的引用，也执行边界检验、志记访问信息、数据完善性检验等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		……<span class="comment">//边界检验</span></span><br><span class="line">		……<span class="comment">//志记数据访问</span></span><br><span class="line">		……<span class="comment">//检验数据完整性</span></span><br><span class="line">		<span class="keyword">return</span> text[position]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> positon)</span><br><span class="line">	&#123;</span><br><span class="line">		……<span class="comment">//边界检验</span></span><br><span class="line">		……<span class="comment">//志记数据访问</span></span><br><span class="line">		……<span class="comment">//检验数据完整性</span></span><br><span class="line">		<span class="keyword">return</span> text[position]</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>const与non-const中有许多重复的代码，也许可以将这些代码移到另一个成员函数，并令两个版本的operator[]调用它，这是可能的，但还是会重复一些代码，比如函数调用、两次return语句等等。<br>我们真正该做的是实现operator[]的机能一次并使用它两次，也就是说令其中的一个调用另一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		……<span class="comment">//边界检验</span></span><br><span class="line">		……<span class="comment">//志记数据访问</span></span><br><span class="line">		……<span class="comment">//检验数据完整性</span></span><br><span class="line">		<span class="keyword">return</span> text[position]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> positon)<span class="comment">//现在只调用const op[]</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将op[]返回值的const转除，为*this加上const,调用const op[]</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">			<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这份代码有两个转型动作，我们准备让non-const operator[]调用其const兄弟，但non-const operator[]内部若只是单纯的调用operator[]，便会递归的调用自己，为了避免无穷的递归，我们必须指出调用的是const operator[]，但c++缺乏直接的语法可以这么做。<br>因此将<em>this从其原型TextBlock&amp;转型为const TextBlock&amp;，然后则是从const operatoe[]的返回值中去除const。<br>*</em>总结**</p>
<p> <strong>1. 将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。<br> 2. 当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
</search>
