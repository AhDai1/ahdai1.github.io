<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux网络编程基础</title>
    <url>/2020/09/05/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h1><h2 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h2><p>传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p>
<h2 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a>B/S模式</h2><p>浏览器/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p>
<h1 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p><strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。<br><strong>数据链路层</strong>：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。<br><strong>网络层</strong>：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。<br><strong>传输层</strong>：定义了一些传输数据的协议和端口号，如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。<br><strong>会话层</strong>：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。<br><strong>表示层</strong>：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。<br><strong>应用层</strong>：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</p>
<h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h2><p>TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。</p>
<p>TCP是一种面向连接的、可靠的协议，TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。</p>
<p>UDP是无连接的传输协议，不保证可靠性。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。</p>
<h1 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h1><h2 id="数据包封装"><a href="#数据包封装" class="headerlink" title="数据包封装"></a>数据包封装</h2><p>传输层及其以下的机制由内核提供，应用层由用户进程提供，应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装。<br><img src="https://img-blog.csdnimg.cn/20200213122053413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）<br>数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p>
<h2 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213122226138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>源地址和目的地址是指MAC地址，长度48位，是出厂时固化的。<br>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。最大值1500称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片。</p>
<h2 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a>ARP数据报格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213122429235.png#pic_center" alt="在这里插入图片描述"><br>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。</p>
<h2 id="IP段格式"><a href="#IP段格式" class="headerlink" title="IP段格式"></a>IP段格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213122614798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。</p>
<p>对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节为单位的，最小值为5，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。8位TOS字段有3个位用来指定IP数据报的优先级，还有4个位表示可选的服务类型，还有一个位总是0。</p>
<p>总长度是整个数据报（包括IP首部和IP层payload）的字节数。</p>
<p>每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。</p>
<p>3位标志和13位片偏移用于分片。</p>
<p>TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。</p>
<p>协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。</p>
<h2 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213122856215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>TFTP是基于文本的协议<br>UDP首部：源端口号是客户端的端口号。</p>
<p>目的端口号是TFTP服务的well-known端口号。<br>使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。</p>
<p>一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。</p>
<h2 id="TCP数据报格式"><a href="#TCP数据报格式" class="headerlink" title="TCP数据报格式"></a>TCP数据报格式</h2><p><img src="https://img-blog.csdnimg.cn/20200213123238703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。<br>32位序号、32位确认序号、窗口大小稍后详细解释。<br>4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节<br>如果没有选项字段，TCP协议头最短20字节。<br>URG、ACK、PSH、RST、SYN、FIN是六个控制位</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>C++多态例子与C语言利用函数指针实现多态</title>
    <url>/2020/05/14/C++%E5%A4%9A%E6%80%81%E4%BE%8B%E5%AD%90%E4%B8%8EC%E8%AF%AD%E8%A8%80%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>本程序解释：诸葛亮交给赵云三个锦囊，三种情况下分别打开不同的锦囊。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TIP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">open_tip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	TIP(<span class="built_in">string</span> from, <span class="built_in">string</span> to)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;from = from;</span><br><span class="line">		<span class="keyword">this</span>-&gt;to = to;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">get_from</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;from;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">get_to</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;to;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> from;</span><br><span class="line">	<span class="built_in">string</span> to;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tip1</span>:</span><span class="keyword">public</span> TIP</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tip1(<span class="built_in">string</span> from, <span class="built_in">string</span> to) :TIP(from, to)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">open_tip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"打开了锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"此锦囊由"</span> &lt;&lt; get_from() &lt;&lt; <span class="string">"写给"</span> &lt;&lt; get_to() &lt;&lt; <span class="string">"的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内容是:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"一到东吴就拜会乔国老"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tip2</span> :</span><span class="keyword">public</span> TIP</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tip2(<span class="built_in">string</span> from, <span class="built_in">string</span> to) :TIP(from, to)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">open_tip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"打开了锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"此锦囊由"</span> &lt;&lt; get_from() &lt;&lt; <span class="string">"写给"</span> &lt;&lt; get_to() &lt;&lt; <span class="string">"的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内容是:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"如果主公乐不思蜀，就谎称曹贼来袭"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tip3</span> :</span><span class="keyword">public</span> TIP</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tip3(<span class="built_in">string</span> from, <span class="built_in">string</span> to) :TIP(from, to)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">open_tip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"打开了锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"此锦囊由"</span> &lt;&lt; get_from() &lt;&lt; <span class="string">"写给"</span> &lt;&lt; get_to() &lt;&lt; <span class="string">"的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内容是:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"如果被孙权追杀，向孙尚香求救"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_tips</span><span class="params">(TIP *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tp-&gt;open_tip();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tip1 *t1 = <span class="keyword">new</span> tip1(<span class="string">"孔明"</span>, <span class="string">"赵云"</span>);</span><br><span class="line">	tip2 *t2 = <span class="keyword">new</span> tip2(<span class="string">"孔明"</span>, <span class="string">"赵云"</span>);</span><br><span class="line">	tip3 *t3 = <span class="keyword">new</span> tip3(<span class="string">"孔明"</span>, <span class="string">"赵云"</span>);</span><br><span class="line">	open_tips(t1);</span><br><span class="line">	open_tips(t2);</span><br><span class="line">	open_tips(t3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//抽象层</span></span><br><span class="line"><span class="comment">//定义一个拆开锦囊方法的类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(TIPS)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//定义锦囊类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tip</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> from[<span class="number">64</span>];<span class="comment">//谁写的</span></span><br><span class="line">	<span class="keyword">char</span> to[<span class="number">64</span>];<span class="comment">//写给谁的</span></span><br><span class="line">	TIPS *tp;<span class="comment">//相当于抽象类的纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//需要一个打开锦囊的架构函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_tip</span><span class="params">(struct tip *tip_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"打开了锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"此锦囊由"</span> &lt;&lt; tip_p-&gt;from &lt;&lt; <span class="string">"写给"</span> &lt;&lt; tip_p-&gt;to &lt;&lt; <span class="string">"的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"内容是："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	tip_p-&gt;tp();<span class="comment">//发生多态现象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供创建锦囊的方法</span></span><br><span class="line"><span class="function">struct tip* <span class="title">Create_tip</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, TIPS *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tip</span> *<span class="title">temp</span> = (<span class="title">struct</span> <span class="title">tip</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">tip</span>));</span></span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(temp-&gt;from, from);</span><br><span class="line">	<span class="built_in">strcpy</span>(temp-&gt;to, to);</span><br><span class="line">	<span class="comment">//给一个回调函数赋值，一般称为注册回调函数</span></span><br><span class="line">	temp-&gt;tp = tp;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供一个销毁锦囊的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(struct tip *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tp != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(tp);</span><br><span class="line">		tp = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现层</span></span><br><span class="line"><span class="comment">//诸葛亮写了三个锦囊</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tip1_func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"一到东吴就拜会乔国老"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tip2_func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"如果主公乐不思蜀，就谎称曹贼来袭"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tip3_func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"如果被孙权追杀，向孙尚香求救"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//业务层</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建出三个锦囊</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tip</span> *<span class="title">tip1</span> = <span class="title">Create_tip</span>("孔明", "赵云", <span class="title">tip1_func</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tip</span> *<span class="title">tip2</span> = <span class="title">Create_tip</span>("孔明", "赵云", <span class="title">tip2_func</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tip</span> *<span class="title">tip3</span> = <span class="title">Create_tip</span>("孔明", "赵云", <span class="title">tip3_func</span>);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//由赵云进行拆锦囊</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"刚刚来到东吴，赵云打开第一个锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	open_tip(tip1);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"刘备乐不思蜀，赵云打开第二个锦囊"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	open_tip(tip2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"孙权大军追杀"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	open_tip(tip3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	destroy(tip1);</span><br><span class="line">	destroy(tip2);</span><br><span class="line">	destroy(tip3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>TCP协议</title>
    <url>/2020/09/05/TCP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="TCP通讯时序"><a href="#TCP通讯时序" class="headerlink" title="TCP通讯时序"></a>TCP通讯时序</h1><p><img src="https://img-blog.csdnimg.cn/20200213153208834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>三次握手<br>1、客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。<br>2、服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。<br>3、客户必须再次回应服务器端一个ACK报文，这是报文段3。<br>数据传输<br>1、客户端发出段4，包含从序号1001开始的20个字节数据。<br>2、服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback。<br>3、客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。<br>四次握手<br>1、客户端发出段7，FIN位表示关闭连接的请求。<br>2、服务器发出段8，应答客户端的关闭连接请求。<br>3、服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。<br>4、客户端发出段10，应答服务器的关闭连接请求。</p>
<h1 id="TCP状态转换图"><a href="#TCP状态转换图" class="headerlink" title="TCP状态转换图"></a>TCP状态转换图</h1><p><img src="https://img-blog.csdnimg.cn/20200213153538726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>CLOSED：表示初始状态。</p>
<p>LISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</p>
<p>SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</p>
<p>SYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</p>
<p>ESTABLISHED：表示连接已经建立。</p>
<p>FIN_WAIT_1: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：</p>
<p>FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。</p>
<p>FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用<br>netstat看到。</p>
<p>FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。</p>
<p>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</p>
<p>CLOSING: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是<br>CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭<br>SOCKET连接。</p>
<p>CLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。</p>
<p>LAST_ACK: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>SIGCHILD信号</title>
    <url>/2020/05/19/SIGCHILD%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="SIGCHILD的产生条件"><a href="#SIGCHILD的产生条件" class="headerlink" title="SIGCHILD的产生条件"></a>SIGCHILD的产生条件</h1><p>1、子进程终止时<br>2、子进程接收到SIGSTOP信号停止时<br>3、子进程处在停止态，接受到SIGCONT后唤醒时</p>
<h1 id="子进程结束status处理方式"><a href="#子进程结束status处理方式" class="headerlink" title="子进程结束status处理方式"></a>子进程结束status处理方式</h1><p>函数原型：pid_t waitpid(pid_t pid, int <em>status, int options)<br>*</em>options：**</p>
<p>WNOHANG：没有子进程结束，立即返回</p>
<p>WUNTRACED：如果子进程由于被停止产生的SIGCHLD，waitpid则立即返回</p>
<p>WCONTINUED：如果子进程由于被SIGCONT唤醒而产生的SIGCHLD，waitpid则立即返回</p>
<p><strong>status：</strong><br>    WIFEXITED(status):子进程正常exit终止，返回真<br>    WEXITSTATUS(status):返回子进程正常退出值<br>    WIFSIGNALED(status):子进程被信号终止，返回真<br>    WTERMSIG(status):返回终止子进程的信号值<br>    WIFSTOPPED(status):子进程被停止，返回真<br>    WSTOPSIG(status):返回停止子进程的信号值<br>    WIFCONTINUED(status):子进程接收到SIGCONT信号继续执行</p>
<h1 id="借助SIGCHILD信号回收子进程"><a href="#借助SIGCHILD信号回收子进程" class="headerlink" title="借助SIGCHILD信号回收子进程"></a>借助SIGCHILD信号回收子进程</h1><p>解释:子进程结束运行，其父进程会收到SIGCHLD信号。该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="comment">//如果用if 在linux内核中，收到多个信号，只会记录一个信号</span></span><br><span class="line">	<span class="comment">//用if的话只会回收其中的某些子进程</span></span><br><span class="line">	<span class="keyword">while</span>((pid = waitpid(<span class="number">0</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"child %d exit %d\n"</span>,pid, WEXITSTATUS(status));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"child %d cancel signal %d\n"</span>,pid, WTERMSIG(status));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">//阻塞SIGCHLD</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">			sys_err(<span class="string">"fork "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(n--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"child ID %d\n"</span>,getpid());</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span> )<span class="comment">//父进程捕捉SIGCHILD信号</span></span><br><span class="line">	&#123;</span><br><span class="line">		struct sigaction act;</span><br><span class="line">		act.sa_handler = do_sig_child;</span><br><span class="line">		sigemptyset(&amp;act.sa_mask);</span><br><span class="line">		act.sa_flags = <span class="number">0</span>;</span><br><span class="line">		sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"parent ID %d\n"</span>, getpid());</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP服务器</title>
    <url>/2020/09/06/UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>UDP不需要在数据传输之前建立、维护连接。只专心获取数据就好。省去了三次握手的过程，通信速度可以大大提高，但与之伴随的通信的稳定性和正确率便得不到保证。</p>
<h1 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C/S模型"></a>C/S模型</h1><p><img src="https://img-blog.csdnimg.cn/20200217112900490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="keyword">int</span> sfd;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="keyword">int</span> i, n;</span><br><span class="line">        sfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        bind(sfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Accepting connections\n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                n = recvfrom(sfd, buf, BUFSIZ, <span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>) </span><br><span class="line">                        perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)), ntohs(clie_addr.sin_port));</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                n = sendto(sfd, buf, n , <span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>) </span><br><span class="line">                perror(<span class="string">"sendto error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> sfd, n;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        sfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;serv_addr.sin_addr);</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        <span class="keyword">while</span>(fgets(buf, BUFSIZ, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                n = sendto(sfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>) </span><br><span class="line">                        perror(<span class="string">"sendto error"</span>);</span><br><span class="line">                n = recvfrom(sfd, buf, BUFSIZ, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//NULL不关心对端</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>) </span><br><span class="line">                        perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">                <span class="built_in">write</span>(STDOUT_FILENO, buf, n); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Socket编程</title>
    <url>/2020/09/05/Socket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200213154454718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。</p>
<h1 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h1><p>TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。如果主机是大端字节序的，发送和接收都不需要做转换。</p>
<h2 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h2><pre><code>#include &lt;arpa/inet.h&gt;
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);</code></pre><h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><pre><code>#include &lt;arpa/inet.h&gt;
int inet_pton(int af, const char *src, void *dst);
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code></pre><h1 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a>网络套接字函数</h1><h2 id="socket模型"><a href="#socket模型" class="headerlink" title="socket模型"></a>socket模型</h2><p><img src="https://img-blog.csdnimg.cn/20200213154852852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int socket(int domain, int type, int protocol);</code></pre><p>domain:<br>AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址<br>AF_INET6 与上面类似，不过是来用IPv6的地址<br>AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</p>
<p>type:<br>SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。<br>SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。<br>SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。<br>SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。<br>SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</p>
<p>protocol:<br>传0 表示使用默认协议。</p>
<p>返回值：<br>成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno</p>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号<br>    #include &lt;sys/types.h&gt;<br>    #include &lt;sys/socket.h&gt;<br>    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>sockfd：<br>socket文件描述符</p>
<p>addr:<br>构造出IP地址加端口号</p>
<p>addrlen:<br>sizeof(addr)长度</p>
<p>返回值：<br>成功返回0，失败返回-1, 设置errno</p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int listen(int sockfd, int backlog);</code></pre><p>sockfd:<br>socket文件描述符</p>
<p>backlog:<br>排队建立3次握手队列和刚刚建立3次握手队列的链接数和</p>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></pre><p>sockdf:<br>socket文件描述符</p>
<p>addr:<br>传出参数，返回链接客户端地址信息，含IP地址和端口号</p>
<p>addrlen:<br>传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小</p>
<p>返回值：<br>成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno</p>
<p>addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。</p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><p>sockdf:<br>socket文件描述符</p>
<p>addr:<br>传入参数，指定服务器端地址信息，含IP地址和端口号</p>
<p>addrlen:<br>传入参数,传入sizeof(addr)大小</p>
<p>返回值：<br>成功返回0，失败返回-1，设置errno</p>
<h1 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ];</span><br><span class="line">        <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line">        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client IP :%s, client port = %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                n = Read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                Write(cfd, buf, n);</span><br><span class="line">        &#125;</span><br><span class="line">        Close(lfd);</span><br><span class="line">        Close(cfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">int</span> cfd, n;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> serv_addr_len;</span><br><span class="line">        cfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        inet_pton(AF_INET, SERV_IP , &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">        Connect(cfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">int</span> r = Write(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"write  %d\n"</span>, r); </span><br><span class="line">                n = Read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"read len %d\n"</span>, n); </span><br><span class="line">                Write(STDOUT_FILENO, buf, n); </span><br><span class="line">        &#125;</span><br><span class="line">        Close(cfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="出错处理封装函数"><a href="#出错处理封装函数" class="headerlink" title="出错处理封装函数"></a>出错处理封装函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        perror(s);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *salenptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//start:</span></span><br><span class="line">                <span class="keyword">if</span> ((n = accept(fd, sa, salenptr)) &lt; <span class="number">0</span>)  </span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line">                                <span class="comment">//goto start;</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                perr_exit(<span class="string">"accept error"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">return</span> n;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> ((n = bind(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">                perr_exit(<span class="string">"bind error"</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        n = <span class="built_in">connect</span>(fd, sa, salen);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)  </span><br><span class="line">        &#123;</span><br><span class="line">                perr_exit(<span class="string">"connect error"</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> ((n = <span class="built_in">listen</span>(fd, backlog)) &lt; <span class="number">0</span>)</span><br><span class="line">                perr_exit(<span class="string">"listen error"</span>);</span><br><span class="line">                        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n; </span><br><span class="line">        <span class="keyword">if</span> ((n = socket(family, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">                perr_exit(<span class="string">"socket error"</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//start:</span></span><br><span class="line">                <span class="keyword">if</span> ( (n = <span class="built_in">read</span>(fd, ptr, nbytes)) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                                <span class="comment">//goto start;</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//start:</span></span><br><span class="line">                <span class="keyword">if</span> ((n = <span class="built_in">write</span>(fd, ptr, nbytes)) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                                <span class="comment">//goto start;</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> ((n = <span class="built_in">close</span>(fd)) == <span class="number">-1</span>)</span><br><span class="line">                perr_exit(<span class="string">"close error"</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*参三: 应该读取的字节数*/</span>                          <span class="comment">//socket 4096  readn(cfd, buf, 4096)   nleft = 4096-1500</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span>  nleft;              <span class="comment">//usigned int 剩余未读取的字节数</span></span><br><span class="line">        <span class="keyword">ssize_t</span> nread;              <span class="comment">//int 实际读到的字节数</span></span><br><span class="line">        <span class="keyword">char</span>   *ptr;</span><br><span class="line">        ptr = vptr;</span><br><span class="line">        nleft = n;                  <span class="comment">//n 未读取字节数</span></span><br><span class="line">        <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> ((nread = <span class="built_in">read</span>(fd, ptr, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                                nread = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                nleft -= nread;   <span class="comment">//nleft = nleft - nread </span></span><br><span class="line">                ptr += nread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> nleft;</span><br><span class="line">        <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line">        ptr = vptr;</span><br><span class="line">        nleft = n;</span><br><span class="line">        <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (nwritten = <span class="built_in">write</span>(fd, ptr, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">                                nwritten = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nleft -= nwritten;</span><br><span class="line">                ptr += nwritten;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">my_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> read_cnt;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> *read_ptr;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> read_buf[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//while(1)</span></span><br><span class="line">                <span class="comment">//&#123;</span></span><br><span class="line">start:</span><br><span class="line">                        <span class="keyword">if</span> ( (read_cnt = <span class="built_in">read</span>(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span>) &#123;   <span class="comment">//"hello\n"</span></span><br><span class="line">                                <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                                        <span class="keyword">goto</span> start;</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//else </span></span><br><span class="line">                        <span class="comment">//      break;</span></span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line">                read_ptr = read_buf;</span><br><span class="line">        &#125;</span><br><span class="line">        read_cnt--;</span><br><span class="line">        *ptr = *read_ptr++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*readline --- fgets*/</span></span><br><span class="line"><span class="comment">//传出参数 vptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Readline</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> n, rc;</span><br><span class="line">        <span class="keyword">char</span>    c, *ptr;</span><br><span class="line">        ptr = vptr;</span><br><span class="line">        <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rc = my_read(fd, &amp;c)) == <span class="number">1</span>)</span><br><span class="line">                &#123;   <span class="comment">//ptr[] = hello\n</span></span><br><span class="line">                        *ptr++ = c;</span><br><span class="line">                        <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        *ptr = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>epoll</title>
    <url>/2020/09/06/epoll/</url>
    <content><![CDATA[<p>1、创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。</p>
<pre><code>#include &lt;sys/epoll.h&gt;
int epoll_create(int size)</code></pre><p>size：监听数目</p>
<p>2、控制某个epoll监控的文件描述符上的事件：注册、修改、删除。</p>
<pre><code>#include &lt;sys/epoll.h&gt;
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></pre><p>epfd： 为epoll_creat的句柄<br>op： 表示动作，用3个宏来表示：<br>EPOLL_CTL_ADD (注册新的fd到epfd)，<br>EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，<br>EPOLL_CTL_DEL (从epfd删除一个fd)；<br>event： 告诉内核需要监听的事件</p>
<pre><code>struct epoll_event {
__uint32_t events; /* Epoll events /
epoll_data_t data; / User data variable */
};
typedef union epoll_data {
void *ptr;
int fd;
uint32_t u32;
uint64_t u64;
} epoll_data_t;</code></pre><p>EPOLLIN ： 表示对应的文件描述符可以读（包括对端SOCKET正常关闭）<br>EPOLLOUT： 表示对应的文件描述符可以写<br>EPOLLPRI： 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）<br>EPOLLERR： 表示对应的文件描述符发生错误<br>EPOLLHUP： 表示对应的文件描述符被挂断<br>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的<br>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>
<p>3、等待所监控文件描述符上有事件的产生，类似于select()调用。</p>
<pre><code>#include &lt;sys/epoll.h&gt;
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code></pre><p>events： 用来存内核得到事件的集合，<br>maxevents： 告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，<br>timeout： 是超时时间<br>-1： 阻塞<br>0： 立即返回，非阻塞<br>.&gt;0： 指定毫秒<br>返回值： 成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</p>
<h1 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ], str[INET_ADDRSTRLEN];<span class="comment">//缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> lfd, cfd, sfd;</span><br><span class="line">        <span class="keyword">int</span> n, maxfd, maxi, num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">ssize_t</span> efd, res;</span><br><span class="line">        <span class="keyword">int</span> nready;<span class="comment">//接收poll返回值</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">tep</span>, <span class="title">ep</span>[<span class="title">OPEN_MAX</span>];</span><span class="comment">//tep:epoll_ctl参数 </span></span><br><span class="line">                                                <span class="comment">//ep[]:epoll_wait参数</span></span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">        efd =   epoll_create(OPEN_MAX);</span><br><span class="line">        <span class="keyword">if</span>(efd == <span class="number">-1</span>) </span><br><span class="line">                perr_exit(<span class="string">"epoll create error"</span>);</span><br><span class="line">        tep.events = EPOLLIN;<span class="comment">//设置为读</span></span><br><span class="line">        tep.data.fd = lfd;</span><br><span class="line">        res = epoll_ctl(efd, EPOLL_CTL_ADD, lfd, &amp;tep);<span class="comment">//将lfd设置到树上</span></span><br><span class="line">        <span class="keyword">if</span>(res == <span class="number">-1</span>) </span><br><span class="line">                perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//每次循环都重新设置select监控信号集</span></span><br><span class="line">        &#123;</span><br><span class="line">                nready = epoll_wait(efd, ep, OPEN_MAX, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">                        perr_exit(<span class="string">"poll error"</span>);</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; nready;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!(ep[i].events &amp; EPOLLIN))<span class="comment">//如果不是读，继续循环</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(ep[i].data.fd == lfd)<span class="comment">//判断满足的是不是lfd</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                                cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);<span class="comment">//不会阻塞</span></span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">"client IP :%s, client port = %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">                                tep.events = EPOLLIN;</span><br><span class="line">                                tep.data.fd = cfd;</span><br><span class="line">                                res = epoll_ctl(efd, EPOLL_CTL_ADD, cfd, &amp;tep);</span><br><span class="line">                                <span class="keyword">if</span>(res == <span class="number">-1</span>)</span><br><span class="line">                                        perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                sfd = ep[i].data.fd;</span><br><span class="line">                                <span class="keyword">if</span>((n = Read(sfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        res = epoll_ctl(efd, EPOLL_CTL_DEL, sfd, <span class="literal">NULL</span>);</span><br><span class="line">                                        <span class="keyword">if</span>(res == <span class="number">-1</span>)</span><br><span class="line">                                                perr_exit(<span class="string">"epoll_ctl error"</span>);</span><br><span class="line"></span><br><span class="line">                                        <span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, i);</span><br><span class="line">                                        Close(sfd);<span class="comment">//说明客户端先关闭链接</span></span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                                                buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                                        Write(sfd, buf, n);</span><br><span class="line">                                        Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">if</span>(errno == ECONNRESET)<span class="comment">//收到RST</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                                res = epoll_ctl(efd, EPOLL_CTL_DEL, sfd, <span class="literal">NULL</span>);</span><br><span class="line">                                                <span class="built_in">printf</span>(<span class="string">"client[%d] aborted connection\n"</span>, i);</span><br><span class="line">                                                Close(sfd);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">else</span></span><br><span class="line">                                                perr_exit(<span class="string">"read error"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Close(lfd);</span><br><span class="line">        Close(efd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>了解C++默默编写并调用哪些函数</title>
    <url>/2020/10/20/%E4%BA%86%E8%A7%A3C++%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>什么时候一个empyt class不再是个empty class呢？<br><strong>当C++处理它之后。</strong><br>如果自己没有声明，编译器就会为它声明一个copy构造函数、一个copy assignment操作符和一个析构函数。如果也没有声明任何的构造函数，编译器也会声明一个default构造函数，这些函数都是public且inline。<br>如果写下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span>&#123;</span>……&#125;;</span><br></pre></td></tr></table></figure>
<p>就好像写下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Empty()&#123;……&#125;;</span><br><span class="line">	Empty(<span class="keyword">const</span> Empty&amp; rhs)&#123;……&#125;;</span><br><span class="line">	~Empty()&#123;……&#125;;</span><br><span class="line">	Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs)&#123;……&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>唯有这些函数被需要的时候，它们才会被编译器创造出来。<br>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Empty e1;<span class="comment">//default构造函数</span></span><br><span class="line">		<span class="comment">//析构函数</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="function">Empty <span class="title">e2</span><span class="params">(e1)</span></span>;<span class="comment">//copy构造函数</span></span><br><span class="line">e2=e1;<span class="comment">//copy assignment操作符</span></span><br></pre></td></tr></table></figure>
<p>default构造函数和析构函数主要是给编译器一个地方来放置base classes和non-static成员变量的构造函数和析构函数。至于copy构造函数只是单纯的将每一个non-static成员变量拷贝到目标对象。</p>
<p>如果编译为class生出copy assignment操作符，行为基本与copy构造函数如出一辙，但一般而言只有当生出的代码合法且有合适机会证明它有意义。<br><strong>如果class中的成员变量有引用或是const变量，编译器则拒绝为class生出operator=。</strong></p>
<p><strong>总结：</strong><br>    <strong>编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符以及析构函数。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>poll</title>
    <url>/2020/09/06/poll/</url>
    <content><![CDATA[<p>#include &lt;poll.h&gt;<br>    int poll(struct pollfd *fds, nfds_t nfds, int timeout)</p>
<pre><code>struct pollfd {
int fd; /* 文件描述符 /
short events; / 监控的事件 /
short revents; / 监控事件中满足条件返回的事件 */
};</code></pre><p>POLLIN 普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND<br>POLLRDNORM 数据可读<br>POLLRDBAND 优先级带数据可读<br>POLLPRI 高优先级可读数据<br>POLLOUT 普通或带外数据可写<br>POLLWRNORM 数据可写<br>POLLWRBAND 优先级带数据可写<br>POLLERR 发生错误<br>POLLHUP 发生挂起<br>POLLNVAL 描述字不是一个打开的文件<br>nfds 监控数组中有多少文件描述符需要被监控<br>timeout 毫秒级等待<br>-1：阻塞<br>0：立即返回，不阻塞进程<br>.&gt;0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值<br>如果不再监控某个文件描述符时，可以把pollfd中，fd设置为-1，poll不再监控此pollfd，下次返回时，把revents设置为0。</p>
<h1 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ], str[INET_ADDRSTRLEN];<span class="comment">//缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> lfd, cfd, sfd;</span><br><span class="line">        <span class="keyword">int</span> n, maxfd, maxi;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> nready;<span class="comment">//接收poll返回值</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line">    </span><br><span class="line">        client[<span class="number">0</span>].fd = lfd;</span><br><span class="line">        client[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt; OPEN_MAX;i++)</span><br><span class="line">                client[i].fd = <span class="number">-1</span>; </span><br><span class="line">        maxi = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//每次循环都重新设置select监控信号集</span></span><br><span class="line">        &#123;</span><br><span class="line">                nready = poll(client, maxi+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">                        perr_exit(<span class="string">"poll error"</span>);</span><br><span class="line">                <span class="keyword">if</span>(client[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">                &#123;</span><br><span class="line">                        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                        cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);<span class="comment">//不会阻塞</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"client IP :%s, client port = %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">                        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; OPEN_MAX;i++)</span><br><span class="line">                                <span class="keyword">if</span>(client[i].fd &lt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="comment">//保存accept返回的文件描述符</span></span><br><span class="line">                                        client[i].fd = cfd;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        <span class="keyword">if</span>(i == OPEN_MAX)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="built_in">fputs</span>(<span class="string">"too many clients\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        client[i].events = POLLIN;<span class="comment">//设置刚刚返回cfd读</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt; maxi)</span><br><span class="line">                                maxi = i;<span class="comment">//保证maxi存的总是最后一个元素下标</span></span><br><span class="line">                        <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= maxi;i++)<span class="comment">//检测哪个客户端有数据就绪</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span>((sfd = client[i].fd) &lt; <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(client[i].revents &amp; POLLIN)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">if</span>((n = Read(sfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, i);</span><br><span class="line">                                        Close(sfd);<span class="comment">//说明客户端先关闭链接</span></span><br><span class="line">                                        client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                                                buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                                        Write(sfd, buf, n);</span><br><span class="line">                                        Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">if</span>(errno == ECONNRESET)<span class="comment">//收到RST</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                                <span class="built_in">printf</span>(<span class="string">"client[%d] aborted connection\n"</span>, i);</span><br><span class="line">                                                Close(sfd);</span><br><span class="line">                                                client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">else</span></span><br><span class="line">                                                perr_exit(<span class="string">"read error"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Close(lfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>mmap</title>
    <url>/2020/05/16/mmap/</url>
    <content><![CDATA[<h1 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h1><p>mmap()函数将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。</p>
<p>mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read(),write()等操作。</p>
<p><strong>函数原型：</strong><br><strong>void * mmap(void * start, size_t length, int port, int flags, int fd, off_t offsize)**</strong></p>
<p>参数的意义：<br><strong>start:</strong> 指向欲映射的内存初始地址，通常设为NULL，代表让系统自动选定地址，映射成功后返回该地址。</p>
<p><strong>length:</strong> 代表将文件中的多大的部分映射到内存。</p>
<p><strong>port:</strong> 映射区域的保护方式<br>PROT_EXEC：映射区域可被执行<br>PROT_READ：映射区域可被读取<br>PROT_WRITE：映射区域可被写入<br>PROT_NONE：映射区域不能存取</p>
<p><strong>flags:</strong> 影响映射区域的各种属性。</p>
<p>在调用mmap()时必须指定MAP_SHARED或MAP_PRIVATE<br>MAP_FIXED：如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。<br>MAP_SHARED：对映射区域的写入数据会复制回文件内，而且允许其它映射文件的进程共享。<br>MAP_PRIVATE：对映射区域的写入操作会产生一个映射文件的复制，即私人的“写时复制”对此区域的任何修改都不会写回原来的文件内容。<br>MAP_ANONYMOUS：建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。<br>MAP_DENYWRITE：只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。<br>MAP_LOCKED：将映射区域锁定住，这表示该区域不会被置换（swap）。</p>
<p><strong>fd:</strong> 要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。</p>
<p><strong>offset:</strong> 文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。<br>返回值：若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(－1)，错误原因存于errno 中。</p>
<h2 id="通过mmap向文件中写数据"><a href="#通过mmap向文件中写数据" class="headerlink" title="通过mmap向文件中写数据"></a>通过mmap向文件中写数据</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	fd = <span class="built_in">open</span>(<span class="string">"mytest.txt"</span>, O_CREAT | O_RDWR ,<span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"open "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = ftruncate(fd, <span class="number">4</span>);<span class="comment">//将文件大小改为4K</span></span><br><span class="line">	<span class="keyword">if</span>(len == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftruncate "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	p = mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(p == MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"mmap "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">strcpy</span>(p, <span class="string">"abc"</span>);<span class="comment">//写数据</span></span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">int</span> ret = munmap(p, <span class="number">4</span>);<span class="comment">//取消映射文件</span></span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"munmap "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="父子进程通过mmap通信"><a href="#父子进程通过mmap通信" class="headerlink" title="父子进程通过mmap通信"></a>父子进程通过mmap通信</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> fd</span><br><span class="line">	<span class="comment">//fd = open("/dev/zero",O_RDWR);//还可以通过系统文件创建映射区</span></span><br><span class="line">	fd = <span class="built_in">open</span>(<span class="string">"temp"</span>, O_CREAT | O_RDWR, <span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"open "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	unlink(<span class="string">"temp"</span>);<span class="comment">//删除临时文件目录项，使之具备被释放的条件</span></span><br><span class="line">	ftruncate(fd, <span class="number">4</span>);</span><br><span class="line">	p = mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_WRITE | PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//p = mmap(NULL, 4, PROT_WRITE | PROT_READ, MAP_PRIVATE, fd, 0);</span></span><br><span class="line">	<span class="keyword">if</span>(p == MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"mmap "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*p = <span class="number">2000</span>;</span><br><span class="line">		var = <span class="number">1000</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child, *p = %d,var = %d\n"</span>,*p,var);<span class="comment">//父子进程拥有不同的全局变量</span></span><br><span class="line">																								<span class="comment">//val值在父进程中还是为100</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);<span class="comment">//确保数据已经被子进程修改</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"parent, *p = %d,var = %d\n"</span>,*p, var);</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">int</span> ret = munmap(p, <span class="number">4</span>);</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"munmap "</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非血缘关系进程间通信"><a href="#非血缘关系进程间通信" class="headerlink" title="非血缘关系进程间通信"></a>非血缘关系进程间通信</h2><p>启动写端程序时，同时打开读端程序，可以看到数据的持续写入</p>
<h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span> = &#123;</span><span class="number">10</span>, <span class="string">"xiaoming"</span>, <span class="string">'m'</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> *<span class="title">mm</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"./a.out file_shared\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">	ftruncate(fd, <span class="keyword">sizeof</span>(student));</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(<span class="string">"file open "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(mm == MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(<span class="string">"mmap "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//通过while(1)持续向文件中写入数据，可以启动读端程序进行读取</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">memcpy</span>(mm, &amp;student, <span class="keyword">sizeof</span>(student));</span><br><span class="line">		student.id++;	</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	munmap(mm, <span class="keyword">sizeof</span>(student));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(<span class="string">"str"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> *<span class="title">mm</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"./a.out file_shared\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(<span class="string">"mmap "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student), PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"id = %d\tname = %s\t %c\n"</span>,mm-&gt;id, mm-&gt;name, mm-&gt;sex);</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	munmap(mm, <span class="keyword">sizeof</span>(student));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>n皇后问题</title>
    <url>/2021/05/11/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="n皇后Ⅰ"><a href="#n皇后Ⅰ" class="headerlink" title="n皇后Ⅰ"></a>n皇后Ⅰ</h1><p>题目：<br>51. N 皇后<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例 1：</p>
<p>输入：n = 4<br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。</p>
<p><strong>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</strong></p>
<h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>①首先记录每行放置的皇后列下标，以此在每一行可行的位置放一个皇后。<br>②通过回溯法进行逐层选择，最终找到每一个皇后的位置，详细注释在代码中</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;<span class="comment">//记录每一种棋盘</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">board</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>))</span></span>;</span><br><span class="line">        <span class="comment">//'.'表示空，'Q'表示皇后</span></span><br><span class="line">        backtrace(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *board中小于row的行已经摆放完成</span></span><br><span class="line"><span class="comment">        *皇后可以放在row行的符合条件的列中</span></span><br><span class="line"><span class="comment">        *当row超过n时则结束   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;board, <span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size() == row)&#123;<span class="comment">//结束条件</span></span><br><span class="line">            ans.emplace_back(board);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = board[row].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(board, row, col))&#123;<span class="comment">//排除不合法的</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[row][col] = <span class="string">'Q'</span>;<span class="comment">//选择</span></span><br><span class="line">            backtrace(board, row + <span class="number">1</span>);<span class="comment">//进入下一层</span></span><br><span class="line">            board[row][col] = <span class="string">'.'</span>;<span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//判断列是否有皇后</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断右上方是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span>&amp;&amp;j &lt; n; i--, j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断左上方是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span>&amp;&amp;j &gt;= <span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="n皇后Ⅱ"><a href="#n皇后Ⅱ" class="headerlink" title="n皇后Ⅱ"></a>n皇后Ⅱ</h1><p>题目：<br>52. N皇后 II<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p>
<p>示例 1：</p>
<p>输入：n = 4<br>输出：2</p>
<p>解释：如上图所示，4 皇后问题存在两个不同的解法。</p>
<h2 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h2><p>只需要把上一题的代码稍作修改就可以得到此题的答案。<br>将记录每一种摆法改成当满足条件以后将结果加一</p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">board</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>))</span></span>;</span><br><span class="line">        backtrace(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;board, <span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size() == row)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = board[row].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(board, row, col))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">            backtrace(board, row + <span class="number">1</span>);</span><br><span class="line">            board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span>&amp;&amp;j &lt; n; i--, j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span>&amp;&amp;j &gt;= <span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>k个一组翻转链表</title>
    <url>/2021/03/30/k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>假设我们要2个一组翻转链表，我们可以看到本问题有递归思想，也就是reverse(head, 2)，而第二个结点后的内容就是子问题，只要解决了原问题，子问题也就迎刃而解了。<br>首先我们先利用迭代来翻转整条链表</p>
<h1 id="翻转一整条链表"><a href="#翻转一整条链表" class="headerlink" title="翻转一整条链表"></a>翻转一整条链表</h1><p>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;nullptr<br>可以通过三个指针来控制链表进行翻转<br>1&lt;-2-&gt;3-&gt;4-&gt;5-&gt;nullptr<br>1&lt;-2&lt;-3-&gt;4-&gt;5-&gt;nullptr<br>以此往下，改变每一个结点的指向。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">reverse</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *pre, *cur, *nxt;</span><br><span class="line">    pre = <span class="literal">nullptr</span>; cur = head; nxt = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        nxt = cur.next;        </span><br><span class="line">        cur.next = pre；</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="翻转a-b结点"><a href="#翻转a-b结点" class="headerlink" title="翻转a~b结点"></a>翻转a~b结点</h1><p>接下来如果我们想翻转前a~b个结点，我们只需要把第b+1个结点看作上方代码最后一个结点指向的空值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseab</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *pre,*cur,*nxt;</span><br><span class="line">        pre=<span class="literal">nullptr</span>;</span><br><span class="line">        cur=a;</span><br><span class="line">        nxt=a;</span><br><span class="line">        <span class="keyword">while</span>(cur != b)&#123;</span><br><span class="line">            nxt=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>只需要把nullptr编程b结点即可。</p>
<h1 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a>k个一组翻转链表</h1><p>我们只需要利用上述代码，在翻转完前k个结点以后，递归调用本身，继续翻转k+1~2k这个部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *a, *b;</span><br><span class="line">        a=b=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            b=b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newHead = reverseab(a,b);<span class="comment">//翻转后的新头结点</span></span><br><span class="line">        a-&gt;next=reverseKGroup(b,k);<span class="comment">//递归调用本身</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>信封嵌套问题</title>
    <url>/2021/04/15/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。注意：不允许旋转信封。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p>输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]<br>输出：3<br>解释：最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</p>
<h1 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h1><p>输入：envelopes = [[1,1],[1,1],[1,1]]<br>输出：1</p>
<h1 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h1><p>①首先我们可以想到外面的信封高和宽一定都比里面的信封的高和宽要大。<br>②这样就可以想到我们将信封进行排序，然后来找最长递增子序列。<br>③然而这样有一个问题，信封应该按怎么样的顺序排序。是按宽的升序排序还是按高的升序排序？<br>我们可以举个例子：<br>这五封信封应该怎么嵌套，才能保证信封最多？[1, 8],[2, 3],[5, 2],[5, 4],[6, 4],[6. 7]<br>[1, 8]</p>
<p>[2, 3]</p>
<p>[5, 4]</p>
<p>[5, 2]</p>
<p>[6, 7]</p>
<p>[6. 4]<br>这三个信封能保证信封嵌套最多[2, 3]，[5, 4]，[6, 7]。我们可以发现，按照信封的宽进行升序排序，按信封的高进行降序排序。<br>按宽进行升序可以很容易理解，因为外面的信封一定要比里面的信封大，而按高的降序则是因为要保证相同宽的信封只能选择一个。<br>④在排完序以后就可以进行对高进行最长递增子序列查找。<br>⑤对于LIS本题是利用二分法进行。</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = envelopes.size();</span><br><span class="line">        sort(envelopes.begin(), envelopes.end(),</span><br><span class="line">            [&amp;](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">0</span>] &lt; b[<span class="number">0</span>])&#123;<span class="comment">//第一关键字，宽的升序</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>] &gt; b[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];<span class="comment">//第二关键字，高的降序</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">height</span><span class="params">(n,<span class="number">0</span>)</span></span>;<span class="comment">//信封的高单独用一个vetcor存</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            height[i] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lengthLis(height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthLis</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//最长递增子序列长度</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">top</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//对每个元素找到相应的位置</span></span><br><span class="line">            <span class="keyword">int</span> key = nums[i];</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> right = len;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;<span class="comment">//二分</span></span><br><span class="line">                <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(top[mid] &gt;= key)&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left == len)&#123;<span class="comment">//如果该元素已经比所有已找到的递增子序列还要大，</span></span><br><span class="line">               len++;       <span class="comment">//则将该元素放到最后，并将len++</span></span><br><span class="line">            &#125;</span><br><span class="line">            top[left] = key;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>利用分治法寻找第k大的数</title>
    <url>/2021/04/21/%E5%88%A9%E7%94%A8%E5%88%86%E6%B2%BB%E6%B3%95%E5%AF%BB%E6%89%BE%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="数组中的第k的最大元素"><a href="#数组中的第k的最大元素" class="headerlink" title="数组中的第k的最大元素"></a>数组中的第k的最大元素</h1><p>题目：<br>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p>
<h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>①首先我们我们知道快速排序是基于分治法，每一次都将基准放到相应的位置使基准数左边的数都比基准数小，右边的数都比基准数大。<br>②而本题正好可以利用快速排序的思想，逐步找到k这个位置，进而这个位置即答案</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//升序</span></span><br><span class="line">        <span class="keyword">int</span> key=nums[l];<span class="comment">//基准数</span></span><br><span class="line">        <span class="keyword">int</span> start=l;</span><br><span class="line">        <span class="keyword">int</span> end=r;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;<span class="comment">//******如果想要找到第K小的数******//</span></span><br><span class="line">			<span class="comment">//******就把下面&lt;=key的符号变成&gt;=key******//</span></span><br><span class="line">            <span class="keyword">while</span>(start&lt;=end&amp;&amp;nums[start]&lt;=key) start++;<span class="comment">//找到比基准数大的</span></span><br><span class="line">            <span class="keyword">while</span>(start&lt;=end&amp;&amp;nums[end]&gt;=key) end--;<span class="comment">//找到比基准数小的</span></span><br><span class="line">            <span class="keyword">if</span>(start&lt;end)<span class="comment">//将在基准数左边比基准数大的数           </span></span><br><span class="line">            &#123;           <span class="comment">//与在基准数有边比基准数小的数进行交换</span></span><br><span class="line">                swap(nums[start],nums[end]);</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[l],nums[end]);<span class="comment">//将基准数交换到自己的位置</span></span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            index=Partition(nums,left,right);</span><br><span class="line">            <span class="keyword">if</span>(index==( nums.size()-k))&#123;<span class="comment">//因为是升序，如果索引等于倒数第k个数</span></span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index&lt;( nums.size()-k))&#123;<span class="comment">//如果索引小于，则向倒数第k个数靠拢</span></span><br><span class="line">                left=index+<span class="number">1</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index&gt;( nums.size()-k))&#123;<span class="comment">//同上</span></span><br><span class="line">                right=index<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>判断是否回文链表</title>
    <url>/2021/03/30/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h1><p>解答思路：<br>① 首先先找到链表的中间位置。<br>② 将中间位置以后的结点进行翻转。<br>③ 将两个链表从头开始相比，如果每一个结点都相等，则是回文链表。</p>
<h2 id="找到中间结点"><a href="#找到中间结点" class="headerlink" title="找到中间结点"></a>找到中间结点</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">endhalflist</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode *slow,*fast;</span><br><span class="line">        slow=head;</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码代表的是，如果链表结点是奇数，则slow指向的是中间结点，而我们要把slow指向中间结点的下一个。<br>例如：<br>1-&gt;2-&gt;3-&gt;2-&gt;1-&gt;nullptr<br>如果没有这一句判断，那么slow将会指向值为3的这个结点，在后续进行链表比对的时候会出现错误。</p>
<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverselist</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        ListNode *pre,*cur,*nxt;</span><br><span class="line">        pre=<span class="literal">nullptr</span>;cur=head;nxt=head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nxt=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此方法在上两篇文章已经提及，可以参考。</p>
<h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *mid = endhalflist(head);</span><br><span class="line">        mid = reverselist(mid);</span><br><span class="line">        <span class="keyword">while</span>(mid != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val != mid-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            mid=mid-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">endhalflist</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode *slow,*fast;</span><br><span class="line">        slow=head;</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverselist</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        ListNode *pre,*cur,*nxt;</span><br><span class="line">        pre=<span class="literal">nullptr</span>;cur=head;nxt=head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nxt=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="递归判断链表是否回文"><a href="#递归判断链表是否回文" class="headerlink" title="递归判断链表是否回文"></a>递归判断链表是否回文</h1><p>解答思路：<br>将每一个结点压入栈中，然后在弹出的时候进行比对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode *left;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        left=head;</span><br><span class="line">        <span class="keyword">return</span> traverse(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">traverse</span><span class="params">(ListNode *right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> res = traverse(right-&gt;next);</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val != right-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left=left-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>实际上就是一种利用了函数栈的方法。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>全局变量的异步I_O</title>
    <url>/2020/05/18/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%82%E6%AD%A5I_O/</url>
    <content><![CDATA[<p>以一个程序来演示：该程序是父子进程通过一个全局变量进行相互数数。</p>
<h1 id="初级版（存在问题）"><a href="#初级版（存在问题）" class="headerlink" title="初级版（存在问题）"></a>初级版（存在问题）</h1><p>解释:通过flag变量标记程序实行进度。flag置1表示数数完成。flag置0表示给对方发送信号完成。<br>问题出现的位置，在父子进程kill函数之后需要紧接着调用 flag，将其置0，标记信号已经发送。但，在这期间很有可能被kernel调度，失去执行权利，而对方获取了执行时间，通过发送信号回调捕捉函数，从而修改了全局的flag。</p>
<p>程序执行期间会造成程序无法唤醒的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//父子进程相互数数,全局变量的异步IO</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I am child %d\t%d\n"</span>, getpid(), n);</span><br><span class="line">	n += <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	flag = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_parent</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I am parent %d\t%d\n"</span>, getpid(), n);</span><br><span class="line">	n += <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	flag = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//sleep(1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(<span class="string">"fork"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n = <span class="number">1</span>;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		act.sa_handler = do_sig_parent;</span><br><span class="line">		sigemptyset(&amp;act.sa_mask);</span><br><span class="line">		act.sa_flags = <span class="number">0</span>;</span><br><span class="line">		sigaction(SIGUSR2, &amp;act, <span class="literal">NULL</span>);<span class="comment">//注册自己的信号捕捉函数</span></span><br><span class="line">		do_sig_parent(<span class="number">0</span>);		<span class="comment">//父使用SIGUSR2信号</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//等待信号</span></span><br><span class="line">			<span class="keyword">if</span>(flag == <span class="number">1</span>)<span class="comment">//父进程数数完成</span></span><br><span class="line">			&#123;</span><br><span class="line">				kill(pid, SIGUSR1);</span><br><span class="line">			<span class="comment">//----如果失去cpu，已给子进程发信号，此时flag = 1</span></span><br><span class="line">			<span class="comment">//子进程数完后给父进程发信号，数完之后，获得cpu</span></span><br><span class="line">			<span class="comment">//标志flag = 0,子进程已经发过信号，都在等待信号</span></span><br><span class="line">			<span class="comment">//所以flag一直会等于0 ，程序停止</span></span><br><span class="line">			<span class="comment">//在子进程同样位置有此时间空档情况</span></span><br><span class="line">				flag = <span class="number">0</span>;<span class="comment">//标志已给子进程发送完信号</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n = <span class="number">2</span>;</span><br><span class="line">		act.sa_handler = do_sig_child;</span><br><span class="line">		sigemptyset(&amp;act.sa_mask);</span><br><span class="line">		act.sa_flags = <span class="number">0</span>;</span><br><span class="line">		sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>);<span class="comment">//父进程数数完成发送SIGUSR1</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)			<span class="comment">//给子进程</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//等待信号</span></span><br><span class="line">			<span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				kill(getppid(), SIGUSR2);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完善版"><a href="#完善版" class="headerlink" title="完善版"></a>完善版</h1><p>通过在信号处理函数中父进程（子进程）数完数以后发送信号给子进程（父进程），避免了程序无法唤醒的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//父子进程交替数数升级版</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>, num1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pid_t</span> son_pid;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"parent\tnum = %d\n"</span>,num1);</span><br><span class="line">	num1 += <span class="number">2</span>;</span><br><span class="line">	kill(son_pid, SIGUSR2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child\tnum = %d\n"</span>, num);</span><br><span class="line">	num += <span class="number">2</span>;</span><br><span class="line">	kill(getppid(), SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act1</span>, <span class="title">act2</span>;</span></span><br><span class="line">	pid = fork();</span><br><span class="line">	son_pid = pid;</span><br><span class="line">	<span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		act1.sa_handler = parent;</span><br><span class="line">		sigemptyset(&amp;act1.sa_mask);</span><br><span class="line">		act1.sa_flags = <span class="number">0</span>;</span><br><span class="line">		sigaction(SIGUSR1, &amp;act1, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);<span class="comment">//让父进程先注册捕获函数</span></span><br><span class="line">		act2.sa_handler = child;</span><br><span class="line">		sigemptyset(&amp;act2.sa_mask);</span><br><span class="line">		act2.sa_flags = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> ret = sigaction(SIGUSR2, &amp;act2, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perr(<span class="string">"sigaction error"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		kill(getppid(), SIGUSR1);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		perr(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>信号</title>
    <url>/2020/05/17/%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="信号的机制和特点"><a href="#信号的机制和特点" class="headerlink" title="信号的机制和特点"></a>信号的机制和特点</h1><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><p>A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。</p>
<p>与硬件中断类似——异步模式。但信号是软件层面上实现的中断，常被称为“软中断”。</p>
<p>信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。</p>
<p><strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、简单<br>2、不能携带大量信息<br>3、满足某个特设条件才发送</p>
<h1 id="信号四要素"><a href="#信号四要素" class="headerlink" title="信号四要素"></a>信号四要素</h1><p>1、编号<br>2、名称<br>3、事件<br>4、默认处理动作<br>默认动作：<br>    Term：终止进程<br>    Ign： 忽略信号 (默认即时对该种信号忽略操作)<br>    Core：终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试)<br>    Stop：停止（暂停）进程<br>    Cont：继续运行进程<br><strong>9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</strong></p>
<h1 id="与信号相关的事件"><a href="#与信号相关的事件" class="headerlink" title="与信号相关的事件"></a>与信号相关的事件</h1><h2 id="递达和未决"><a href="#递达和未决" class="headerlink" title="递达和未决"></a>递达和未决</h2><h3 id="递达"><a href="#递达" class="headerlink" title="递达"></a>递达</h3><p>递达并且到达进程</p>
<h3 id="未决"><a href="#未决" class="headerlink" title="未决"></a>未决</h3><p>产生和递达之间的状态，主要由于阻塞（屏蔽）导致该状态</p>
<h4 id="阻塞信号集（信号屏蔽字）"><a href="#阻塞信号集（信号屏蔽字）" class="headerlink" title="阻塞信号集（信号屏蔽字）"></a>阻塞信号集（信号屏蔽字）</h4><p>将某些信号加入集合，对他们设置屏蔽，当屏蔽某信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)</p>
<h4 id="未决信号集"><a href="#未决信号集" class="headerlink" title="未决信号集"></a>未决信号集</h4><p>1、信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。<br>2、信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。   </p>
<h1 id="信号的处理方式"><a href="#信号的处理方式" class="headerlink" title="信号的处理方式"></a>信号的处理方式</h1><p>第一种是类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理。</p>
<p>第二种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。</p>
<p>第三种方法是，对该信号的处理保留系统的默认值，这种缺省操作，对大部分的信号的缺省操作是使得进程终止。进程通过系统调用signal来指定进程对某个信号的处理行为。</p>
<h1 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h1><p>1、按键产生，如：Ctrl+c、Ctrl+z、Ctrl+<br>2、系统调用产生，如：kill、raise、abort<br>3、软件条件产生，如：定时器alarm<br>4、硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)<br>5、命令产生，如：kill命令</p>
<h2 id="kill函数-命令产生信号"><a href="#kill函数-命令产生信号" class="headerlink" title="kill函数/命令产生信号"></a>kill函数/命令产生信号</h2><p>kill命令产生信号：kill -SIGKILL pid<br>kill函数：给指定进程发送指定信号(<strong>不一定杀死</strong>)<br>函数原型：int kill(pid_t pid, int sig)   成功：0；失败：-1 (ID非法，信号非法，普通用户杀init进程等权级问题)，设置errno</p>
<p>sig：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。<br>pid &gt; 0:  发送信号给指定的进程。<br>pid = 0:  发送信号给 与调用kill函数进程属于同一进程组的所有进程。<br>pid &lt; 0:  取|pid|发给对应进程组。<br>pid = -1：发送给进程有权限发送的系统中所有进程。</p>
<p>进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</p>
<p>权限保护：super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的<br>例如kill -9 (root用户的pid)  是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。普通用户基本规则是：发送者实际或有效用户ID等于接收者实际或有效用户ID</p>
<h2 id="raise和abort函数"><a href="#raise和abort函数" class="headerlink" title="raise和abort函数"></a>raise和abort函数</h2><p>raise 函数：给当前进程发送指定信号(自己给自己发)    <strong>raise(signo) == kill(getpid(), signo)</strong><br>函数原型：int raise(int sig)  成功：0，失败非0值</p>
<p>abort 函数：给自己发送异常终止信号 6) SIGABRT 信号，终止并产生core文件<br>函数原型：void abort(void)  该函数无返回</p>
<h2 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h2><p>作用：设置定时器(闹钟)<br>在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。</p>
<p><strong>每个进程都有且只有唯一个定时器。</strong></p>
<p>函数原型：unsigned int alarm(unsigned int seconds) 返回0或剩余的秒数，无失败。<br><strong>常用：取消定时器使用alarm(0)，返回旧闹钟余下秒数。</strong><br>定时，与进程状态无关(自然定时法)，就绪、运行、挂起(阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm都计时。<br>使用time命令查看程序执行的时间。    </p>
<p><strong>程序运行的瓶颈在于IO，优化程序，首选优化IO。</strong><br>实际执行时间 = 系统时间 + 用户时间 + 等待时间</p>
<h2 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h2><p>作用：设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。<br>函数原型：int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value)    成功：0；失败：-1，设置errno</p>
<p>参数<br>which：指定定时方式<br>1、自然定时：ITIMER_REAL → 14）SIGLAR——计算自然时间<br>2、虚拟空间计时(用户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM——只计算进程占用cpu的时间<br>3、运行时计时(用户+内核)：ITIMER_PROF → 27）SIGPROF——计算占用cpu及执行系统调用的时间</p>
<p><strong>it_interval：用来设定两次定时任务之间间隔的时间<br>it_value：定时的时长<br>两个参数都设置为0，即清0操作。</strong></p>
<h3 id="setitimer函数实现alarm函数，实现计算机1秒数数程序。"><a href="#setitimer函数实现alarm函数，实现计算机1秒数数程序。" class="headerlink" title="setitimer函数实现alarm函数，实现计算机1秒数数程序。"></a>setitimer函数实现alarm函数，实现计算机1秒数数程序。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	struct itimerval </span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		struct timeval</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			it_value.tv_sec;</span></span><br><span class="line"><span class="comment">			it_value.tv_usec;	</span></span><br><span class="line"><span class="comment">		&#125;it_interval;//用来设定两次定时任务之间间隔的时间</span></span><br><span class="line"><span class="comment">		struct timeval</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			it_value.tv_sec;</span></span><br><span class="line"><span class="comment">			it_value.tv_usec;	</span></span><br><span class="line"><span class="comment">		&#125;it_value;//定时的时长</span></span><br><span class="line"><span class="comment">	&#125;it, oldit;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">my_alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> sec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	it.it_value.tv_sec = sec;</span><br><span class="line">	it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">	it.it_interval.tv_sec = <span class="number">0</span>;<span class="comment">//两次定时之间的间隔</span></span><br><span class="line">	it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">	ret = setitimer(ITIMER_REAL, &amp;it, &amp;oldit);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"setitimer\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> oldit.it_value.tv_sec;<span class="comment">//返回剩余的秒数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	my_alarm(<span class="number">1</span>);<span class="comment">//alarm(1);</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用setitimer函数的参数实现定时间隔"><a href="#利用setitimer函数的参数实现定时间隔" class="headerlink" title="利用setitimer函数的参数实现定时间隔"></a>利用setitimer函数的参数实现定时间隔</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">	signal(SIGALRM, myfunc);<span class="comment">//注册SIGALRM信号的捕捉处理函数</span></span><br><span class="line">	it.it_value.tv_sec = <span class="number">5</span>;</span><br><span class="line">	it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">	it.it_interval.tv_sec = <span class="number">3</span>;</span><br><span class="line">	it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(setitimer(ITIMER_REAL, &amp;it, &amp;oldit) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"setitimer error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h1><p>内核通过读取未决信号集来判断信号是否应被处理<br>信号屏蔽字mask可以影响未决信号集。而我们可以在应用程序中自定义set来改变mask。已达到屏蔽指定信号的目的。</p>
<h2 id="信号集设定函数"><a href="#信号集设定函数" class="headerlink" title="信号集设定函数"></a>信号集设定函数</h2><p>sigset_t  set;        // typedef unsigned long sigset_t;<br>int sigemptyset(sigset_t *set)：将某个信号集清0<br>成功：0，失败：-1</p>
<p>int sigfillset(sigset_t *set)：将某个信号集置1<br>成功：0，失败：-1</p>
<p>int sigaddset(sigset_t *set, int signum)：将某个信号加入信号集<br>成功：0，失败：-1</p>
<p>int sigdelset(sigset_t *set, int signum)    ：将某个信号清出信号集<br>成功：0，失败：-1</p>
<p>int sigismember(const sigset_t *set, int signum)：判断某个信号是否在信号集中<br>返回值：在集合：1，不在：0，出错：-1  </p>
<p><strong>sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</strong></p>
<h2 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h2><p>用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB中)<br><strong>严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。</strong><br>函数原型：int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)    成功：0，失败：-1，设置errno<br>参数：<br>set：传入参数，是一个位图，set中哪位置1，就表示当前进程屏蔽哪个信号。oldset：传出参数，保存旧的信号屏蔽集。<br>how参数取值：假设当前的信号屏蔽字为mask。<br>1、SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask = mask|set<br>2、SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask = mask &amp;~set<br>3、SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于 mask = set，若调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</p>
<h2 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h2><p>读取当前进程的未决信号集<br>函数原型：int sigpending(sigset_t *set)    set传出参数。<br>返回值：成功：0，失败：-1，设置errno</p>
<h2 id="所有常规信号的未决状态打印至屏幕"><a href="#所有常规信号的未决状态打印至屏幕" class="headerlink" title="所有常规信号的未决状态打印至屏幕"></a>所有常规信号的未决状态打印至屏幕</h2><p>解释：在程序执行过程中使用终端按键产生信号观察未决信号集的变化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printped</span><span class="params">(<span class="keyword">sigset_t</span> *ped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++)<span class="comment">//打印前31个未决信号集</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">if</span>(sigismember(ped, i) == <span class="number">1</span>)<span class="comment">//判断是否处于未决状态</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">sigset_t</span> myset, oldset, ped;</span><br><span class="line">	sigemptyset(&amp;myset);<span class="comment">//将myset置为空</span></span><br><span class="line">	sigaddset(&amp;myset, SIGQUIT);<span class="comment">//将三个信号添加到信号集中</span></span><br><span class="line">	sigaddset(&amp;myset, SIGINT);</span><br><span class="line">	sigaddset(&amp;myset, SIGTSTP);</span><br><span class="line">	<span class="keyword">int</span> ret = sigprocmask(SIG_BLOCK, &amp;myset, &amp;oldset);<span class="comment">//设置屏蔽信号</span></span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"sigprocmask error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sigpending(&amp;ped);</span><br><span class="line">		printped(&amp;ped);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h1><h2 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h2><p>作用：注册一个信号捕捉函数<br>typedef void (<em>sighandler_t)(int);<br>sighandler_t signal(int signum, sighandler_t handler);<br>*</em>该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。**</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catchsigint</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;catch\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">__sighandler_t</span> handler;</span><br><span class="line">	handler = signal(SIGINT, catchsigint);<span class="comment">//捕捉SIGINT信号</span></span><br><span class="line">	<span class="comment">//当接收到SIGINT信号时，执行信号捕捉函数</span></span><br><span class="line">	<span class="keyword">if</span>(handler == SIG_ERR)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"signal error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h2><p>作用：修改信号处理动作（通常在Linux用其来注册一个信号的捕捉函数）<br>函数原型:int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)<br>成功：0；失败：-1，设置errno</p>
<p>参数：<br>act：传入参数，新的处理方式。<br>oldact：传出参数，旧的处理方式。</p>
<p>struct sigaction结构体<br>struct sigaction {<br>    void     (<em>sa_handler)(int);<br>    void     (</em>sa_sigaction)(int, siginfo_t <em>, void *);<br>    sigset_t   sa_mask;<br>    int       sa_flags;<br>    void     (</em>sa_restorer)(void);<br>};<br>sa_restorer：该元素是过时的，不应该使用，POSIX.1标准将不指定该元素。(弃用)<br>sa_sigaction：当sa_flags被指定为SA_SIGINFO标志时，使用该信号处理程序。(很少使用)<br>1、sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作<br>2、sa_mask: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。<strong>注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</strong><br>3、sa_flags：通常设置为0，表使用默认属性。    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">docatch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d signal is catched\n"</span>,signo);</span><br><span class="line">	<span class="comment">//在此期间SIGQUIT信号被屏蔽，等到睡晚10秒以后SIGQUIT信号会被执行一次</span></span><br><span class="line">	sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">	act.sa_handler = docatch;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	sigaddset(&amp;act.sa_mask, SIGQUIT);</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;<span class="comment">//使用默认属性 信号捕捉函数执行期间，屏蔽本信号</span></span><br><span class="line">	<span class="keyword">int</span> ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"sigaction error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//sleep(5);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>区间调度问题</title>
    <url>/2021/04/19/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h1><p>题目：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意:</p>
<p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。<br>示例 1:</p>
<p>输入: [ [1,2], [2,3], [3,4], [1,3] ]</p>
<p>输出: 1</p>
<p>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
<h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>①题目的意思是找到重叠的区域，把它去除，则可以得到不重叠的区域，我们可以反着来，找到了不重叠的区域不就找到了需要移除区间的个数。<br>②可能我们可以找区间中开始最早的那个区间，但是这可能存在某些区间很早，但是该区间很长，则会忽略掉很多短的区间。<br>③所以我们先从区间集合中选出一个区间x，这个x是在所有区间中结束最早的，然后把所有与x区间相交的区间去掉，重复这一条则可以找到没有重叠的区间。<br>④需要先将集合按结束时间进行升序排序，则与x相交的区间必定开始时间小于等于x的结束时间。<br>⑤将区间集合总数减去不重叠的区间则得到需要移除区间的最小数量。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(),[]</span><br><span class="line">            (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];<span class="comment">//集合按结束时间升序排序</span></span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;<span class="comment">//无论怎样都会有一个不重叠的区间</span></span><br><span class="line">        <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];<span class="comment">//x结束时间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = intervals[i][<span class="number">0</span>];<span class="comment">//开始时间</span></span><br><span class="line">            <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.size() - count;<span class="comment">//区间总数-不重叠区间数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="用最少数量的剪引爆气球"><a href="#用最少数量的剪引爆气球" class="headerlink" title="用最少数量的剪引爆气球"></a>用最少数量的剪引爆气球</h1><p>题目：<br>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p>示例 1：</p>
<p>输入：points = [[10,16],[2,8],[1,6],[7,12]]<br>输出：2<br>解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</p>
<h2 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h2><p>①本题的意思是，用一支箭在x轴方向射，只要碰到了气球，则气球会爆炸，求至少需要几支箭。<br>②同样这是一题求不重叠区间的数量，只要求出不重叠区间的个数不就求出了箭的数量。<br>③但要注意的是本题在区间相邻的时候，也算是重叠，即只需要一支箭就可以。</p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(points.begin(), points.end(),[]</span><br><span class="line">            (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];<span class="comment">//按区间右端点升序排序</span></span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = points[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(start &gt; end)&#123;<span class="comment">//***注意：因为题目要求相邻也相当于重叠所以不需要等于*****</span></span><br><span class="line">                count++;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划解0-1背包问题</title>
    <url>/2021/05/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A30-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个可装载重量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为val[i]，现在让你用这个背包装物品，最多能装的价值是多少？</p>
<p>举个简单的例子，输入如下：</p>
<p>N = 3, W = 4<br>wt = [2, 1, 3]<br>val = [4, 2, 3]<br>算法返回 6，选择前两件物品装进背包，总重量 3 小于W，可以获得最大价值 6。</p>
<h1 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h1><p>①首先我们想到背包问题的状态有两个，一个是背包的容量，一个是可选择的物品。<br>②选择就是装进背包与不装进背包。<br>③接下来就是要明白dp[i][w]的含义，比如dp[3][5]=6就是代表对于给定的一系列物品中，若只对前三个物品进行选择，当背包容量为5的时候最多可以装下价值为6。<br>④根据以上，可以知道最终结果就是dp[N][W]，base case就是dp[0][…]=0,dp[…][0]=0。因为没有物品活背包没有空间的时候，能装的最大价值为0。<br>⑤当选择不装进背包时dp[i][w]=dp[i-1][w]，不装就等于继承之前的结果。<br>⑥当选择装入背包时dp[i][w]=max(d[i-1][w], dp[i-1][w-wt[i-1]] + val[i-1])。寻求剩余重量w-wt[i-1]限制能装下的最大价值加上第i个物品的价值。</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; wt, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; val)</span> </span></span><br><span class="line"><span class="function">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前背包容量装不下，只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">                dp[i][w] = max(dp[i - <span class="number">1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], </span><br><span class="line">                               dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>去除重复字母</title>
    <url>/2021/04/15/%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p>输入：s = “bcabc”<br>输出：”abc”</p>
<h1 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h1><p>输入：s = “cbacdcbc”<br>输出：”acdb”</p>
<h1 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h1><p>①首先由题可知，要去除重复字母<br>②去重字符串的相对位置不能改变<br>③去重字符串的字典序保证最小，例如”bcabc”可以去重成”bac”，也可以去重成“abc”而为了保证字典序最小，则需要去重成”abc”<br>④我们可以想到利用栈进行操作，将每一个字母依次入栈，并进行判断，栈内是否存在相同字母，如相同则跳到下一个字母。以及字典序是否小于栈顶元素，将字典序大于目前将要入栈的元素的字母弹出栈，并将当前字母入栈。<br>⑤目前只能保证去重以及位置不变，如果我们按现在的思路，”bcac”经过操作会变成”ac”，而正确答案应该是”bac”，这是因为当我们将a入栈时，判断时将”bc“全部弹出，而这并不是我们想要的<br>⑥解决这个问题其实也很简单，只需要添加一个计数器，首先遍历字符串统计每个字母出现的次数，如果栈内的元素大于将要压栈的元素的字典序，但是字符串只有这一个元素，就不需要进行弹出</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//计数器</span></span><br><span class="line">        <span class="keyword">bool</span> instack[<span class="number">256</span>]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//判断是否在栈中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)&#123;<span class="comment">//统计每个元素出现的次数</span></span><br><span class="line">            count[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)&#123;</span><br><span class="line">            count[c]--;<span class="comment">//每遍历到这个元素，将次数减一</span></span><br><span class="line">            <span class="keyword">if</span>(instack[c])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(!st.empty()&amp;&amp;st.top()&gt;c)&#123;<span class="comment">//判断字典序</span></span><br><span class="line">                <span class="keyword">if</span>(count[st.top()]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                instack[st.top()]=<span class="literal">false</span>;</span><br><span class="line">                st.pop();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            st.push(c);</span><br><span class="line">            instack[c]=<span class="literal">true</span>;<span class="comment">//入栈后将元素标记为栈中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            ans=st.top()+ans;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>利用mmap实现多进程复制文件</title>
    <url>/2020/05/16/%E5%88%A9%E7%94%A8mmap%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>程序将文件分为五部分，四个子进程进行前面的复制工作，父进程进行回收四个子进程，并完成最后的复制工作<br><strong>注意:</strong><br>    1.mmap函数指定的读写方式是对mmap映射区而言的<br>    2.创建映射区的权限要小于等于打开文件的权限，映射区创建过程当中存在一次对文件的读操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"./a.out file "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd1, fd2;</span><br><span class="line">	<span class="keyword">int</span> len, i;</span><br><span class="line">	fd1 = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd1 == <span class="number">-1</span>)</span><br><span class="line">	&#123;		</span><br><span class="line">		perror(<span class="string">"open file1 error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	len = lseek(fd1, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	<span class="keyword">void</span>*mmap_r = mmap(<span class="literal">NULL</span>, len, PROT_READ , MAP_SHARED, fd1, <span class="number">0</span>);<span class="comment">//创建读映射区</span></span><br><span class="line">	<span class="keyword">if</span>(mmap_r == MAP_FAILED)</span><br><span class="line">	&#123;		</span><br><span class="line">		perror(<span class="string">"mmap_r error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fd2 = <span class="built_in">open</span>(argv[<span class="number">2</span>], O_CREAT | O_RDWR, <span class="number">0644</span>);</span><br><span class="line">	<span class="comment">//因为创建映射区会对文件进行一次读操作，所以需要读权限</span></span><br><span class="line">	<span class="keyword">if</span>(fd2 == <span class="number">-1</span>)	</span><br><span class="line">	&#123;		</span><br><span class="line">		perror(<span class="string">"open file2 error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ret = ftruncate(fd2, len);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"ftruncate error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> *mmap_w = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd2, <span class="number">0</span>);<span class="comment">//创建写映射区</span></span><br><span class="line">	<span class="keyword">if</span>(mmap_w == MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"mmap_w error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">//循环创建进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"fork error\n"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> wpid;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">4</span>)<span class="comment">//父进程进行回收子进程，并进行最后的复制工作</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">			<span class="keyword">if</span>(wpid &gt; <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				n--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span>(n);</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w+<span class="number">4</span>*len/<span class="number">5</span>, mmap_r+<span class="number">4</span>*len/<span class="number">5</span>, len<span class="number">-4</span>*len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"parent copy 5th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w, mmap_r, len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"son1 copy 1th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w+i*len/<span class="number">5</span>, mmap_r+i*len/<span class="number">5</span>, len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"son2 copy 2th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w+i*len/<span class="number">5</span>, mmap_r+i*len/<span class="number">5</span>, len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"son3 copy 3th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mmap_w+i*len/<span class="number">5</span>, mmap_r+i*len/<span class="number">5</span>, len/<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"son4 copy 4th successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd1);</span><br><span class="line">	<span class="built_in">close</span>(fd2);</span><br><span class="line">	munmap(mmap_w, len);</span><br><span class="line">	munmap(mmap_r, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>process</tag>
        <tag>mmap</tag>
      </tags>
  </entry>
  <entry>
    <title>填充二叉树的节点的右侧指针</title>
    <url>/2021/05/16/%E5%A1%AB%E5%85%85%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E7%9A%84%E5%8F%B3%E4%BE%A7%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>116.给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。<br>输入：root = [1,2,3,4,5,6,7]<br>输出：[1,#,2,3,#,4,5,6,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，’#’ 标志着每一层的结束。<br><img src="https://img-blog.csdnimg.cn/20210516160913968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h1><p>①根据题意，这是一棵完美二叉树，最终除了右侧节点的next指针会指向null，其余节点的next都会指向右侧相邻的节点。<br>②如果我们只是简单的想将每个节点的左右节点都穿起来就会出现一个问题，题目所说的是将一层的每个节点都穿起来，而这个思路只能将同父节点的左右节点穿起来，如上图，5和6就不能被穿起来。<br>③所以只依赖一个节点是没办法解决问题的，我们应该将题目细化成将每相邻的节点连接起来。</p>
<p>④我们还可以利用队列来进行解答，用层次遍历的思想，将一层中的节点连接起来。</p>
<h1 id="code1（递归）"><a href="#code1（递归）" class="headerlink" title="code1（递归）"></a>code1（递归）</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> null;</span><br><span class="line">    connectTwoNode(root-&gt;left, root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectTwoNode</span><span class="params">(Node* node1, Node* node2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == null || node2 == null) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**** 前序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">// 将传入的两个节点连接</span></span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 连接相同父节点的两个子节点</span></span><br><span class="line">    connectTwoNode(node1-&gt;left, node1-&gt;right);</span><br><span class="line">    connectTwoNode(node2-&gt;left, node2-&gt;right);</span><br><span class="line">    <span class="comment">// 连接跨越父节点的两个子节点</span></span><br><span class="line">    connectTwoNode(node1-&gt;right, node2-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="code2（队列）"><a href="#code2（队列）" class="headerlink" title="code2（队列）"></a>code2（队列）</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; que;</span><br><span class="line">        que.push(root);<span class="comment">//根节点进入队列</span></span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)&#123;<span class="comment">//将一层的节点都连接起来</span></span><br><span class="line">                Node* temp = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span>(i != size - <span class="number">1</span>)&#123;<span class="comment">//如果没有到一层的最右侧的节点，则将左侧的next指向右侧节点</span></span><br><span class="line">                    temp-&gt;next = que.front();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left)<span class="comment">//左节点进入队列</span></span><br><span class="line">                    que.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right)<span class="comment">//右节点进入队列</span></span><br><span class="line">                    que.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>回收子进程</title>
    <url>/2020/05/15/%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：</p>
<p>如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。</p>
<p>我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p>
<h1 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h1><p>父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</p>
<h1 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h1><p>进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</p>
<h1 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h1><p>该函数有三个功能：<br>① 阻塞等待子进程退出<br>② 回收子进程残留资源<br>③ 获取子进程结束状态(退出原因)。</p>
<p> 原型:pid_t wait(int *status)</p>
<p>成功：清理掉的子进程ID；失败：-1 (没有子进程)</p>
<p>当进程终止时，操作系统的隐式回收机制：</p>
<p>1.关闭所有文件描述符 </p>
<p>2.释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)</p>
<p>可使用wait函数传出参数status来保存进程的退出状态。</p>
<p>借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：<br> 1.WIFEXITED(status) 为非0    → 进程正常结束<br>    WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)</p>
<p> 2.WIFSIGNALED(status) 为非0 → 进程异常终止<br>    WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</p>
<p>3.WIFSTOPPED(status) 为非0 → 进程处于暂停状态<br>    WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。<br>    WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">pid_t</span> pid,wpid;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm child,my parent = %d,going to sleep 10s\n"</span>,getppid());</span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"child die\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">76</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                wpid = wait(&amp;status);<span class="comment">//阻塞等待回收</span></span><br><span class="line">                <span class="keyword">if</span>(wpid == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">"wait "</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"child exit with %d\n"</span>,WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"child killed by%d\n"</span>,WTERMSIG(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"I'm parent,pid = %d,myson =%d\n"</span>,getpid(),pid);</span><br><span class="line">                        sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">"fork "</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid()"></a>waitpid()</h1><p>原型：pid_t waitpid(pid_t pid, int *status, in options)    </p>
<p>成功：返回清理掉的子进程ID  失败：-1(无子进程)</p>
<p>特殊参数和返回情况<br>参数pid:<br>pid &gt; 0 回收指定ID的子进程<br>pid = -1 回收任意子进程（相当于wait）<br>pid = 0 回收和当前调用waitpid一个组的所有子进程<br>pid &lt; -1 回收指定进程组内的任意子进程</p>
<p>参数options指定为WNOHANG，设置为非阻塞，且子进程正在运行</p>
<p>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>当程序执行之后，通过while(1)阻止父进程结束，可通过ps aux查看是否存在僵尸进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>,i;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">pid_t</span> wpid;</span><br><span class="line">        <span class="keyword">int</span> q,p;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                p = fork();</span><br><span class="line">                <span class="keyword">if</span>(p == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                &#125;    </span><br><span class="line">                <span class="comment">//else if(i == 3)</span></span><br><span class="line">                <span class="comment">//&#123;</span></span><br><span class="line">                <span class="comment">//        q = p;//设置回收指定子进程</span></span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == i)<span class="comment">//父进程</span></span><br><span class="line">        &#123;</span><br><span class="line">                sleep(n);<span class="comment">//等待子进程执行完</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm parent,pid = %d\n"</span>,getppid());</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                        wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">                        <span class="keyword">if</span>(wpid &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                n--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(n &gt; <span class="number">0</span>); </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"wait finish\n"</span>);</span><br><span class="line">                <span class="comment">//while(waitpid(q, NULL, WNOHANG))</span></span><br><span class="line">				<span class="comment">//wait(NULL);</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm %dth child, pid = %d, gpid = %d\n"</span>,i+<span class="number">1</span>, getpid(),getppid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程拷贝文件</title>
    <url>/2020/05/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_COUNT 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_BUF 1024</span></span><br><span class="line"><span class="comment">//作为线程创建的参数，包括两个文件的文件描述符和每个线程复制的大小</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd1;</span><br><span class="line">	<span class="keyword">int</span> fd2;</span><br><span class="line">	<span class="keyword">size_t</span> start;</span><br><span class="line">	<span class="keyword">size_t</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_copy</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_block</span> *<span class="title">block</span> = (<span class="title">struct</span> <span class="title">thread_block</span> *)<span class="title">arg</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[THREAD_BUF];</span><br><span class="line">	<span class="keyword">size_t</span> count = block-&gt;start;</span><br><span class="line">	<span class="comment">//打印线程ID和线程复制的起始位置和终点位置</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread id = %lu start = %ld end = %ld\n"</span>, pthread_self(), block-&gt;start, block-&gt;<span class="built_in">end</span>);</span><br><span class="line">	<span class="keyword">int</span> ret = lseek(block-&gt;fd1, block-&gt;start, SEEK_SET);<span class="comment">//将文件指针移到线程复制的起始位置</span></span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"lseek fd1 "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = lseek(block-&gt;fd2, block-&gt;start, SEEK_SET);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"lseek fd2 "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(count &lt; block-&gt;<span class="built_in">end</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">size_t</span> read_size, write_size;</span><br><span class="line">		read_size = <span class="built_in">read</span>(block-&gt;fd1, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="keyword">if</span>(read_size &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			count += read_size;<span class="comment">//加上读到的内容</span></span><br><span class="line">			<span class="keyword">if</span>(read_size == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				perror(<span class="string">"read "</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">char</span> *ptr = buf;<span class="comment">//*</span></span><br><span class="line">			<span class="keyword">do</span><span class="comment">//避免一次性不能写完全</span></span><br><span class="line">			&#123;</span><br><span class="line">				write_size = <span class="built_in">write</span>(block-&gt;fd2, ptr, read_size);</span><br><span class="line">				<span class="keyword">if</span>(write_size == <span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					perror(<span class="string">"write "</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(write_size &gt; <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ptr += write_size;<span class="comment">//*</span></span><br><span class="line">					read_size -= write_size;<span class="comment">//当一次没写完时，使数据减去已写入的数据</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">while</span>(write_size != <span class="number">0</span>);<span class="comment">//当没有数据可写的时候退出</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread exit %lu\n"</span>, pthread_self());</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"./a.out error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd1 = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd1 &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"open file1:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd2 = <span class="built_in">open</span>(argv[<span class="number">2</span>], O_CREAT | O_WRONLY, <span class="number">0664</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd2 &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"open file2:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = fstat(fd1, &amp;st);<span class="comment">//获取文件状态</span></span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"stat "</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">size_t</span> file_size = st.st_size;<span class="comment">//获取文件的大小</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_block</span> *<span class="title">blocks</span>;</span></span><br><span class="line">	blocks = (struct thread_block *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct thread_block)* THREAD_COUNT);</span><br><span class="line">	<span class="keyword">size_t</span> percent = file_size/THREAD_COUNT;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"filesize = %ld\t each percent = %ld\n"</span>, file_size, percent);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		blocks[i].fd1 = fd1;</span><br><span class="line">		blocks[i].fd2 = fd2;</span><br><span class="line">		blocks[i].start = i*percent;</span><br><span class="line">		blocks[i].<span class="built_in">end</span> = blocks[i].start + percent;</span><br><span class="line">	&#125;</span><br><span class="line">	blocks[i<span class="number">-1</span>].<span class="built_in">end</span> = file_size;<span class="comment">//最后一份</span></span><br><span class="line">	<span class="keyword">pthread_t</span> tid[THREAD_COUNT];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread_copy, (<span class="keyword">void</span> *)&amp;blocks[i]);</span><br><span class="line">		<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"creat error:%s\n"</span>, strerror(ret));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"join error:%s\n"</span>, strerror(ret));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(blocks);</span><br><span class="line">	ret = <span class="built_in">close</span>(fd1);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"close fd1"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">close</span>(fd2);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"close fd2"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"copy successful\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>LWP</tag>
      </tags>
  </entry>
  <entry>
    <title>多播（组播）</title>
    <url>/2020/09/06/%E5%A4%9A%E6%92%AD%EF%BC%88%E7%BB%84%E6%92%AD%EF%BC%89/</url>
    <content><![CDATA[<p>组播组可以是永久的也可以是临时的。<br>组播组地址中，有一部分由官方分配的，称为永久组播组。<br>永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。<br>永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。</p>
<p>可以使用ip -ad查看网卡编号<br>可以使用if_nametoindex函数根据网卡名获取网卡序号</p>
<p>224.0.0.0～224.0.0.255 为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；<br>224.0.1.0～224.0.1.255 是公用组播地址，可以用于Internet；欲使用需申请。<br>224.0.2.0～238.255.255.255 为用户可用的组播地址（临时组地址），全网范围内有效；<br>239.0.0.0～239.255.255.255 为本地管理组播地址，仅在特定的本地范围内有效。</p>
<h1 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIE_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">"239.0.0.2"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sfd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">char</span> buf[MAXLINE] = <span class="string">"ahdai\n"</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span></span><br><span class="line">        sfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port =htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        bind(sfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    </span><br><span class="line">        inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);<span class="comment">//设置组地址</span></span><br><span class="line">        inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;group.imr_address);<span class="comment">//本地任意IP</span></span><br><span class="line">        group.imr_ifindex = if_nametoindex(<span class="string">"ens33"</span>);</span><br><span class="line">        setsockopt(sfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;group, <span class="keyword">sizeof</span>(group));<span class="comment">//组播权限</span></span><br><span class="line">        bzero(&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));<span class="comment">//构造 client地址</span></span><br><span class="line">        clie_addr.sin_family = AF_INET;</span><br><span class="line">        inet_pton(AF_INET, GROUP, &amp;clie_addr.sin_addr.s_addr);<span class="comment">//239.0.0.0</span></span><br><span class="line">        clie_addr.sin_port = htons(CLIE_PORT);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(buf, <span class="string">"ahdai %d\n"</span>, i++);</span><br><span class="line">                sendto(sfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIE_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">"239.0.0.2"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">lo_addr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> cfd;</span><br><span class="line">        <span class="keyword">ssize_t</span> len;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span></span><br><span class="line">        cfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;lo_addr, <span class="keyword">sizeof</span>(lo_addr));</span><br><span class="line">        lo_addr.sin_family = AF_INET;</span><br><span class="line">        inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;lo_addr.sin_addr.s_addr);</span><br><span class="line">        lo_addr.sin_port = htons(CLIE_PORT);</span><br><span class="line">        bind(cfd, (struct sockaddr *)&amp;lo_addr, <span class="keyword">sizeof</span>(lo_addr));</span><br><span class="line">        inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);</span><br><span class="line">        inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;group.imr_address);</span><br><span class="line">        group.imr_ifindex = if_nametoindex(<span class="string">"ens33"</span>);</span><br><span class="line">        setsockopt(cfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, <span class="keyword">sizeof</span>(group));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                len = recvfrom(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>); </span><br><span class="line">                <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(cfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>尽量以const、enum、inline替换define</title>
    <url>/2020/10/18/%E5%B0%BD%E9%87%8F%E4%BB%A5const%E3%80%81enum%E3%80%81inline%E6%9B%BF%E6%8D%A2define/</url>
    <content><![CDATA[<h1 id="const替换-define"><a href="#const替换-define" class="headerlink" title="const替换#define"></a>const替换#define</h1><p>这个规则也许可以改为“宁可以编译器替换预处理器”，#define不被视作语言的一部分，这正是问题的所在。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure>
<p>记号名称ASPECT_RATIO也许从未被编译器看见，它在编译器开始处理之前就被预处理器移走了，于是这个记号名称并没有进入记号表（symbol table）内。<br>当使用这个常量但是却或者一个编译错误信息时，这个错误信息也许会提到1.653而绝不会提到ASPECT_RATIO。如果这个记号被定义在一个非本人写的头文件内，肯定对1.653毫无概念。而这解决方法便是用const替换#define</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;</span><br></pre></td></tr></table></figure>
<p>作为一个语言常量肯定会被编译器所看到。</p>
<p>值得注意的是class专属变量。为了将常量的作用域限制于class内，必须让它称为class的一个成员，而还需要确保此常量最多只有一份实体，所以必须用static修饰。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//static const int Numturns;//常量声明,位于头文件内</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Numturns = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> scores[Numturns];</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//const int GamePlayer::Numturns = 5;//常量定义，位于实现文件内</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::Numturns;</span><br><span class="line"><span class="comment">//如果程序不需要取Numturns的地址，则可以不用定义</span></span><br></pre></td></tr></table></figure>
<p>我们无法用#define创建一个class专属常量，因为#define并不重视作用域。一旦宏被定义，就在其后的编译过程中有效。这就意味着#define不仅不能用来定义class专属变量，也不能提供任何的封装性。</p>
<h1 id="enum替换-define"><a href="#enum替换-define" class="headerlink" title="enum替换#define"></a>enum替换#define</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gameplayer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123; Numturns = <span class="number">5</span>&#125;;<span class="comment">//令Numturns成为5的一个记号名称</span></span><br><span class="line">	<span class="keyword">int</span> scores[Numturns];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>enum的行为与#define比较相似，例如取一个#define的地址是非法的，同样取一个enum的地址也是非法的。</p>
<h1 id="inline替换-define"><a href="#inline替换-define" class="headerlink" title="inline替换#define"></a>inline替换#define</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>
<p>这样的宏函数有非常多的缺点，必须为所有的实参加上小括号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不需要在函数体内中为参数加上括号。</p>
<p><strong>总结：</strong><br> <strong>1. 对于单纯常量，最好以const对象或enums替换#define。<br> 2. 对于形似函数的宏，最好以inline函数替换#define</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>多路I_O转接服务器select</title>
    <url>/2020/09/06/%E5%A4%9A%E8%B7%AFI_O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8select/</url>
    <content><![CDATA[<p>多路IO转接服务器也叫做多任务IO服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件。</p>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>1、select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数<br>2、解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效</p>
<pre><code>#include &lt;sys/select.h
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout)</code></pre><p>nfds: 监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态</p>
<p>readfds： 监控有读数据到达文件描述符集合，传入传出参数</p>
<p>writefds： 监控写数据到达文件描述符集合，传入传出参数</p>
<p>exceptfds： 监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数</p>
<p>timeout： 定时阻塞监控时间，3种情况<br>1、NULL，永远等下去<br>2、设置timeval，等待固定时间<br>3、设置timeval里时间均为0，检查描述字后立即返回，轮<br>struct timeval {<br>long tv_sec; /* seconds /<br>long tv_usec; / microseconds */<br>};</p>
<p>void FD_CLR(int fd, fd_set *set); //把文件描述符集合里fd清0</p>
<p>int FD_ISSET(int fd, fd_set *set); //测试文件描述符集合里fd是否置1</p>
<p>void FD_SET(int fd, fd_set *set); //把文件描述符集合里fd位置1</p>
<p>void FD_ZERO(fd_set *set); //把文件描述符集合里所有位清0</p>
<h2 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ], str[INET_ADDRSTRLEN];<span class="comment">//缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> lfd, cfd, sfd;</span><br><span class="line">        <span class="keyword">int</span> n, maxfd, maxi;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> nready, client[FD_SETSIZE];<span class="comment">//自定义数组,防止便利1024文件描述符</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        fd_set rset, allset;</span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line">    </span><br><span class="line">        maxfd = lfd;<span class="comment">//起初lfd 为最大文件描述符</span></span><br><span class="line">        maxi = <span class="number">-1</span>;<span class="comment">//初始值指向0个元素之前下标位置</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">                client[i] = <span class="number">-1</span>;<span class="comment">//初始化</span></span><br><span class="line">        FD_ZERO(&amp;allset);</span><br><span class="line">        FD_SET(lfd, &amp;allset);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//每次循环都重新设置select监控信号集</span></span><br><span class="line">        &#123;</span><br><span class="line">                rset = allset;</span><br><span class="line">                nready = select(maxfd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span>(nready &lt; <span class="number">0</span>)</span><br><span class="line">                        perr_exit(<span class="string">"select errpr"</span>);</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(lfd, &amp;rset))<span class="comment">//说明有新的客户端链接请求</span></span><br><span class="line">                &#123;</span><br><span class="line">    </span><br><span class="line">                        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                        cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);<span class="comment">//不会阻塞</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"client IP :%s, client port = %d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">                        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; FD_SETSIZE;i++)</span><br><span class="line">                                <span class="keyword">if</span>(client[i] &lt; <span class="number">0</span>)<span class="comment">//找client[i]中没有使用的位置</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="comment">//保存accept返回的文件描述符</span></span><br><span class="line">                                        client[i] = cfd;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        <span class="keyword">if</span>(i == FD_SETSIZE)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="built_in">fputs</span>(<span class="string">"too many clients\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        FD_SET(cfd, &amp;allset);<span class="comment">//向监控文件描述符集添加新的</span></span><br><span class="line">                        <span class="keyword">if</span>(cfd &gt; maxfd)</span><br><span class="line">                                maxfd = cfd;<span class="comment">//select第一个参数</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt; maxi)</span><br><span class="line">                                maxi = i;<span class="comment">//保证maxi存的总是最后一个元素下标</span></span><br><span class="line">                        <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= maxi;i++)<span class="comment">//检测哪个客户端有数据就绪</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span>((sfd = client[i]) &lt; <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(FD_ISSET(sfd, &amp;rset))</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="comment">//当客户端关闭链接时,服务器端也关闭也关闭</span></span><br><span class="line">                                <span class="keyword">if</span>((n = Read(sfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        Close(sfd);</span><br><span class="line">                                        FD_CLR(sfd, &amp;allset);<span class="comment">//解除监控</span></span><br><span class="line">                                        client[i] = <span class="number">-1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                                                buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                                        Write(sfd, buf, n);</span><br><span class="line">                                        Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span>(--nready == <span class="number">0</span>)</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Close(lfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>尽可能使用const</title>
    <url>/2020/10/18/%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/</url>
    <content><![CDATA[<h1 id="const-iterator"><a href="#const-iterator" class="headerlink" title="const_iterator"></a>const_iterator</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();</span><br><span class="line">*iter = <span class="number">10</span>;<span class="comment">//没问题，改变的是iter所指的值</span></span><br><span class="line">iter++;<span class="comment">//错误，iter是const,类似于const T*</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator citer = vec.begin();</span><br><span class="line">*citer = <span class="number">10</span>;<span class="comment">//错误，*citer是const</span></span><br><span class="line">citer++;<span class="comment">//没问题，类似于T * const</span></span><br></pre></td></tr></table></figure>
<h1 id="降低客户的错误造成的意外"><a href="#降低客户的错误造成的意外" class="headerlink" title="降低客户的错误造成的意外"></a>降低客户的错误造成的意外</h1><p>例如一个有理数的operator*声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span>……&#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,<span class="keyword">const</span> Rational&amp; rhs)</span><br></pre></td></tr></table></figure>
<p>很多人会疑惑为什么要返回一个const，原因是如果不返回const，客户可以实现以下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Rational a,b,c;</span><br><span class="line">(a * b) = c;<span class="comment">//在a * b的成果上调用operator=</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a * b = c)<span class="comment">//其实只是想做一个比较动作，少输了一个等号</span></span><br></pre></td></tr></table></figure>
<p>如果a和b都是内置类型，这样的代码就是不合法的，将operator*的回传值声明为const则可以预防这个毫无意义的赋值</p>
<h1 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span></span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> text[position];<span class="comment">//const对象</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> text[position];<span class="comment">//non-const对象</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TextBlock的operator[]可以被这么使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tb[<span class="number">0</span>];<span class="comment">//调用non-const TextBlock::operator[]</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ctb[<span class="number">0</span>];<span class="comment">//调用const TextBlock::operator[]</span></span><br><span class="line"></span><br><span class="line">tb[<span class="number">0</span>]=<span class="string">'x'</span>;<span class="comment">//可以，写一个non-const TextBlock</span></span><br><span class="line">ctb[<span class="number">0</span>]=<span class="string">'x'</span>;<span class="comment">//错误，写一个const TextBlock</span></span><br></pre></td></tr></table></figure>
<p>上述的错误只因operator[]的返回类型，错误起因是企图对一个const char&amp;施行赋值动作。</p>
<p>下面有一个很有趣的事情，将operator[]声明为const成员函数却返回一个引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span><span class="comment">//其实并不适当</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> pText[position]</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;<span class="comment">//声明一个常量对象</span></span><br><span class="line"><span class="keyword">char</span>* pc = &amp;cctb[<span class="number">0</span>];<span class="comment">//调用const operator[]取得一个指针指向cctb的数据</span></span><br><span class="line">*pc = <span class="string">'J'</span>;<span class="comment">//cctb现在有了"Jello"的内容</span></span><br></pre></td></tr></table></figure>
<p>看起来没有任何的错误，创建一个常量对象并设以某值，而且只对他调用const成员函数，但你终究还是改变了他的值。所以引用与const相结合需要非常谨慎。<br>如果想修改const成员函数中的内容，成员变量只需要在声明的时候前面加上mutable就可以了。</p>
<h1 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h1><p>假设一个TextBlock内的operator[]不止返回一个指向某个字符的引用，也执行边界检验、志记访问信息、数据完善性检验等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		……<span class="comment">//边界检验</span></span><br><span class="line">		……<span class="comment">//志记数据访问</span></span><br><span class="line">		……<span class="comment">//检验数据完整性</span></span><br><span class="line">		<span class="keyword">return</span> text[position]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> positon)</span><br><span class="line">	&#123;</span><br><span class="line">		……<span class="comment">//边界检验</span></span><br><span class="line">		……<span class="comment">//志记数据访问</span></span><br><span class="line">		……<span class="comment">//检验数据完整性</span></span><br><span class="line">		<span class="keyword">return</span> text[position]</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>const与non-const中有许多重复的代码，也许可以将这些代码移到另一个成员函数，并令两个版本的operator[]调用它，这是可能的，但还是会重复一些代码，比如函数调用、两次return语句等等。<br>我们真正该做的是实现operator[]的机能一次并使用它两次，也就是说令其中的一个调用另一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		……<span class="comment">//边界检验</span></span><br><span class="line">		……<span class="comment">//志记数据访问</span></span><br><span class="line">		……<span class="comment">//检验数据完整性</span></span><br><span class="line">		<span class="keyword">return</span> text[position]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> positon)<span class="comment">//现在只调用const op[]</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将op[]返回值的const转除，为*this加上const,调用const op[]</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">			<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这份代码有两个转型动作，我们准备让non-const operator[]调用其const兄弟，但non-const operator[]内部若只是单纯的调用operator[]，便会递归的调用自己，为了避免无穷的递归，我们必须指出调用的是const operator[]，但c++缺乏直接的语法可以这么做。<br>因此将*this从其原型TextBlock&amp;转型为const TextBlock&amp;，然后则是从const operatoe[]的返回值中去除const。</p>
<p> <strong>总结</strong></p>
<p> <strong>1. 将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。<br> 2. 当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/2021/04/18/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="求最长公共子序列"><a href="#求最长公共子序列" class="headerlink" title="求最长公共子序列"></a>求最长公共子序列</h1><p>题目：给你输入两个字符串s1和s2，请你找出他们俩的最长公共子序列，返回这个子序列的长度。</p>
<p>比如说输入s1 = “zabcde”, s2 = “acez”，它俩的最长公共子序列是lcs = “ace”，长度为 3，所以算法返回 3。</p>
<h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>①首先我们想到的是枚举出所有子序列，然后看有没有公共的，再找出最长的，这显然时间复杂度会非常高。<br>②对于两个字符串寻找子序列，我们可以想到动态规划。<br>③我们观察两个字符串的每个字母。用两个指针分别指向两个字符串，当两个字母相等的时候，我们可以肯定这个字母肯定实在lcs里面的，所以<strong>dp[i][j] =dp[i - 1][j - 1] + 1</strong>。<br>④但当字母不相等的时候可以有三种情况，其一是s1[i]不在lcs,其二是s2[j]不在lcs中，最后就是两个字母都不在lcs中，这样我们可以得到状态转移方程的另一半<strong>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j -1])</strong>。<br>⑤但第三种情况其实可以忽略，因为第一和第二种情况包括了。<br>所以动态转移方程：<br><strong>dp[i][j] = dp[i - 1][j - 1] + 1       (s1[i] == s2[j])<br>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1)   (s1[i] != s2[j])</strong></p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = word1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = word2.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(len1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2 + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h1><p>题目：给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。<br>输入: “sea”, “eat”<br>输出: 2<br>解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”</p>
<h2 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h2><p>①本题不是问求lcs，但实际上是换了个说法，删除以后留下的字母不就是lcs吗。<br>②所以只需要利用lcs模板。</p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = word1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = word2.size();</span><br><span class="line">        <span class="keyword">int</span> len = lcs(word1, word2);</span><br><span class="line">		<span class="keyword">int</span> ans = len1 + len2 - len * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="两个字符串的最小ASCII删除和"><a href="#两个字符串的最小ASCII删除和" class="headerlink" title="两个字符串的最小ASCII删除和"></a>两个字符串的最小ASCII删除和</h1><p>题目：给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。</p>
<p>输入: s1 = “sea”, s2 = “eat”<br>输出: 231<br>解释: 在 “sea” 中删除 “s” 并将 “s” 的值(115)加入总和。<br>在 “eat” 中删除 “t” 并将 116 加入总和。<br>结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。</p>
<h2 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h2><p>①本题是求删除的ASCII码，不能用上述的Lcs模板来解答，但还是同样的思路。<br>②当指向的两个字母相同时，同样肯定在Lcs中，也就不用求该字母的ASCII码，即<strong>dp[i][j] = dp[i -1][j - 1]</strong><br>③当不相等时，即<strong>dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]</strong><br>④当有一个字符串为空时，则ans就是另一个字符串的所有字符ASCII相加之和。</p>
<h2 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(len1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2 + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + s1[i - <span class="number">1</span>];<span class="comment">//求dpbase</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len2; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + s2[i - <span class="number">1</span>];<span class="comment">//同dpbase</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j] + s1[i - <span class="number">1</span>], dp[i][j - <span class="number">1</span>] + s2[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>树的非递归遍历</title>
    <url>/2020/05/26/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversal</span><span class="params">(TNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TNode *rt = root;</span><br><span class="line">	<span class="built_in">stack</span>&lt;TNode*&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (rt || s.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (rt)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(rt-&gt;rchild);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; rt-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			rt = rt-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		rt = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">(TNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TNode *rt = root;</span><br><span class="line">	<span class="built_in">stack</span>&lt;TNode*&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (rt || s.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (rt)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(rt);</span><br><span class="line">			rt = rt-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		rt = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; rt-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		rt = rt-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><p>因为程序是通过根，右，左遍历，所以最后需要倒置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTraversal</span><span class="params">(TNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TNode *rt = root;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v;</span><br><span class="line">	<span class="built_in">stack</span>&lt;TNode*&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (rt || s.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (rt)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(rt-&gt;lchild);</span><br><span class="line">			v.push_back(rt-&gt;data);</span><br><span class="line">			rt = rt-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		rt = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(v.begin(), v.end());<span class="comment">//倒转v</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = v.begin(); iter != v.end(); iter++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>特化swap</title>
    <url>/2020/10/21/%E7%89%B9%E5%8C%96swap/</url>
    <content><![CDATA[<h1 id="基础swap"><a href="#基础swap" class="headerlink" title="基础swap"></a>基础swap</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">		<span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要T支持copying，swap便可以置换类型为T的对象，但这swap实现版本十分平淡，它涉及三个对象的复制。对于某些类型而言这些复制动作无一必要。</p>
<h1 id="特化swap"><a href="#特化swap" class="headerlink" title="特化swap"></a>特化swap</h1><p>如果一个类的成员变量非常多，可以设置一个类，用一个指针指向这个成员变量的类，这样就以一个指针指向对象，内含真正的数据。就是所谓的“pimpl”手法,按这样设计：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span>//针对<span class="title">Wigdet</span>设计的<span class="title">class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	WidgetImpl(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v):a(a),b(b),v(v)&#123;&#125;</span><br><span class="line">	WidgetImpl(<span class="keyword">const</span> WidgetImpl&amp; other) &#123;</span><br><span class="line">		a = other.a;</span><br><span class="line">		b = other.b;</span><br><span class="line">		v = other.v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_a</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_b</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;b; &#125;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="title">get_v</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;v; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a, b;<span class="comment">//可能有许多数据，意味着复制时间很长</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Widget(<span class="keyword">const</span> WidgetImpl&amp; rhs) &#123;</span><br><span class="line">		pImpl = <span class="keyword">new</span> WidgetImpl(rhs);</span><br><span class="line">	&#125;</span><br><span class="line">	Widget(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">		pImpl = <span class="keyword">new</span> WidgetImpl(*rhs.pImpl);</span><br><span class="line">	&#125;</span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">		<span class="keyword">if</span> (&amp;rhs == <span class="keyword">this</span>)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		pImpl = <span class="keyword">new</span> WidgetImpl(*rhs.pImpl);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Widget() &#123;</span><br><span class="line">		<span class="keyword">delete</span> pImpl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"成员swap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">		swap(pImpl, other.pImpl);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;pImpl-&gt;get_a() &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="keyword">this</span>-&gt;pImpl-&gt;get_b() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> iter: <span class="keyword">this</span>-&gt;pImpl-&gt;get_v()) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; iter &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	WidgetImpl *pImpl;<span class="comment">//指针，所指对象内含Widget数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一旦要置换Widget对象值，我们只需要置换pImpl指针，但swap算法不知道这点，它不知复制三个Widget还复制三个WidgetImpl对象，非常缺乏效率。</p>
<p>我们考虑到可以在std命名空间内特化swap函数例如：<br>（一种错误的写法）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)&#123;</span><br><span class="line">		swap(a.pImpl, b.pImpl);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这个swap在访问类中的private成员所以编译不能通过，</p>
<p>我们可以在Widget中添加一个swap成员函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget::<span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"成员swap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">		swap(pImpl, other.pImpl);<span class="comment">//这个便是使用std::swap交换指针的值</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>然后在std命名空间里特化swap</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)&#123;</span><br><span class="line">		a.swap(b);<span class="comment">//调用Widget的成员函数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止swap特化完成，以下代码的swap调用的是特化版本，因为c++的名称查找法则会找到Widget的专属版本。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">WidgetImpl <span class="title">W1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, v)</span></span>;</span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(W1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">WidgetImpl <span class="title">W2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, v2)</span></span>;</span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(W2)</span></span>;</span><br><span class="line">w1.print();</span><br><span class="line">w2.print();</span><br><span class="line">swap(w1,w2);<span class="comment">//调用的是特化版本的swap而不是std::swap</span></span><br><span class="line">w1.print();</span><br><span class="line">w2.print();</span><br></pre></td></tr></table></figure>
<h1 id="尝试将Widget参数化"><a href="#尝试将Widget参数化" class="headerlink" title="尝试将Widget参数化"></a>尝试将Widget参数化</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span>&#123;</span>……&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span>……&#125;;</span><br></pre></td></tr></table></figure>

<p>但是如果我们想将特化swap写成这样是不合法的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">void</span> swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt;&amp; a,Widget&lt;T&gt;&amp; b)&#123;</span><br><span class="line">		a.swap(b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为c++只允许对class templates偏特化，在function templates身上时行不通的。</p>
<p>当打算偏特化一个function template时，通常做法是简单的为它添加一个重载版本例如：<br>虽然这个在这个样例中也是不合法的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,Widget&lt;T&gt;&amp; b)</span></span>&#123;</span><br><span class="line">		a.swap(b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是因为std里的内容由c++标准已经决定好的，我们只可以对特化std里的东西而不能膨胀那些已经声明好的东西。<br>以下是解决方法：<br>假设所有Widget相关的机能都被置于这个命名空间内</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff&#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span>……&#125;;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,Widget&lt;T&gt;&amp; b)</span></span>&#123;<span class="comment">//这里并不属于std空间</span></span><br><span class="line">		a.swap(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，在任何的地方任何代码如果打算置换两个Widget对象，都会调用特化的swap。</p>
<p><strong>总结：</strong></p>
<p> <strong>1. 当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定他不抛出异常。<br> 2. 当提供一个member swap，也应该提供一个non-member swap用来调用前者，对于classed而言，也请特化std::swap。<br> 3. 调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。<br> 4. 为“用户定义类型”进行std templates全特化是好的，千万不要尝试在std内加入某些对std而言全新的东西。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>确定对象被使用前已先被初始化</title>
    <url>/2020/10/18/%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="使用初始化列表"><a href="#使用初始化列表" class="headerlink" title="使用初始化列表"></a>使用初始化列表</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span>&#123;</span>……&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABEntry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ABEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> <span class="built_in">string</span>&amp; address,</span><br><span class="line">					<span class="keyword">const</span> <span class="built_in">list</span>&lt;PhoneNumber&gt;&amp;phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> theName;</span><br><span class="line">	<span class="built_in">string</span> theAddress;</span><br><span class="line">	<span class="built_in">list</span>&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">	<span class="keyword">int</span> numTimeConsulted;</span><br><span class="line">&#125;;</span><br><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> <span class="built_in">string</span>&amp; address,</span><br><span class="line">					<span class="keyword">const</span> <span class="built_in">list</span>&lt;PhoneNumber&gt;&amp;phones)</span><br><span class="line">&#123;</span><br><span class="line">	theName = name;<span class="comment">//这些都是赋值而非初始化</span></span><br><span class="line">	theAddress = address;</span><br><span class="line">	thePhones = phones;</span><br><span class="line">	numTimesConsulted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;					</span><br><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> <span class="built_in">string</span>&amp; address,</span><br><span class="line">					<span class="keyword">const</span> <span class="built_in">list</span>&lt;PhoneNumber&gt;&amp;phones)</span><br><span class="line">:theName(name),<span class="comment">//现在这些都是初始化</span></span><br><span class="line">theAddress(address),</span><br><span class="line">thePhones(phones),</span><br><span class="line">numTimeConsulted(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;	<span class="comment">//构造函数本体内不必有任何动作</span></span><br></pre></td></tr></table></figure>
<p>下面这个构造函数与上面那个构造函数最终结果相同，但通常效率较高。基于赋值的版本，首先调用默认构造函数为成员变量设初值，然后立刻对它们赋值。默认构造的以切因此浪费了。使用初始化列表则避免了这一问题。本例中theName以name为初值进行copy构造其余成员变量同样，对大多数类型而言，比先调用默认构造函数再调用copy assignment操作符，单只调用一次copy构造函数是比较高效的。<br><strong>如果成员变量是const或引用则必须使用初始化而不能赋值。</strong></p>
<h1 id="不同编译单元内定义non-local-static对象的初始化次序"><a href="#不同编译单元内定义non-local-static对象的初始化次序" class="headerlink" title="不同编译单元内定义non-local static对象的初始化次序"></a>不同编译单元内定义non-local static对象的初始化次序</h1><p>所谓编译单元是指产出单一目标文件的那些源码，基本上是单一源码文件加上其所含入的头文件。<br>现在我们关心的至少是两个源码文件<br>假设有一个FileSystem class，让互联网上的文件看起来好像在本机</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	……</span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">numDisk</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//众多成员函数之一</span></span><br><span class="line">	……</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;<span class="comment">//预备给客户使用的对象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>//由程序库客户建立</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Directory(params);</span><br><span class="line">	……</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">size_t</span> disks = tfs.numDisks();<span class="comment">//使用tfs对象</span></span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步假设，客户决定创建一个Directory对象用于放置临时文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">(params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>现在初始化次序的重要性就显现出来了，除非tfs在tempDir之前被初始化，否则tempDir的构造函数会用到未初始化的tfs。但tfs和tempDir是不同的人在不同的时间于不同的源码文件建立起来的，我们无法确定tfs和tempDir谁先被初始化。<strong>当然可以用一个设计巧妙解决这个问题。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span>……&#125;;<span class="comment">//同前</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span><span class="comment">//这个函数用来替换tfs对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> FileSystem fs;<span class="comment">//定义并初始化一个local static对象</span></span><br><span class="line">	<span class="keyword">return</span> fs;	<span class="comment">//返回一个对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>&#123;</span>……&#125;;<span class="comment">//同前</span></span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">size_t</span> disks = tfs().numDisks();<span class="comment">//原版本的tfs改为tfs()</span></span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempdir</span><span class="params">()</span><span class="comment">//用来替换tempDir对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> Directory td;</span><br><span class="line">	<span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改之后客户完全像以前一样去使用它，唯一不同的是现在使用tfs()和tempDir()而不是tfs和tempDir，也就是说它们使用函数返回指向static对象的引用，而不再是static对象的本身。这样就可以保证使用的tfs是初始化以后的。</p>
<p><strong>总结</strong></p>
<p> <strong>1. 为内置对象进行手工初始化，因为c++不保证初始化它们。<br> 2. 构造函数最好使用成员初始化列表，而不要在构造函数本体内使用赋值操作。初始化列列出的成员变量，其排列次序应该和他们在class中的声明次序相同。<br> 3. 为免除“跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>并发服务器</title>
    <url>/2020/09/05/%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_IP <span class="meta-string">"192.168.44.138"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> n;</span><br><span class="line">        <span class="keyword">while</span>((n = waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG)) &gt; <span class="number">0</span>); </span><br><span class="line"><span class="comment">/*      while(1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                n = waitpid(0, NULL, WNOHANG);</span></span><br><span class="line"><span class="comment">                if(n == -1)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                        perror("waitpid error");</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ], clie_IP[BUFSIZ];</span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        <span class="comment">//serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span></span><br><span class="line">        inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(lfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(lfd, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                cfd = Accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"client IP :%s, port:%d\n"</span>, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, <span class="keyword">sizeof</span>(clie_IP)), ntohs(clie_addr.sin_port));</span><br><span class="line">                pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">"fork error"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        Close(lfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                        Close(cfd);</span><br><span class="line">                        signal(SIGCHLD, wait_child);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        n = Read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="comment">//client close</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                Close(cfd);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                perror(<span class="string">"read error"</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                                <span class="built_in">write</span>(cfd, buf, n);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8888</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_info</span>//将地址与<span class="title">cfd</span>捆绑</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> connfd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_work</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> *<span class="title">ts</span> = (<span class="title">struct</span> <span class="title">s_info</span> *)<span class="title">arg</span>;</span></span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                n = Read(ts-&gt;connfd, buf, MAXLINE);</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"the client %d closed \n"</span>, ts-&gt;connfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>, inet_ntop(AF_INET, &amp;(*ts).clie_addr.sin_addr.s_addr, str, <span class="keyword">sizeof</span>(str)), ntohs((*ts).clie_addr.sin_port));</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span> ;i &lt; n ;i++)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                Write(STDOUT_FILENO, buf, n); </span><br><span class="line">                Write(ts-&gt;connfd, buf, n); </span><br><span class="line">        &#125;</span><br><span class="line">        Close(ts-&gt;connfd);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> <span class="title">ts</span>[256];</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">        bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">        Bind(listenfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        Listen(listenfd, <span class="number">128</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Acceptint client connect \n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);<span class="comment">//阻塞监听客户端链接请求</span></span><br><span class="line">                ts[i].clie_addr = clie_addr;</span><br><span class="line">                ts[i].connfd = connfd;</span><br><span class="line">                <span class="comment">//达到线程最大时，pthread_create出错处理，增加服务器稳定性</span></span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, do_work, (<span class="keyword">void</span> *)&amp;ts[i]);</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>管道</title>
    <url>/2020/05/15/%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<p><strong>管道是一种最基本的IPC机制</strong><br>作用于有血缘关系的进程之间，完成数据传递。</p>
<p>调用pipe系统函数即可创建一个管道。有如下特征：<br>1.其本质是一个伪文件(实为内核缓冲区)<br>2.由两个文件描述符引用，一个表示读端，一个表示写端。<br>3.规定数据从管道的写端流入管道，从读端流出。</p>
<p><strong>管道的原理：</strong><br>管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p>
<p><strong>管道的局限性：</strong><br>1.数据自己读不能自己写。<br>2. 数据一旦被读走，便不在管道中存在，不可反复读取。<br>3. 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。<br>4. 只能在有公共祖先的进程间使用管道。</p>
<p>常见的通信方式有，单工通信、半双工通信、全双工通信</p>
<h1 id="pipe"><a href="#pipe" class="headerlink" title="pipe()"></a>pipe()</h1><p>函数原型：int pipe(int pipefd[2])<br>成功：0；失败：-1，设置errno</p>
<p>1.父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。<br> 2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。<br> 3. 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];<span class="comment">//读写文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe err"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork err"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">//子进程，读数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="built_in">close</span>(fd[<span class="number">1</span>]);<span class="comment">//关闭写端</span></span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        ret = <span class="built_in">read</span>(fd[<span class="number">0</span>], buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"--------\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in">write</span>(STDOUT_FILENO, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);<span class="comment">//关闭读端</span></span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>],<span class="string">"hello pipe\n"</span>, <span class="built_in">strlen</span>(<span class="string">"hello pipe\n"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2020/05/19/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h1><p>LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)</p>
<p>进程：独立地址空间，拥有PCB<br>线程：也有PCB，但没有独立的地址空间(共享)<br>区别：在于是否共享地址空间。<br>Linux下：<br><strong>线程：最小的执行单位<br>进程：最小分配资源单位，可看成是只有一个线程的进程。</strong></p>
<h1 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a>Linux内核线程实现原理</h1><p>1、线程也有PCB，创建线程使用的底层函数和进程一样，都是clone<br>2、从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的<br>3、进程可以蜕变成线程<br>4、线程可看做寄存器和栈的集合<br>5、<strong>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</strong></p>
<p>对于进程来说，相同的地址(同一个虚拟地址)在不同的进程中，反复使用而不冲突。原因是他们虽虚拟址一样，但，页目录、页表、物理页面各不相同。相同的虚拟址，映射到不同的物理页面内存单元，最终访问不同的物理页面。</p>
<p><strong>但线程不同</strong>，两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。<br>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。<br>如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。<br><strong>因此</strong>：Linux内核是不区分进程和线程的。只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</p>
<h1 id="线程资源的共享与非共享"><a href="#线程资源的共享与非共享" class="headerlink" title="线程资源的共享与非共享"></a>线程资源的共享与非共享</h1><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>1、文件描述符表<br>2、每种信号的处理方式<br>3、当前工作目录<br>4、用户ID和组ID<br>5、内存地址空间 (.text/.data/.bss/heap/共享库)</p>
<h2 id="非共享"><a href="#非共享" class="headerlink" title="非共享"></a>非共享</h2><p>1、线程id<br>2、处理器现场和栈指针(内核栈)<br>3、独立的栈空间(用户空间栈)<br>4、errno变量<br>5、信号屏蔽字<br>6、调度优先级</p>
<h1 id="线程的控制原语"><a href="#线程的控制原语" class="headerlink" title="线程的控制原语"></a>线程的控制原语</h1><h2 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h2><p>作用：获取线程ID。<br>函数原型：pthread_t pthread_self(void）<br>返回值：成功：线程ID；    失败：无</p>
<p>线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现</p>
<p>线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同)<br><strong>注意：不应使用全局变量 pthread_t tid，而在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。</strong></p>
<h2 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h2><p>作用：创建一个新线程。<br>函数原型：int pthread_create(pthread_t <em>thread, const pthread_attr_t *attr, void *(</em>start_routine) (void *), void *arg)<br>返回值：成功：0，    失败：错误号    —–Linux环境下，所有线程特点，失败均直接返回错误号。</p>
<p>参数：<br>pthread_t：typedef unsigned long int pthread_t;<strong>(Linux)</strong><br>参数1：传出参数，保存系统为我们分配好的线程ID<br>参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。<br>参数3：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。<br>参数4：线程主函数执行期间所使用的参数。</p>
<h2 id="创建新线程，打印线程ID"><a href="#创建新线程，打印线程ID" class="headerlink" title="创建新线程，打印线程ID"></a>创建新线程，打印线程ID</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In thread:thread id = %lu\n"</span>, pthread_self());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %u\n"</span>,getpid());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In main1:thread id = %lu\n"</span>, pthread_self());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %u\n"</span>,getpid());</span><br><span class="line">	ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span> ,<span class="string">"pthread_create error:%s\n"</span>,strerror(ret));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In main2:thread id = %lu\n"</span>, pthread_self());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %u\n"</span>,getpid());</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环创建多个线程"><a href="#循环创建多个线程" class="headerlink" title="循环创建多个线程"></a>循环创建多个线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int i = *(int *)arg;这样是错误的</span></span><br><span class="line">	<span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line">	sleep(i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%dth thread:"</span>,i+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"In thread:thread id = %lu\n"</span>, pthread_self());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %u\n"</span>,getpid());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="comment">//在线程取地址之后，有可能i的值发生变化</span></span><br><span class="line">		<span class="comment">//ret = pthread_create(&amp;tid, NULL, thrd_func, (void *)&amp;i);</span></span><br><span class="line">		ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span> *)i);</span><br><span class="line">		<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span> ,<span class="string">"pthread_create error:%s\n"</span>,strerror(ret));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程之间共享全局变量"><a href="#线程之间共享全局变量" class="headerlink" title="线程之间共享全局变量"></a>线程之间共享全局变量</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//线程之间共享全局变量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	var = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"at first var = %d\n"</span>, var);</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"after pthread_create, var = %d\n"</span>, var);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h2><p>作用：将单个线程退出<br>函数原型：void pthread_exit(void <em>retval)<br>参数：retval表示线程退出状态，通常传NULL<br>*</em>注意：线程中，禁止使用exit函数，会导致进程内所有线程全部退出。**</p>
<h2 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h2><p>作用：阻塞等待线程退出，获取线程退出状<br>函数原型：int pthread_join(pthread_t thread, void **retval)</p>
<p>成功：0；失败：错误号<br>参数：thread：线程ID,retval：存储线程结束状态。</p>
<p>1、如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。<br>2、如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。<br>3、如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。<br>4、如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。</p>
<h2 id="回收多个子线程"><a href="#回收多个子线程" class="headerlink" title="回收多个子线程"></a>回收多个子线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//循环回收多个子线程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	i = (<span class="keyword">int</span>)arg;</span><br><span class="line">	sleep(i);</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">1</span>)<span class="comment">//第二个线程修改val=333</span></span><br><span class="line">	&#123;</span><br><span class="line">		var = <span class="number">333</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"var = %d\n"</span>,var);</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">void</span> *)var;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>)<span class="comment">//第4个线程修改val=777</span></span><br><span class="line">	&#123;</span><br><span class="line">		var = <span class="number">777</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm %dth pthread, id = %lu\n var = %d\n"</span>,i+<span class="number">1</span>, pthread_self(), var);</span><br><span class="line">		pthread_exit((<span class="keyword">void</span> *)var);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm %dth pthread, id = %lu\n var = %d\n"</span>,i+<span class="number">1</span>, pthread_self(), var);</span><br><span class="line">		pthread_exit((<span class="keyword">void</span> *)var);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> *ret[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_create(&amp;tid[i], <span class="literal">NULL</span>, tfn, (<span class="keyword">void</span> *)i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span> ;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_join(tid[i], (<span class="keyword">void</span> **)&amp;ret[i]);<span class="comment">//回收子线程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d 's ret = %d\n"</span>, i+<span class="number">1</span>, (<span class="keyword">int</span>)ret[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I'm main pthread tid = %lu\t var = %d\n"</span>,pthread_self(), var);</span><br><span class="line">	sleep(i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pthread-deatch函数"><a href="#pthread-deatch函数" class="headerlink" title="pthread_deatch函数"></a>pthread_deatch函数</h2><p>作用：实现线程分离<br>函数原型：int pthread_detach(pthread_t thread<br>成功：0，失败：错误号<br><strong>线程分离状态</strong>：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放<br>网络、多线程服务器常用。</p>
<h2 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h2><p>作用：杀死(取消)线程<br>函数原型：int pthread_cancel(pthread_t thread<br>成功：0，失败：错误号</p>
<p>线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。<br><strong>取消点</strong>：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write….. </p>
<p>可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthreestcancel函数自行设置一个取消点。</p>
<p>被取消的线程，退出值定义在Linux的pthread库中<br>常数PTHREAD_CANCELED的值是-1。可在头文件pthread.h中找到它的定义：#define PTHREAD_CANCELED ((void *) -1)。因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1。</p>
<h2 id="杀死线程的三种方式"><a href="#杀死线程的三种方式" class="headerlink" title="杀死线程的三种方式"></a>杀死线程的三种方式</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//杀死线程3种方式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 1 returning\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 2 exiting\n"</span>);</span><br><span class="line">	pthread_exit((<span class="keyword">void</span> *)<span class="number">222</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn3</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//printf("thread 3:I'm going to die in 3 seconds\n");</span></span><br><span class="line">		<span class="comment">//sleep(1);</span></span><br><span class="line">		pthread_testcancel();<span class="comment">//自己设置取消点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">666</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">void</span> *tred = <span class="literal">NULL</span>;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid, &amp;tred);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 1 exit code = %d\n\n"</span>, (<span class="keyword">int</span>)tred);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn2, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid, &amp;tred);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 2 exit code = %d\n\n"</span>, (<span class="keyword">int</span>)tred);</span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn3, <span class="literal">NULL</span>);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">	pthread_cancel(tid);<span class="comment">//需要到达某个取消点 系统调用</span></span><br><span class="line">	pthread_join(tid, &amp;tred);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 3 exit code = %d\n\n"</span>, (<span class="keyword">int</span>)tred);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>LWP</tag>
      </tags>
  </entry>
  <entry>
    <title>竞态条件（时序竞态）</title>
    <url>/2020/05/18/%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%88%E6%97%B6%E5%BA%8F%E7%AB%9E%E6%80%81%EF%BC%89/</url>
    <content><![CDATA[<h1 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a>pause函数</h1><p>调用该函数可以造成进程主动挂起，等待信号唤醒。<br>调用该系统调用的进程将处于阻塞状态(主动放弃cpu) 直到有信号递达将其唤醒。<br>函数原型：int pause(void）<br>返回值：-1 并设置errno为EINTR<br>返回值：<br>1、如果信号的默认处理动作是终止进程，则进程终止，pause函数没有机会返回。<br>2、如果信号的默认处理动作是忽略，进程继续处于挂起状态，pause函数不返回。<br>3、如果信号的处理动作是捕捉，则调用完信号处理函数之后，pause返回-1，errno设置为EINTR，表示“被信号中断”。<br>4、pause收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒。</p>
<h1 id="sleep实现"><a href="#sleep实现" class="headerlink" title="sleep实现"></a>sleep实现</h1><h2 id="存在时序竞态问题"><a href="#存在时序竞态问题" class="headerlink" title="存在时序竞态问题"></a>存在时序竞态问题</h2><p>pause函数和alarm函数实现sleep<br>可以通过设置屏蔽SIGALRM的方法来控制程序执行逻辑，但无论如何设置，程序都有可能在“解除信号屏蔽”与“挂起等待信号”这个两个操作间隙失去cpu资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_sigalarm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">	act.sa_handler = catch_sigalarm;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = sigaction(SIGALRM, &amp;act, &amp;oldact);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"sigaction error:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	alarm(seconds);</span></span><br><span class="line"><span class="comment">	//如果失去了CPU，优先级较高的程序较多，长时间没有分配CPU</span></span><br><span class="line"><span class="comment">	//如果2S后再获得CPU，先处理信号，程序则不能被唤醒</span></span><br><span class="line"><span class="comment">	ret = pause();</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	alarm(seconds);</span><br><span class="line">	<span class="comment">//屏蔽</span></span><br><span class="line">	ret = pause();</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINTR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pause successful\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = alarm(<span class="number">0</span>);</span><br><span class="line">	sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);<span class="comment">//恢复SIGALRM信号旧有的处理方式</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ret = mysleep(<span class="number">1</span>);<span class="comment">//睡1S</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d------\n"</span>,ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可将某个信号（如SIGALRM）从临时信号屏蔽字mask中删除，这样在调用sigsuspend时将解除对该信号的屏蔽，然后挂起等待，当sigsuspend返回时，进程的信号屏蔽字恢复为原来的值。如果原来对该信号是屏蔽态，sigsuspend函数返回后仍然屏蔽该信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nsecs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">	<span class="keyword">sigset_t</span> newmask, oldmask, suspmask;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line">	<span class="comment">//1、为SIGALRM设置捕捉函数</span></span><br><span class="line">	newact.sa_handler = sig_alrm;</span><br><span class="line">	sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">	newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigaction(SIGALRM, &amp;newact, &amp;oldact);</span><br><span class="line">	<span class="comment">//2、设置阻塞信号集，阻塞SIGALRM信号</span></span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigaddset(&amp;newmask, SIGALRM);</span><br><span class="line">	sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);<span class="comment">//屏蔽信号字 mask</span></span><br><span class="line">	<span class="comment">//3、定时n秒，到时后可以产生SIGALRM信号</span></span><br><span class="line">	alarm(nsecs);</span><br><span class="line">	<span class="comment">//4、构造一个调用sigsuspend临时有效的阻塞信号集</span></span><br><span class="line">	<span class="comment">//在临时阻塞信号集里解除SIGALRM的阻塞</span></span><br><span class="line">	suspmask = oldmask;                 <span class="comment">//SIGALRM没有被阻塞</span></span><br><span class="line">	sigdelset(&amp;suspmask, SIGALRM);<span class="comment">//保证SIGALRM一定没有被屏蔽</span></span><br><span class="line">	<span class="comment">//5、sigsuspend调用期间，采用临时阻塞信号集suspmask替换原有</span></span><br><span class="line">	<span class="comment">//这个信号集中不包括SIGALRM信号，同时挂起等待</span></span><br><span class="line">	<span class="comment">//当sigsuspend被信号唤醒返回时，恢复原有的阻塞信号集</span></span><br><span class="line">	sigsuspend(&amp;suspmask);<span class="comment">//解除屏蔽调用信号处理函数，同时执行</span></span><br><span class="line">	unslept = alarm(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//6、恢复SIGALRM原有的处理动作-----回应注释1</span></span><br><span class="line">	sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//7、解除对SIGALRM阻塞-------回应注释2</span></span><br><span class="line">	sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> unslept;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mysleep(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"------\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</p>
<p>不可靠由其实现原理所致：信号是通过软件方式实现(跟内核调度高度依赖，延时性强)，每次系统调用结束后，或中断处理处理结束后，需通过扫描PCB中的未决信号集，来判断是否应处理某个信号。当系统负载过重时，会出现时序混乱。</p>
<p>这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。且由于该错误不具规律性，后期捕捉和重现十分困难。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>进程的创建以及exec族函数的应用</title>
    <url>/2020/05/14/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BB%A5%E5%8F%8Aexec%E6%97%8F%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="父子进程共享"><a href="#父子进程共享" class="headerlink" title="父子进程共享"></a>父子进程共享</h2><p>父子进程间遵循读时共享写时复制的原则。</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>全局变量、.date、.text、栈、堆、环境变量、用户ID、宿主ID、进程工作目录、信号处理方式…</p>
<h3 id="非共享"><a href="#非共享" class="headerlink" title="非共享"></a>非共享</h3><p>进程ID、fork返回值、父进程ID、进程运行时间、闹钟、未决信号集</p>
<h2 id="循环创建多个多进程"><a href="#循环创建多个多进程" class="headerlink" title="循环创建多个多进程"></a>循环创建多个多进程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"xxxxxxxx\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">"fork error:"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">//关键所在</span></span><br><span class="line">                <span class="comment">//如果不break则会导致子进程继续fork，从而导致不只有5个子进程</span></span><br><span class="line">                <span class="comment">//      printf("I'm %dth child ,pid = %u,ppid = %u\n",i+1,getpid(),getppid());</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm %dth child, pid = %u\n"</span>,i+<span class="number">1</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"I'm parent"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"yyyyyyyyyyyy\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="exec族函数"><a href="#exec族函数" class="headerlink" title="exec族函数"></a>exec族函数</h2><p>用途：加载某一个进程</p>
<h3 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h3><p>加载一个进程，借助PATH环境变量</p>
<p>int execlp(const char *file, const char *arg, …)成功：无返回；失败：-1<br>参数1 : 要加载的程序的名字。</p>
<p>execlp(“ls”, “ls”, “-l”, “-F”, NULL);         使用程序名在PATH中搜索。<br>该函数通常调用系统程序例如：ls date cp</p>
<h3 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h3><p>加载一个进程， 通过 路径+程序名 来加载。</p>
<p>int execl(const char *path, const char *arg, …成功：无返回；失败：-1</p>
<p>execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL);<br>使用参数1给出的绝对路径搜索。</p>
<h3 id="execvp"><a href="#execvp" class="headerlink" title="execvp"></a>execvp</h3><p>加载一个进程，使用自定义环境变量env</p>
<p>int execvp(const char *file, const char *argv[]);<br>变参形式： ①… ② argv[]  (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, …)) </p>
<p>变参终止条件：① NULL结尾 ② 固参指定</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">"fork "</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"parent\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//execl("./while","while",NULL);</span></span><br><span class="line">                execl(<span class="string">"/bin/ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"-F"</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">//execlp("ls", "ls","-l","-a",NULL);</span></span><br><span class="line">                <span class="keyword">char</span> *argv[] = &#123;<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="string">"-a"</span>,<span class="string">"-h"</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">                <span class="comment">//execv("/bin/ls",argv);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用dup2-重定向输出到文件中"><a href="#利用dup2-重定向输出到文件中" class="headerlink" title="利用dup2()重定向输出到文件中"></a>利用dup2()重定向输出到文件中</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd; </span><br><span class="line">        fd = <span class="built_in">open</span>(<span class="string">"ps.out"</span>, O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">"open ps.out"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">        dup2(fd, STDOUT_FILENO);<span class="comment">//dup2(3,1);</span></span><br><span class="line">        <span class="comment">//将标准输出重定向到自己创建的文件中</span></span><br><span class="line">        execlp(<span class="string">"ps"</span>,<span class="string">"ps"</span>,<span class="string">"aux"</span>,<span class="literal">NULL</span>);<span class="comment">//no successful return</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>线程属性</title>
    <url>/2020/05/20/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="线程属性结构体"><a href="#线程属性结构体" class="headerlink" title="线程属性结构体"></a>线程属性结构体</h1><pre><code>typedef struct
{
    int                     etachstate;     //线程的分离状态
    int                     schedpolicy;     //线程调度策略
    struct sched_param    schedparam;     //线程的调度参数
    int                     inheritsched;     //线程的继承性
    int                     scope;         //线程的作用域
    size_t                 guardsize;     //线程栈末尾的警戒缓冲区大小
    int                    stackaddr_set; //线程的栈设置
    void*                 stackaddr;     //线程栈的位置
    size_t                 stacksize;     //线程栈的大小
} pthread_attr_t; </code></pre><p>主要结构体成员：<br><strong>1、线程分离状态<br>2、线程栈大小（默认平均分配）<br>3、线程栈警戒缓冲区大小（位于栈末尾）</strong>    </p>
<p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。<br>之后须用pthread_attr_destroy函数来释放资源。</p>
<p>线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</p>
<h2 id="pthread-attr-init函数"><a href="#pthread-attr-init函数" class="headerlink" title="pthread_attr_init函数"></a>pthread_attr_init函数</h2><p>作用：初始化线程属性<br>函数原型：int pthread_attr_init(pthread_attr_t *attr)<br>成功：0,失败：错误号</p>
<h2 id="pthread-attr-destroy"><a href="#pthread-attr-destroy" class="headerlink" title="pthread_attr_destroy"></a>pthread_attr_destroy</h2><p>作用：销毁线程属性所占用的资源<br>函数原型：int pthread_attr_destroy(pthread_attr_t *attr)<br>成功：0，失败：错误号</p>
<h1 id="线程的分离状态"><a href="#线程的分离状态" class="headerlink" title="线程的分离状态"></a>线程的分离状态</h1><p>线程的分离状态决定一个线程以什么样的方式来终止自己。<br><strong>非分离状态</strong>：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。<br><strong>分离状态</strong>：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。<br>线程分离状态的函数：<br>设置线程属性，分离or非分离<br>int <strong>pthread_attr_setdetachstate</strong>(pthread_attr_t <em>attr, int detachstate);<br>获取程属性，分离or非分离<br> int *</em>pthread_attr_getdetachstate<strong>(pthread_attr_t <em>attr, int *detachstate);<br>参数：<br>*</em>attr</strong>：已初始化的线程属性<br><strong>detachstate</strong>：<br>PTHREAD_CREATE_DETACHED（分离线程）<br>PTHREAD _CREATE_JOINABLE（非分离线程）<br><strong>注意</strong>：如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</p>
<h2 id="pthread-deatch函数"><a href="#pthread-deatch函数" class="headerlink" title="pthread_deatch函数"></a>pthread_deatch函数</h2><p>作用：实现线程分离<br>函数原型:int pthread_detach(pthread_t thread)<br>成功：0,失败：错误号</p>
<p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。<br>进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。<br>也可使用 pthread_create函数参2(线程属性)来设置线程分离。</p>
<p><strong>可以通过pthread_detach设置分离状态，也可以通过线程属性设置分离状态</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;//线程分离</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"thread count %d\n"</span>, n);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_exit((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">void</span> *tred;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	<span class="keyword">pthread_attr_t</span> attr;<span class="comment">//通过线程属性来设置游离态</span></span><br><span class="line">	<span class="keyword">int</span> ret = pthread_attr_init(&amp;attr);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_init error:%s\n"</span>, strerror(ret));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">	ret = pthread_creat(&amp;tid, &amp;attr, tfn, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create error:%s\n"</span>, strerror(ret));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_detach(tid);<span class="comment">//线程分离，自动退出，无系统残留资源</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		err = pthread_join(tid, &amp;tred);<span class="comment">//设置分离属性以后，err=22</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"err = %d\n"</span>,err);</span><br><span class="line">		<span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"thread_join error: %s\n"</span>, strerror(err));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"thread exit code %d\n"</span>, (<span class="keyword">int</span>)tred);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>LWP</tag>
      </tags>
  </entry>
  <entry>
    <title>若不想使用编译器自动生成的函数，就该明确拒绝</title>
    <url>/2020/10/20/%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D/</url>
    <content><![CDATA[<p>如果你想这个类对象独一无二，那么你肯定不想下面的代码成功</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>&#123;</span>……&#125;;</span><br><span class="line">HomeForSale h1;</span><br><span class="line">HomeForSale h2;</span><br><span class="line"><span class="function">HomeForSale <span class="title">h3</span><span class="params">(h1)</span></span>;<span class="comment">//希望它失败</span></span><br><span class="line">h1 = h2;<span class="comment">//同样希望它失败</span></span><br></pre></td></tr></table></figure>
<p>你可以做以下的设计</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	……</span><br><span class="line">	HomeForSale(<span class="keyword">const</span> HomeForSale&amp; );<span class="comment">//只有声明</span></span><br><span class="line">	HomeForSale&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HomeForSale&amp; );</span><br><span class="line">&#125;：</span><br></pre></td></tr></table></figure>
<p>令这些函数为private，使你得以阻止调用它，如果member函数和friend函数调用private函数，会获得一个连接错误。</p>
<p>还有一种便是设计一个base class</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Uncopyable();<span class="comment">//允许derived class对象构造和析构</span></span><br><span class="line">	~Uncopyable();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">	Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp; );<span class="comment">//但阻止copy</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>:</span><span class="keyword">private</span> Uncopyable&#123;……&#125;;</span><br><span class="line"><span class="comment">//class不再声明copy构造函数和copy assignment操作符</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：<br>    为驳回编译器自动提供的机制，可将相应的成员函数声明为private并且不与实现。使用像Uncopyable这样的base class也是一种做法</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>递归翻转链表的一部分</title>
    <url>/2021/03/29/%E9%80%92%E5%BD%92%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>首先我们直接想翻转链表中间的一部分的时候，我们可以先想到如何翻转一整条链表。</p>
<h1 id="翻转一整条链表"><a href="#翻转一整条链表" class="headerlink" title="翻转一整条链表"></a>翻转一整条链表</h1><p>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;nullptr</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Reverse</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	ListNode *last = Reverse(head-&gt;next);</span><br><span class="line">	head-&gt;next-&gt;next = head;</span><br><span class="line">	head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，递归的边界条件为if(head-&gt;next==nullptr)，当递归到链表的最后一个结点时，也就意味着翻转已经完成。<br>简单的描述一下思想：<br>① 1-&gt;Reverse(2-&gt;3-&gt;4-&gt;5)-&gt;nullptr（注意不要一层一层跳进递归，考虑整体会带来什么结果）<br>② nullptr&lt;-1&lt;-Reverse(2-&gt;3-&gt;4-&gt;5)<br>现在我们完成了一整条链表的翻转，接下来我们进行翻转链表的前n个结点。</p>
<h1 id="翻转链表的前n个结点"><a href="#翻转链表的前n个结点" class="headerlink" title="翻转链表的前n个结点"></a>翻转链表的前n个结点</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode *Nptr;</span><br><span class="line"><span class="function">ListNode* <span class="title">ReverseN</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">		Nptr = head-&gt;next;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode *last = Reverse(head-&gt;next, n<span class="number">-1</span>);</span><br><span class="line">	head-&gt;next-&gt;next = head;</span><br><span class="line">	head-&gt;next = Nptr;</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与翻转整条链表有一些区别</p>
<p>①  首先函数的参数ListNode* Reverse(ListNode *head, int n)新增了int n，表示前n个结点。<br>② if(n == 1)这个递归出口表示，当递归到了n个节点以后，将Nptr指向n+1这个节点，以便当前n个结点翻转完以后，将第一个结点的next指向n+1这个结点。</p>
<h1 id="翻转链表中一部分"><a href="#翻转链表中一部分" class="headerlink" title="翻转链表中一部分"></a>翻转链表中一部分</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ReverseBetween</span><span class="params">(ListNode *head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> ReverseN(head, n);</span><br><span class="line">	&#125;</span><br><span class="line">	head-&gt;next = ReverseBetween(head-&gt;next, m<span class="number">-1</span>, n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们已经能够翻转前n个结点，而翻转链表中一部分的话，可以通过递归思想调用ReverseN()。</p>
<p>如果我们想要翻转2-5这个部分，那么m=2,n=5，然而我们可以把第二个结点看作头结点，然后可以看作翻转1-4(m=1,n=4)这个部分，也就是翻转前4个结点，这样我们就可以调用ReverseN(ListNode *head, int n)来翻转。在翻转以后再使第一个结点的next指向ReverseN()的返回值。这样就完成了翻转链表中的一部分结点。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>马拉车算法</title>
    <url>/2021/03/25/%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个字符串，找出里面的回文串的数目，例如cabadabae</p>
<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>①首先以第三位为中心：”c<strong>aba</strong>dabae”的回文串为”aba”<br>②以第五位为中心：”c<strong>abadaba</strong>e”的回文串为”abadaba”<br>③由以上两条可以判断2-4位对称，2-8位对称，那么在判断第七位为中心的回文串时，很容易得出6-8位也同样是对称的。<br>④由于之前计算已经知道第五位为中心的”abadaba”是回文串，而以第四位为中心的a回文长度是a本身，也就是1，所以以第六位为中心的回文长度只能为1，不用再去扩展判断了。<br>⑤我们已经知道了以第七位为中心的回文串最小长度是3了，但是我们不知道加上第9位以后，以第七位为中心的回文串长度会不会改变，所以我们需要继续向后进行扩展。<br>⑥但有一种特殊情况，回文串的中心可能是连个字符的中间，有一种很巧妙的方法可以避免：在每两个字符的中间加上特殊字符’#’,新的字符串特性不变。</p>
<h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><p>①首先，先对字符串进行处理，避免下标越界，可以把字符串最左边加上’!’，最右边加上’$’，再两个字符中间加上’#’。<br>②然后遍历整个字符串，用一个数组来记录以该字符串位中心的回文长度，为了方便计算右边界，在数组中记录长度的一半。<br>③每一次遍历的时候，如果字符在已知回文串最右边界的覆盖下，那么就计算相对右边界回文串中心对称位置，便可以求出以该字符为中心的回文串长度。<br>④判断该长度和右边界，如果达到了右边界，就需要进行中心扩展。如果第三步的字符并没有在已知回文串的覆盖下，直接进行中心扩展，同时更新右边界。<br>⑤最后累加数组每个元素的一半，也就是每个回文串的长度的一半。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.size();</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        str+=<span class="string">"$#"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)&#123;</span><br><span class="line">            str+=c;</span><br><span class="line">            str+=<span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n=str.size();</span><br><span class="line">        str+=<span class="string">"!"</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> imax=<span class="number">0</span>,rmax=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=rmax)&#123;</span><br><span class="line">                f[i]=min(f[imax*<span class="number">2</span>-i],rmax-i+<span class="number">1</span>);<span class="comment">//初始化f[i]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i]=<span class="number">1</span>;<span class="comment">//如果当前字符不在已知回文串覆盖，则f[i]=1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(str[i+f[i]]==str[i-f[i]])&#123;<span class="comment">//中心拓展</span></span><br><span class="line">                f[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i+f[i]<span class="number">-1</span>&gt;rmax)&#123;<span class="comment">//维护最长回文串的左边界和右边界</span></span><br><span class="line">                rmax=i+f[i]<span class="number">-1</span>;</span><br><span class="line">                imax=i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=(f[i]/<span class="number">2</span>);<span class="comment">//因为添加了特殊字符，所以需要减半</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树展开为链表</title>
    <url>/2021/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>114.二叉树展开为链表<br>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p><img src="https://img-blog.csdnimg.cn/20210517181952729.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>示例 1：<br>输入：root = [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]</p>
<h1 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h1><p>①首先我们可以看出，题意就是将二叉树的左子树搬到右子树，然后将右子树接到当前右子树的末端。<br>②<strong>第一种可以用递归实现</strong><br>1、将root的左子树和右子树拉平<br>2、将root的右子树接到左子树的下方<br>3、然后将整个左子树作为右子树<br>需要注意的是当我们用递归实现算法的时候，一定不要跳进递归里面，而要明确函数在当前层的定义。<br>③我们发现递归方法消耗了空间，下面这种解法可以<strong>原地将二叉树拉成链表</strong>。<br>1、首先找到左子树的最右节点<br>2、然后将根节点的右子树放到左子树最右节点的右子树上<br>3、这时候再将根的左子树放到右子树上</p>
<h1 id="code1-递归"><a href="#code1-递归" class="headerlink" title="code1(递归)"></a>code1(递归)</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        flatten(root-&gt;left);<span class="comment">//递归进入左子树</span></span><br><span class="line">        flatten(root-&gt;right);<span class="comment">//递归进入右子树</span></span><br><span class="line">        <span class="comment">//左右子树已经被拉成一条链表</span></span><br><span class="line">        TreeNode *left = root-&gt;left;</span><br><span class="line">        TreeNode *right = root-&gt;right;</span><br><span class="line">        root-&gt;left = <span class="literal">nullptr</span>;<span class="comment">//将节点的左子节点置为空</span></span><br><span class="line">        root-&gt;right = left;<span class="comment">//将节点的左子节点接到节点的右子节点</span></span><br><span class="line">        TreeNode *temp = root;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;<span class="comment">//将原先的右子节点接到当前右子树的末端</span></span><br><span class="line">            temp = temp-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;right = right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="code2"><a href="#code2" class="headerlink" title="code2"></a>code2</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                TreeNode *most_right = root-&gt;left;<span class="comment">//左子树最右节点</span></span><br><span class="line">                <span class="keyword">while</span>(most_right-&gt;right != <span class="literal">nullptr</span>)&#123;<span class="comment">//找最右节点</span></span><br><span class="line">                    most_right = most_right-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                most_right-&gt;right = root-&gt;right;<span class="comment">//根的右子树接到最右节点的右子树</span></span><br><span class="line">                root-&gt;right = root-&gt;left;<span class="comment">//根的左子树接到右子树</span></span><br><span class="line">                root-&gt;left = <span class="literal">nullptr</span>;<span class="comment">//左子树置为空</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;<span class="comment">//继续下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>根据前中后序遍历构造二叉树</title>
    <url>/2021/05/18/%E6%A0%B9%E6%8D%AE%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="从前序与中序遍历中构造二叉树"><a href="#从前序与中序遍历中构造二叉树" class="headerlink" title="从前序与中序遍历中构造二叉树"></a>从前序与中序遍历中构造二叉树</h1><p>题目：<br>105. 从前序与中序遍历序列构造二叉树<br>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p>
<p>   3<br>   /  \<br>  9  20<br>    /       \<br>   15   7</p>
<h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>①首先找到根节点比较简单，根节点就是前序遍历的第一个元素。<br>②然后<strong>关键就是</strong>通过根节点在中序遍历找出二叉树的左子树与右子树的元素以及数量，递归调用构造二叉树。<br>③如下图所示对于递归构造左子树，前序遍历的范围是[preStart + 1, preStart + leftSize]，中序遍历的范围是[inStart, index - 1]。<br>④对于递归构造右子树，前序遍历的范围是[preStart + leftSize + 1, preEnd]，中序遍历的范围是[index + 1, inEnd]。</p>
<p><img src="https://img-blog.csdnimg.cn/20210518171919635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.size() - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(inStart &gt; inEnd)&#123;<span class="comment">//前序遍历数组左索引大于右索引就返回</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> rootVal = preorder[preStart];<span class="comment">//root节点对应的值就是前序遍历数组的第一个</span></span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//rootVal在中序遍历数组中的索引</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(rootVal == inorder[i])&#123;</span><br><span class="line">               index = i;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> leftSize = index - inStart;<span class="comment">//前序遍历数组中，左子树节点的数量</span></span><br><span class="line">       TreeNode *root = <span class="keyword">new</span> TreeNode(rootVal);<span class="comment">//构造当前节点</span></span><br><span class="line">       <span class="comment">//递归构造左右子树</span></span><br><span class="line">       root-&gt;left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize, inorder, inStart, index - <span class="number">1</span>);</span><br><span class="line">       root-&gt;right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd, inorder, index + <span class="number">1</span>, inEnd);</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h1 id="从后序与中序遍历中构造二叉树"><a href="#从后序与中序遍历中构造二叉树" class="headerlink" title="从后序与中序遍历中构造二叉树"></a>从后序与中序遍历中构造二叉树</h1><p>题目：<br>106. 从中序与后序遍历序列构造二叉树<br>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p>
<p>   3<br>   / \<br>  9  20<br>    /  \<br>   15   7</p>
<h2 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h2><p>与上一题相同，只需要找出根结点的左右子树对应中序遍历以及后序遍历的索引递归即可。</p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(postStart &gt; postEnd)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> rootVal = postorder[postEnd];</span><br><span class="line">       <span class="keyword">int</span> index;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(rootVal == inorder[i])&#123;</span><br><span class="line">               index = i;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> leftSize = index - inStart;</span><br><span class="line">       TreeNode *root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">       root-&gt;left = build(inorder, inStart, index - <span class="number">1</span>,postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">       root-&gt;right = build(inorder, index + <span class="number">1</span>, inEnd,postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>构造最大二叉树</title>
    <url>/2021/05/18/%E6%9E%84%E9%80%A0%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>654 最大二叉树<br>给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：</p>
<p>二叉树的根是数组 nums 中的最大元素。<br>左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。<br>右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。<br>返回有给定数组 nums 构建的 最大二叉树 。</p>
<p> <img src="https://img-blog.csdnimg.cn/20210518164315528.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzY5NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>示例 1：</p>
<p>输入：nums = [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p>
<ul>
<li>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。<ul>
<li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。<ul>
<li>空数组，无子节点。</li>
<li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul>
<li>空数组，无子节点。</li>
<li>只有一个元素，所以子节点是一个值为 1 的节点。</li>
</ul>
</li>
</ul>
</li>
<li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul>
<li>只有一个元素，所以子节点是一个值为 0 的节点。</li>
<li>空数组，无子节点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h1><p>①对于构造二叉树，根节点要做的就是想办法把自己构造出来。<br>②先遍历数组找出最大值，然后把根节点构造出来，然后对最大值的左边数组和右边数组进行递归调用，作为根节点的左右子树。</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_num = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left;i &lt;= right;i++)&#123;<span class="comment">//找到[left, right]中最大的元素，以及索引</span></span><br><span class="line">            <span class="keyword">if</span>(max_num &lt; nums[i])&#123;</span><br><span class="line">                max_num = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(max_num);<span class="comment">//将最大的元素构造成当前nums的根节点</span></span><br><span class="line">        root-&gt;left = build(nums, left, index - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = build(nums, index + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
</search>
